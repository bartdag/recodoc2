<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 26. Database Portability Considerations</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="best-practices.html" title="Chapter 25. Best Practices"/><link rel="next" href="bi01.html" title="References"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Chapter 26. Database Portability Considerations</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="portability.html#portability-basics">26.1. Portability Basics</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialect">26.2. Dialect</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialectresolver">26.3. Dialect resolution</a></span></dt><dt><span class="section"><a href="portability.html#portability-idgen">26.4. Identifier generation</a></span></dt><dt><span class="section"><a href="portability.html#portability-functions">26.5. Database functions</a></span></dt><dt><span class="section"><a href="portability.html#portability-types">26.6. Type mappings</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>26.1. Portability Basics</h2></div></div></div><p>
            One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is
            the notion of database portability.  This could mean an internal IT user migrating from one
            database vendor to another, or it could mean a framework or deployable application consuming
            Hibernate to simultaneously target multiple database products by their users.  Regardless of
            the exact scenario, the basic idea is that you want Hibernate to help you run against any number
            of databases without changes to your code, and ideally without any changes to the mapping metadata.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>26.2. Dialect</h2></div></div></div><p>
            The first line of portability for Hibernate is the dialect, which is a specialization of the
            <code class="classname">org.hibernate.dialect.Dialect</code> contract.  A dialect encapsulates all
            the differences in how Hibernate must communicate with a particular database to accomplish some
            task like getting a sequence value or structuring a SELECT query.  Hibernate bundles a wide range
            of dialects for many of the most popular databases.  If you find that your particular database is
            not among them, it is not terribly difficult to write your own.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>26.3. Dialect resolution</h2></div></div></div><p>
            Originally, Hibernate would always require that users specify which dialect to use.  In the case
            of users looking to simultaneously target multiple databases with their build that was problematic.
            Generally this required their users to configure the Hibernate dialect or defining their own method
            of setting that value.
        </p><p>
            Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect
            to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a
            <code class="interfacename">java.sql.Connection</code> to that database.  This was much better, expect
            that this resolution was limited to databases Hibernate know about ahead of time and was in no way
            configurable or overrideable.
        </p><p>
            Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine
            which dialect to should be used by relying on a series of delegates which implement the
            <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a
            single method:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA">&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_keyword"&gt;public&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;&amp;nbsp;&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_type"&gt;Dialect&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;&amp;nbsp;resolveDialect&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;(&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_type"&gt;DatabaseMetaData&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;&amp;nbsp;metaData&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;)&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;&amp;nbsp;&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_keyword"&gt;throws&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;&amp;nbsp;&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_type"&gt;JDBCConnectionException&lt;/span&gt;</pre><p>.
            The basic contract here is that if the resolver 'understands' the given database metadata then
            it returns the corresponding Dialect; if not it returns null and the process continues to the next
            resolver.  The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code>
            as possibly being thrown.  A JDBCConnectionException here is interpreted to imply a "non transient"
            (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution
            attempts.  All other exceptions result in a warning and continuing on to the next resolver.
        </p><p>
            The cool part about these resolvers is that users can also register their own custom resolvers
            which will be processed ahead of the built-in Hibernate ones.  This might be useful in a number of
            different situations: it allows easy integration for auto-detection of dialects beyond those
            shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular
            database is recognized; etc.  To register one or more resolvers, simply specify them (seperated by
            commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the
            <code class="constant">DIALECT_RESOLVERS</code> constant on
            <code class="classname">org.hibernate.cfg.Environment</code>).
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>26.4. Identifier generation</h2></div></div></div><p>
            When considering portability between databases, another important decision is selecting the
            identifier generation stratagy you want to use.  Originally Hibernate provided the
            <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between
            a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span>
            strategy depending on the capability of the underlying database.  However, an insidious implication
            of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span>
            generation and some which do not.  <span class="emphasis"><em>identity</em></span> generation relies on the SQL
            definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is
            known as a post-insert generation strategy becauase the insert must actually happen before we can
            know the identifier value.  Because Hibernate relies on this identifier value to uniquely reference
            entities within a persistence context it must then issue the insert
            immediately when the users requests the entitiy be associated with the session (like via
            save() e.g.) regardless of current transactional semantics.

            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    Hibernate was changed slightly once the implication of this was better understood so that
                    the insert is delayed in cases where that is feasible.
                </p></div><p>

            The underlying issue is that the actual semanctics of the application itself changes in these cases.
        </p><p>
            Starting with version 3.2.3, Hibernate comes with a set of
            <a class="ulink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting
            portability in a much different way.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators:
                    </p><div class="itemizedlist"><ul><li><p>
                                <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code>
                            </p></li><li><p>
                                <code class="classname">org.hibernate.id.enhanced.TableGenerator</code>
                            </p></li></ul></div><p>
                </p></div><p>
            The idea behind these generators is to port the actual semantics of the identifer value
            generation to the different databases.  For example, the
            <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of
            a sequence on databases which do not support sequences by using a table.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>26.5. Database functions</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                This is an area in Hibernate in need of improvement.  In terms of portability concerns,
                this function handling currently works pretty well from HQL; however, it is quite lacking
                in all other aspects.
            </p></div><p>
            SQL functions can be referenced in many ways by users.  However, not all databases
            support the same set of functions.  Hibernate, provides a means of mapping a
            <span class="emphasis"><em>logical</em></span> function name to a delegate which knows how to render
            that particular function, perhaps even using a totally different physical function call.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
                    Technically this function registration is handled through the
                    <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class
                    which is intended to allow users to provide custom function definitions without
                    having to provide a custom dialect.  This specific behavior is not fully completed
                    as of yet.
                </p><p>
                    It is sort of implemented such that users can programatically register functions
                    with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions
                    will be recognized for HQL.
                </p></div><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>26.6. Type mappings</h2></div></div></div><p>
            This section scheduled for completion at a later date...
        </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Prev</strong>Chapter 25. Best Practices</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Next</strong>References</a></li></ul></body></html>