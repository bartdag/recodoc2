<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;6.&nbsp;Spring AOP: Aspect Oriented Programming with Spring</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Spring - Java/J2EE Application Framework"><link rel="up" href="index.html" title="Spring - Java/J2EE Application Framework"><link rel="previous" href="validation.html" title="Chapter&nbsp;5.&nbsp;PropertyEditors, data binding, validation and the BeanWrapper"><link rel="next" href="aspectj.html" title="Chapter&nbsp;7.&nbsp;AspectJ Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;6.&nbsp;Spring AOP: Aspect Oriented Programming with Spring</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="validation.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="aspectj.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aop"></a>Chapter&nbsp;6.&nbsp;Spring AOP: Aspect Oriented Programming with Spring</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction"></a>6.1.&nbsp;Concepts</h2></div></div><div></div></div><p><span class="emphasis"><em>Aspect-Oriented Programming</em></span>
    (<span class="emphasis"><em>AOP</em></span>) complements OOP by providing another way of
    thinking about program structure. While OO decomposes applications into a
    hierarchy of objects, AOP decomposes programs into
    <span class="emphasis"><em>aspects</em></span> or <span class="emphasis"><em>concerns</em></span>. This
    enables modularization of concerns such as transaction management that
    would otherwise cut across multiple objects. (Such concerns are often
    termed <span class="emphasis"><em>crosscutting</em></span> concerns.)</p><p>One of the key components of Spring is the <span class="emphasis"><em>AOP
    framework</em></span>. While the Spring IoC containers (BeanFactory and
    ApplicationContext) do not depend on AOP, meaning you don't need to use
    AOP if you don't want to, AOP complements Spring IoC to provide a very
    capable middleware solution.</p><p>AOP is used in Spring:</p><div class="itemizedlist"><ul type="disc"><li><p>To provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <span class="emphasis"><em>declarative transaction management</em></span>,
        which builds on Spring's transaction abstraction.</p></li><li><p>To allow users to implement custom aspects, complementing their
        use of OOP with AOP.</p></li></ul></div><p>Thus you can view Spring AOP as either an enabling technology that
    allows Spring to provide declarative transaction management without EJB;
    or use the full power of the Spring AOP framework to implement custom
    aspects.</p><i><span class="remark">If you are interested only in generic declarative services or
    other pre-packaged declarative middleware services such as pooling, you
    don't need to work directly with Spring AOP, and can skip most of this
    chapter.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn"></a>6.1.1.&nbsp;AOP concepts</h3></div></div><div></div></div><p>Let us begin by defining some central AOP concepts. These terms
      are not Spring-specific. Unfortunately, AOP terminology is not
      particularly intuitive. However, it would be even more confusing if
      Spring used its own terminology.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Aspect</em></span>: A modularization of a concern for
          which the implementation might otherwise cut across multiple
          objects. Transaction management is a good example of a crosscutting
          concern in J2EE applications. Aspects are implemented using Spring
          as Advisors or interceptors.</p></li><li><p><span class="emphasis"><em>Joinpoint</em></span>: Point during the execution of
          a program, such as a method invocation or a particular exception
          being thrown. In Spring AOP, a joinpoint is always method
          invocation. Spring does not use the term joinpoint prominently;
          joinpoint information is accessible through methods on the
          <tt class="literal">MethodInvocation</tt> argument passed to interceptors,
          and is evaluated by implementations of the
          <tt class="literal">org.springframework.aop.Pointcut
          </tt>interface.</p></li><li><p><span class="emphasis"><em>Advice</em></span>: Action taken by the AOP framework
          at a particular joinpoint. Different types of advice include
          "around," "before" and "throws" advice. Advice types are discussed
          below. Many AOP frameworks, including Spring, model an advice as an
          <span class="emphasis"><em>interceptor</em></span>, maintaining a chain of
          interceptors "around" the joinpoint.</p></li><li><p><span class="emphasis"><em>Pointcut</em></span>: A set of joinpoints specifying
          when an advice should fire. An AOP framework must allow developers
          to specify pointcuts: for example, using regular expressions.</p></li><li><p><span class="emphasis"><em>Introduction</em></span>: Adding methods or fields to
          an advised class. Spring allows you to introduce new interfaces to
          any advised object. For example, you could use an introduction to
          make any object implement an <tt class="literal">IsModified</tt>
          interface, to simplify caching.</p></li><li><p><span class="emphasis"><em>Target object</em></span>: Object containing the
          joinpoint. Also referred to as <span class="emphasis"><em>advised</em></span> or
          <span class="emphasis"><em>proxied</em></span> object.</p></li><li><p><span class="emphasis"><em>AOP proxy</em></span>: Object created by the AOP
          framework, including advice. In Spring, an AOP proxy will be a JDK
          dynamic proxy or a CGLIB proxy.</p></li><li><p><span class="emphasis"><em>Weaving</em></span>: Assembling aspects to create an
          advised object. This can be done at compile time (using the AspectJ
          compiler, for example), or at runtime. Spring, like other pure Java
          AOP frameworks, performs weaving at runtime.</p></li></ul></div><p>Different advice types include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a
          joinpoint such as a method invocation. This is the most powerful
          kind of advice. Around advices will perform custom behavior before
          and after the method invocation. They are responsible for choosing
          whether to proceed to the joinpoint or to shortcut executing by
          returning their own return value or throwing an exception.</p></li><li><p><span class="emphasis"><em>Before advice</em></span>: Advice that executes
          before a joinpoint, but which does not have the ability to prevent
          execution flow proceeding to the joinpoint (unless it throws an
          exception).</p></li><li><p><span class="emphasis"><em>Throws advice</em></span>: Advice to be executed if a
          method throws an exception. Spring provides strongly typed throws
          advice, so you can write code that catches the exception (and
          subclasses) you're interested in, without needing to cast from
          Throwable or Exception.</p></li><li><p><span class="emphasis"><em>After returning advice</em></span>: Advice to be
          executed after a joinpoint completes normally: for example, if a
          method returns without throwing an exception.</p></li></ul></div><p>Around advice is the most general kind of advice. Most
      interception-based AOP frameworks, such as Nanning Aspects, provide only
      around advice.</p><p>As Spring, like AspectJ, provides a full range of advice types, we
      recommend that you use the least powerful advice type that can implement
      the required behavior. For example, if you need only to update a cache
      with the return value of a method, you are better off implementing an
      after returning advice than an around advice, although an around advice
      can accomplish the same thing. Using the most specific advice type
      provides a simpler programming model with less potential for errors. For
      example, you don't need to invoke the <tt class="literal">proceed()</tt>
      method on the MethodInvocation used for around advice, and hence can't
      fail to invoke it.</p><p>The pointcut concept is the key to AOP, distinguishing AOP from
      older technologies offering interception. Pointcuts enable advice to be
      targeted independently of the OO hierarchy. For example, an around
      advice providing declarative transaction management can be applied to a
      set of methods spanning multiple objects. Thus pointcuts provide the
      structural element of AOP.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn"></a>6.1.2.&nbsp;Spring AOP capabilities and goals</h3></div></div><div></div></div><p>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</p><p>Spring currently supports interception of method invocations.
      Field interception is not implemented, although support for field
      interception could be added without breaking the core Spring AOP
      APIs.</p><i><span class="remark">Field interception arguably violates OO encapsulation. We don't
      believe it is wise in application development. If you require field
      interception, consider using AspectJ.</span></i><p>Spring provides classes to represent pointcuts and different
      advice types. Spring uses the term <span class="emphasis"><em>advisor</em></span> for an
      object representing an aspect, including both an advice and a pointcut
      targeting it to specific joinpoints.</p><p>Different advice types are <tt class="literal">MethodInterceptor</tt>
      (from the AOP Alliance interception API); and the advice interfaces
      defined in the <tt class="literal">org.springframework.aop</tt> package. All
      advices must implement the <tt class="literal">org.aopalliance.aop.Advice</tt>
      tag interface. Advices supported out the box are
      <tt class="literal">MethodInterceptor</tt> ; <tt class="literal">ThrowsAdvice</tt>;
      <tt class="literal">BeforeAdvice</tt>; and
      <tt class="literal">AfterReturningAdvice</tt>. We'll discuss advice types in
      detail below.</p><p>Spring implements the <span class="emphasis"><em>AOP Alliance</em></span>
      interception interfaces (<a href="http://www.sourceforge.net/projects/aopalliance" target="_top">http://www.sourceforge.net/projects/aopalliance</a>).
      Around advice must implement the AOP Alliance
      <tt class="literal">org.aopalliance.intercept.MethodInterceptor</tt>
      interface. Implementations of this interface can run in Spring or any
      other AOP Alliance compliant implementation. Currently JAC implements
      the AOP Alliance interfaces, and Nanning and Dynaop are likely to in
      early 2004.</p><p>Spring's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</p><p>Thus, for example, Spring's AOP functionality is normally used in
      conjunction with a Spring IoC container. AOP advice is specified using
      normal bean definition syntax (although this allows powerful
      "autoproxying" capabilities); advice and pointcuts are themselves
      managed by Spring IoC: a crucial difference from other AOP
      implementations. There are some things you can't do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects.
      AspectJ is probably the best choice in such cases. However, our
      experience is that Spring AOP provides an excellent solution to most
      problems in J2EE applications that are amenable to AOP.</p><p>Spring AOP will never strive to compete with AspectJ or
      AspectWerkz to provide a comprehensive AOP solution. We believe that
      both proxy-based frameworks like Spring and full-blown frameworks such
      as AspectJ are valuable, and that they are complementary, rather than in
      competition. Thus a major priority for Spring 1.1 will be seamlessly
      integrating Spring AOP and IoC with AspectJ, to enable all uses of AOP
      to be catered for within a consistent Spring-based application
      architecture. This integration will not affect the Spring AOP API or the
      AOP Alliance API; Spring AOP will remain backward-compatible.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies"></a>6.1.3.&nbsp;AOP Proxies in Spring</h3></div></div><div></div></div><p>Spring defaults to using J2SE <span class="emphasis"><em>dynamic proxies</em></span>
      for AOP proxies. This enables any interface or set of interfaces to be
      proxied.</p><p>Spring can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object doesn't implement an interface. As it's good practice to
      <span class="emphasis"><em>program to interfaces rather than classes</em></span>, business
      objects normally will implement one or more business interfaces.</p><p>It is possible to force the use of CGLIB: we'll discuss this
      below, and explain why you'd want to do this.</p><i><span class="remark">Beyond Spring 1.0, Spring may offer additional types of AOP
      proxy, including wholly generated classes. This won't affect the
      programming model.</span></i></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction-pointcuts"></a>6.2.&nbsp;Pointcuts in Spring</h2></div></div><div></div></div><p>Let's look at how Spring handles the crucial pointcut
    concept.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3772"></a>6.2.1.&nbsp;Concepts</h3></div></div><div></div></div><p>Spring's pointcut model enables pointcut reuse independent of
      advice types. It's possible to target different advice using the same
      pointcut.</p><p>The <tt class="literal">org.springframework.aop.Pointcut</tt> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</p><pre class="programlisting">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</pre><p>Splitting the <tt class="literal">Pointcut</tt> interface into two parts
      allows reuse of class and method matching parts, and fine-grained
      composition operations (such as performing a "union" with another method
      matcher).</p><p>The <tt class="literal">ClassFilter</tt> interface is used to restrict
      the pointcut to a given set of target classes. If the
      <tt class="literal">matches()</tt> method always returns true, all target
      classes will be matched:</p><pre class="programlisting">public interface ClassFilter {

    boolean matches(Class clazz);
}</pre><p>The <tt class="literal">MethodMatcher</tt> interface is normally more
      important. The complete interface is shown below:</p><pre class="programlisting">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</pre><p>The <tt class="literal">matches(Method, Class) </tt>method is used to
      test whether this pointcut will ever match a given method on a target
      class. This evaluation can be performed when an AOP proxy is created, to
      avoid the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <tt class="literal">isRuntime()</tt> method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</p><p>Most MethodMatchers are static, meaning that their
      <tt class="literal">isRuntime()</tt> method returns false. In this case, the
      3-argument matches method will never be invoked.</p><i><span class="remark">If possible, try to make pointcuts static, allowing the AOP
      framework to cache the results of pointcut evaluation when an AOP proxy
      is created.</span></i></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3821"></a>6.2.2.&nbsp;Operations on pointcuts</h3></div></div><div></div></div><p>Spring supports operations on pointcuts: notably,
      <span class="emphasis"><em>union</em></span> and <span class="emphasis"><em>intersection</em></span>.</p><p>Union means the methods that either pointcut matches.</p><p>Intersection means the methods that both pointcuts match.</p><p>Union is usually more useful.</p><p>Pointcuts can be composed using the static methods in the
      <span class="emphasis"><em>org.springframework.aop.support.Pointcuts</em></span> class, or
      using the <span class="emphasis"><em>ComposablePointcut</em></span> class in the same
      package.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3846"></a>6.2.3.&nbsp;Convenience pointcut implementations</h3></div></div><div></div></div><p>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3851"></a>6.2.3.1.&nbsp;Static pointcuts</h4></div></div><div></div></div><p>Static pointcuts are based on method and target class, and
        cannot take into account the method's arguments. Static pointcuts are
        sufficient--and best--for most usages. It's possible for Spring to
        evaluate a static pointcut only once, when a method is first invoked:
        after that, there is no need to evaluate the pointcut again with each
        method invocation.</p><p>Let's consider some static pointcut implementations included
        with Spring.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3858"></a>6.2.3.1.1.&nbsp;Regular expression pointcuts</h5></div></div><div></div></div><p>One obvious way to specific static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible.
          <tt class="literal">org.springframework.aop.support.Perl5RegexpMethodPointcut</tt>
          is a generic regular expression pointcut, using Perl 5 regular
          expression syntax. the <tt class="literal">Perl5RegexpMethodPointcut</tt> class
					depends on Jakarta ORO for regular expression matching. Spring also provides
					the <tt class="literal">JdkRegexpMethodPointcut</tt> class that uses the regular
					expression support in JDK 1.4+.</p><p>Using the <tt class="literal">Perl5RegexpMethodPointcut</tt> class,
					you can provide a list of pattern Strings. If any of these is a match,
					the pointcut will evaluate to true. (So the result is effectively the
					union of these pointcuts.)</p><p>The usage is shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulatePointcut" 
    class="org.springframework.aop.support.Perl5RegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Spring provides a convenience class,
          <tt class="literal">RegexpMethodPointcutAdvisor</tt>, that allows us to
          reference an Advice also (Remember that an Advice can be an interceptor,
					before advice, throws advice etc.). Behind the scenes, Spring will use the
					<tt class="literal">JdkRegexpMethodPointcut</tt> on J2SE 1.4 or above, and will
					fall back to <tt class="literal">Perl5RegexpMethodPointcut</tt> on older VMs.
					The use of <tt class="literal">Perl5RegexpMethodPointcut</tt> can be forced
				  by setting the <tt class="literal">perl5</tt> property to true.
					Using <tt class="literal">RegexpMethodPointcutAdvisor</tt> simplifies wiring,
					as the one bean serves as both pointcut and advisor, as shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulateAdvisor" 
    class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>RegexpMethodPointcutAdvisor</em></span> can be used
          with any Advice type.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3909"></a>6.2.3.1.2.&nbsp;Attribute-driven pointcuts</h5></div></div><div></div></div><p>An important type of static pointcut is a
          <span class="emphasis"><em>metadata-driven</em></span> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3917"></a>6.2.3.2.&nbsp;Dynamic pointcuts</h4></div></div><div></div></div><p>Dynamic pointcuts are costlier to evaluate than static
        pointcuts. They take into account method
        <span class="emphasis"><em>arguments</em></span>, as well as static information. This
        means that they must be evaluated with every method invocation; the
        result cannot be cached, as arguments will vary.</p><p>The main example is the <tt class="literal">control flow</tt>
        pointcut.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3930"></a>6.2.3.2.1.&nbsp;Control flow pointcuts</h5></div></div><div></div></div><p>Spring control flow pointcuts are conceptually similar to
          AspectJ <span class="emphasis"><em>cflow</em></span> pointcuts, although less
          powerful. (There is currently no way to specify that a pointcut
          executes below another pointcut.) A control flow pointcut matches
          the current call stack. For example, it might fire if the joinpoint
          was invoked by a method in the <tt class="literal">com.mycompany.web</tt>
          package, or by the <tt class="literal">SomeCaller</tt> class. Control flow
          pointcuts are specified using the
          <tt class="literal">org.springframework.aop.support.ControlFlowPointcut
          </tt>class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Control flow pointcuts are significantly more expensive to
              evaluate at runtime than even other dynamic pointcuts. In Java
              1.4, the cost is about 5 times that of other dynamic pointcuts;
              in Java 1.3 more than 10.</p></td></tr></table></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3950"></a>6.2.4.&nbsp;Pointcut superclasses</h3></div></div><div></div></div><p>Spring provides useful pointcut superclasses to help you to
      implement your own pointcuts.</p><p>Because static pointcuts are most useful, you'll probably subclass
      StaticMethodMatcherPointcut, as shown below. This requires implemented
      just one abstract method (although it's possible to override other
      methods to customize behavior):</p><pre class="programlisting">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</pre><p>There are also superclasses for dynamic pointcuts.</p><p>You can use custom pointcuts with any advice type in Spring 1.0
      RC2 and above.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3963"></a>6.2.5.&nbsp;Custom pointcuts</h3></div></div><div></div></div><p>Because pointcuts in Spring are Java classes, rather than language
      features (as in AspectJ) it's possible to declare custom pointcuts,
      whether static or dynamic. However, there is no support out of the box
      for the sophisticated pointcut expressions that can be coded in AspectJ
      syntax. However, custom pointcuts in Spring can be arbitrarily
      complex.</p><i><span class="remark">Later versions of Spring may offer support for "semantic
      pointcuts" as offered by JAC: for example, "all methods that change
      instance variables in the target object."</span></i></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3970"></a>6.3.&nbsp;Advice types in Spring</h2></div></div><div></div></div><p>Let's now look at how Spring AOP handles advice.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3975"></a>6.3.1.&nbsp;Advice lifecycles</h3></div></div><div></div></div><p>Spring advices can be shared across all advised objects, or unique
      to each advised object. This corresponds to
      <span class="emphasis"><em>per-class</em></span> or <span class="emphasis"><em>per-instance</em></span>
      advice.</p><p>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; they merely act on the method and
      arguments.</p><p>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied
      object.</p><p>It's possible to use a mix of shared and per-instance advice in
      the same AOP proxy.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-advice-types"></a>6.3.2.&nbsp;Advice types in Spring</h3></div></div><div></div></div><p>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let us look at the basic
      concepts and standard advice types.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3997"></a>6.3.2.1.&nbsp;Interception around advice</h4></div></div><div></div></div><p>The most fundamental advice type in Spring is
        <span class="emphasis"><em>interception around advice</em></span>.</p><p>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</p><pre class="programlisting">public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</pre><p>The <span class="emphasis"><em>MethodInvocation</em></span> argument to the
        <span class="emphasis"><em>invoke()</em></span> method exposes the method being invoked;
        the target joinpoint; the AOP proxy; and the arguments to the method.
        The <span class="emphasis"><em>invoke()</em></span> method should return the
        invocation's result: the return value of the joinpoint.</p><p>A simple <span class="emphasis"><em>MethodInterceptor</em></span> implementation
        looks as follows:</p><pre class="programlisting">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</pre><p>Note the call to the MethodInvocation's
        <span class="emphasis"><em>proceed()</em></span> method. This proceeds down the
        interceptor chain towards the joinpoint. Most interceptors will invoke
        this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don't want to do this without good reason!</p><i><span class="remark">MethodInterceptors offer interoperability with other AOP
        Alliance-compliant AOP implementations. The other advice types
        discussed in the remainder of this section implement common AOP
        concepts, but in a Spring-specific way. While there is an advantage in
        using the most specific advice type, stick with MethodInterceptor
        around advice if you are likely to want to run the aspect in another
        AOP framework. Note that pointcuts are not currently interoperable
        between frameworks, and the AOP Alliance does not currently define
        pointcut interfaces.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4034"></a>6.3.2.2.&nbsp;Before advice</h4></div></div><div></div></div><p>A simpler advice type is a <span class="bold"><b>before
        advice</b></span>. This does not need a
        <tt class="literal">MethodInvocation</tt> object, since it will only be
        called before entering the method.</p><p>The main advantage of a before advice is that there is no need
        to invoke the <tt class="literal">proceed() </tt>method, and therefore no
        possibility of inadvertently failing to proceed down the interceptor
        chain.</p><p>The <tt class="literal">MethodBeforeAdvice</tt> interface is shown
        below. (Spring's API design would allow for field before advice,
        although the usual objects apply to field interception and it's
        unlikely that Spring will ever implement it).</p><pre class="programlisting">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</pre><p>Note the the return type is <tt class="literal">void</tt>. Before
        advice can insert custom behavior before the joinpoint executes, but
        cannot change the return value. If a before advice throws an
        exception, this will abort further execution of the interceptor chain.
        The exception will propagate back up the interceptor chain. If it is
        unchecked, or on the signature of the invoked method, it will be
        passed directly to the client; otherwise it will be wrapped in an
        unchecked exception by the AOP proxy.</p><p>An example of a before advice in Spring, which counts all
        method invocations:</p><pre class="programlisting">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</pre><i><span class="remark">Before advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4068"></a>6.3.2.3.&nbsp;Throws advice</h4></div></div><div></div></div><p><span class="bold"><b>Throws advice</b></span> is invoked after
        the return of the joinpoint if the joinpoint threw an exception.
        Spring offers typed throws advice. Note that this means that the
        <tt class="literal">org.springframework.aop.ThrowsAdvice</tt> interface does
        not contain any methods: it is a tag interface identifying that the
        given object implements one or more typed throws advice methods. These
        should be of form</p><pre class="programlisting">afterThrowing([Method], [args], [target], subclassOfThrowable) </pre><p>Only the last argument is required. Thus there from one to four
        arguments, depending on whether the advice method is interested in the
        method and arguments. The following are examples of throws
        advices.</p><p>This advice will be invoked if a
        <tt class="literal">RemoteException</tt> is thrown (including
        subclasses):</p><pre class="programlisting">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</pre><p>The following advice is invoked if a
        <span class="emphasis"><em>ServletException</em></span> is thrown. Unlike the above
        advice, it declares 4 arguments, so that it has access to the invoked
        method, method arguments and target object:</p><pre class="programlisting">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><p>The final example illustrates how these two methods could be
        used in a single class, which handles both
        <tt class="literal">RemoteException</tt> and
        <tt class="literal">ServletException</tt>. Any number of throws advice
        methods can be combined in a single class.</p><pre class="programlisting">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><i><span class="remark">Throws advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4108"></a>6.3.2.4.&nbsp;After Returning advice</h4></div></div><div></div></div><p>An after returning advice in Spring must implement the
        <span class="emphasis"><em>org.springframework.aop.AfterReturningAdvice</em></span>
        interface, shown below:</p><pre class="programlisting">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) 
            throws Throwable;
}</pre><p>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and
        target.</p><p>The following after returning advice counts all successful
        method invocations that have not thrown exceptions:</p><pre class="programlisting">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</pre><p>This advice doesn't change the execution path. If it throws an
        exception, this will be thrown up the interceptor chain instead of the
        return value.</p><i><span class="remark">After returning advice can be used with any pointcut.</span></i></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4128"></a>6.3.2.5.&nbsp;Introduction advice</h4></div></div><div></div></div><p>Spring treats introduction advice as a special kind of
        interception advice.</p><p>Introduction requires an <tt class="literal">IntroductionAdvisor</tt>,
        and an <tt class="literal">IntroductionInterceptor</tt>, implementing the
        following interface:</p><pre class="programlisting">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</pre><p>The <tt class="literal">invoke() </tt>method inherited from the AOP
        Alliance <tt class="literal">MethodInterceptor</tt> interface must implement
        the introduction: that is, if the invoked method is on an introduced
        interface, the introduction interceptor is responsible for handling
        the method call--it cannot invoke <tt class="literal">proceed()</tt>.</p><p>Introduction advice cannot be used with any pointcut, as it
        applies only at class, rather than method, level. You can only use
        introduction advice with the <tt class="literal">IntroductionAdvisor</tt>, which
        has the following methods:</p><pre class="programlisting">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

	ClassFilter getClassFilter();

	void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

	Class[] getInterfaces();
}</pre><p>There is no <tt class="literal">MethodMatcher</tt>, and hence no
        <tt class="literal">Pointcut</tt>, associated with introduction advice. Only
        class filtering is logical.</p><p>The <tt class="literal">getInterfaces()</tt> method returns the
        interfaces introduced by this advisor.</p> The <tt class="literal">validateInterfaces()</tt>
		method is used internally to see whether or not the introduced interfaces can be
		implemented by the configured <tt class="literal">IntroductionInterceptor</tt>.

		<p>Let's look at a simple example from the Spring test suite. Let's
        suppose we want to introduce the following interface to one or more
        objects:</p><pre class="programlisting">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</pre><p>This illustrates a <span class="bold"><b>mixin</b></span>. We
        want to be able to cast advised objects to Lockable, whatever their
        type, and call lock and unlock methods. If we call the lock() method,
        we want all setter methods to throw a
        <tt class="literal">LockedException</tt>. Thus we can add an aspect that
        provides the ability to make objects immutable, without them having
        any knowledge of it: a good example of AOP.</p><p>Firstly, we'll need an
        <tt class="literal">IntroductionInterceptor</tt> that does the heavy
        lifting. In this case, we extend the
        <tt class="literal">org.springframework.aop.support.DelegatingIntroductionInterceptor</tt>
        convenience class. We could implement IntroductionInterceptor
        directly, but using
        <tt class="literal">DelegatingIntroductionInterceptor</tt> is best for most
        cases.</p><p>The <tt class="literal">DelegatingIntroductionInterceptor</tt> is
        designed to delegate an introduction to an actual implementation of
        the introduced interface(s), concealing the use of interception to do
        so. The delegate can be set to any object using a constructor
        argument; the default delegate (when the no-arg constructor is used)
        is this. Thus in the example below, the delegate is the
        <tt class="literal">LockMixin</tt> subclass of
        <tt class="literal">DelegatingIntroductionInterceptor</tt>. Given a delegate
        (by default itself) a
        <tt class="literal">DelegatingIntroductionInterceptor</tt> instance looks
        for all interfaces implemented by the delegate (other than
        IntroductionInterceptor), and will support introductions against any
        of them. It's possible for subclasses such as
        <tt class="literal">LockMixin</tt> to call the
        <tt class="literal">suppressInterflace(Class intf) </tt>method to suppress
        interfaces that should not be exposed. However, no matter how many
        interfaces an <tt class="literal">IntroductionInterceptor</tt> is prepared
        to support, the <tt class="literal">IntroductionAdvisor</tt> used will
        control which interfaces are actually exposed. An introduced interface
        will conceal any implementation of the same interface by the
        target.</p><p>Thus LockMixin subclasses
        <tt class="literal">DelegatingIntroductionInterceptor</tt> and implements
        Lockable itself. The superclass automatically picks up that Lockable
        can be supported for introduction, so we don't need to specify that.
        We could introduce any number of interfaces in this way.</p><p>Note the use of the <tt class="literal">locked</tt> instance variable.
        This effectively adds additional state to that held in the target
        object.</p><pre class="programlisting">public class LockMixin extends DelegatingIntroductionInterceptor 
    implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0)
            throw new LockedException();
        return super.invoke(invocation);
    }

}</pre><p>Often it isn't necessary to override the <tt class="literal">invoke()
        </tt>method: the
        <tt class="literal">DelegatingIntroductionInterceptor</tt>
        implementation--which calls the delegate method if the method is
        introduced, otherwise proceeds towards the joinpoint--is usually
        sufficient. In the present case, we need to add a check: no setter
        method can be invoked if in locked mode.</p><p>The introduction advisor required is simple. All it needs to do
        is hold a distinct <tt class="literal">LockMixin</tt> instance, and specify
        the introduced interfaces--in this case, just
        <tt class="literal">Lockable</tt>. A more complex example might take a
        reference to the introduction interceptor (which would be defined as a
        prototype): in this case, there's no configuration relevant for a
        <tt class="literal">LockMixin</tt>, so we simply create it using
        <tt class="literal">new</tt>.</p><pre class="programlisting">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</pre><p>We can apply this advisor very simply: it requires no
        configuration. (However, it <span class="emphasis"><em>is</em></span> necessary: It's
        impossible to use an <tt class="literal">IntroductionInterceptor</tt>
        without an <span class="emphasis"><em>IntroductionAdvisor</em></span>.) As usual with
        introductions, the advisor must be per-instance, as it is stateful. We
        need a different instance of <tt class="literal">LockMixinAdvisor</tt>, and
        hence <tt class="literal">LockMixin</tt>, for each advised object. The
        advisor comprises part of the advised object's state.</p><p>We can apply this advisor programmatically, using the
        <tt class="literal">Advised.addAdvisor() </tt>method, or (the recommended
        way) in XML configuration, like any other advisor. All proxy creation
        choices discussed below, including "auto proxy creators," correctly
        handle introductions and stateful mixins.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4291"></a>6.4.&nbsp;Advisors in Spring</h2></div></div><div></div></div><p>In Spring, an Advisor is a modularization of an aspect. Advisors
    typically incorporate both an advice and a pointcut.</p><p>Apart from the special case of introductions, any advisor can be
    used with any advice.
    <tt class="literal">org.springframework.aop.support.DefaultPointcutAdvisor</tt>
    is the most commonly used advisor class. For example, it can be used with
    a <tt class="literal">MethodInterceptor</tt>, <tt class="literal">BeforeAdvice</tt> or
    <tt class="literal">ThrowsAdvice</tt>.</p><p>It is possible to mix advisor and advice types in Spring in the same
    AOP proxy. For example, you could use a interception around advice, throws
    advice and before advice in one proxy configuration: Spring will
    automatically create the necessary create interceptor chain.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-pfb"></a>6.5.&nbsp;Using the ProxyFactoryBean to create AOP proxies</h2></div></div><div></div></div><p>If you're using the Spring IoC container (an ApplicationContext or
    BeanFactory) for your business objects--and you should be!--you will want
    to use one of Spring's AOP FactoryBeans. (Remember that a factory bean
    introduces a layer of indirection, enabling it to create objects of a
    different type).</p><p>The basic way to create an AOP proxy in Spring is to use the
    <span class="emphasis"><em>org.springframework.aop.framework.ProxyFactoryBean</em></span>.
    This gives complete control over the pointcuts and advice that will apply,
    and their ordering. However, there are simpler options that are preferable
    if you don't need such control.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-1"></a>6.5.1.&nbsp;Basics</h3></div></div><div></div></div><p>The <tt class="literal">ProxyFactoryBean</tt>, like other Spring
      <tt class="literal">FactoryBean</tt> implementations, introduces a level of
      indirection. If you define a <tt class="literal">ProxyFactoryBean</tt> with
      name <tt class="literal">foo</tt>, what objects referencing
      <tt class="literal">foo</tt> see is not the
      <tt class="literal">ProxyFactoryBean</tt> instance itself, but an object
      created by the <tt class="literal">ProxyFactoryBean's</tt> implementation of
      the <tt class="literal">getObject() </tt>method. This method will create an
      AOP proxy wrapping a target object.</p><p>One of the most important benefits of using a
      <tt class="literal">ProxyFactoryBean</tt> or other IoC-aware class to create
      AOP proxies, is that it means that advices and pointcuts can also be
      managed by IoC. This is a powerful feature, enabling certain approaches
      that are hard to achieve with other AOP frameworks. For example, an
      advice may itself reference application objects (besides the target,
      which should be available in any AOP framework), benefiting from all the
      pluggability provided by Dependency Injection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-2"></a>6.5.2.&nbsp;JavaBean properties</h3></div></div><div></div></div><p>Like most FactoryBean implementations provided with Spring,
      <tt class="literal">ProxyFactoryBean</tt> is itself a JavaBean. Its properties
      are used to:</p><div class="itemizedlist"><ul type="disc"><li><p>Specify the target you want to proxy</p></li><li><p>Specify whether to use CGLIB</p></li></ul></div><p>Some key properties are inherited from
      <tt class="literal">org.springframework.aop.framework.ProxyConfig</tt>: the
      superclass for all AOP proxy factories. These include:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">proxyTargetClass</tt>: true if we should proxy
          the target class, rather than its interfaces. If this is true we
          need to use CGLIB.</p></li><li><p><tt class="literal">optimize</tt>: whether to apply aggressive
          optimization to created proxies. Don't use this setting unless you
          understand how the relevant AOP proxy handles optimization. This is
          currently used only for CGLIB proxies; it has no effect with JDK
          dynamic proxies (the default).</p></li><li><p><tt class="literal">frozen</tt>: whether advice changes should be
          disallowed once the proxy factory has been configured. Default is
          false.</p></li><li><p><tt class="literal">exposeProxy</tt>: whether the current proxy
          should be exposed in a ThreadLocal so that it can be accessed by the
          target. (It's available via the MethodInvocation without the need
          for a ThreadLocal.) If a target needs to obtain the proxy and
          exposeProxy is true, the target can use the
          <tt class="literal">AopContext.currentProxy()</tt> method.</p></li><li><p><tt class="literal">aopProxyFactory</tt>: the implementation of
          AopProxyFactory to use. Offers a way of customizing whether to use
          dynamic proxies, CGLIB or any other proxy strategy. The default
          implementation will choose dynamic proxies or CGLIB appropriately.
          There should be no need to use this property; it's intended to allow
          the addition of new proxy types in Spring 1.1.</p></li></ul></div><p>Other properties specific to <tt class="literal">ProxyFactory</tt>Bean
      include:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">proxyInterfaces</tt>: array of String interface
          names. If this isn't supplied, a CGLIB proxy for the target class
          will be used</p></li><li><p><tt class="literal">interceptorNames</tt>: String array of Advisor,
          interceptor or other advice names to apply. Ordering is significant.
          First come, first serve that is. The first interceptor in the list
          will be the first to be able to intercept the invocation (of course
          if it concerns a regular <tt class="literal">MethodInterceptor</tt> or
          <tt class="literal">BeforeAdvice</tt>.</p><p>The names are bean names in the current factory, including bean
          names from ancestor factories. You can't mention bean references
          here since doing so would result in the ProxyFactoryBean ignoring
          the singleton setting of the advise.</p><p>You can append an interceptor name with an asterisk (*).
          This will result in the application of all advisor beans with names starting
          with the part before the asterisk to be applied. An example of using
          this feature can be found below.</p></li><li><p>singleton: whether or not the factory should return a single
          object, no matter how often the <tt class="literal">getObject()</tt>
          method is called. Several <tt class="literal">FactoryBean</tt>
          implementations offer such a method. Default value is true. If you
          want to use stateful advice--for example, for stateful mixins--use
          prototype advices along with a singleton value of false.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4440"></a>6.5.3.&nbsp;Proxying interfaces</h3></div></div><div></div></div><p>Let's look at a simple example of ProxyFactoryBean in action. This
      example involves:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>target bean</em></span> that will be proxied. This
          is the "personTarget" bean definition in the example below.</p></li><li><p>An Advisor and an Interceptor used to provide advice.</p></li><li><p>An AOP proxy bean definition specifying the target object (the
          personTarget bean) and the interfaces to proxy, along with the
          advices to apply.</p></li></ul></div><pre class="programlisting">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;

    &lt;property name="target"&gt;&lt;ref local="personTarget"/&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the <tt class="literal">interceptorNames</tt> property takes a
      list of String: the bean names of the interceptor or advisors in the
      current factory. Advisors, interceptors, before, after returning and
      throws advice objects can be used. The ordering of advisors is
      significant.</p><i><span class="remark">You might be wondering why the list doesn't hold bean
      references. The reason for this is that if the ProxyFactoryBean's
      singleton property is set to false, it must be able to return
      independent proxy instances. If any of the advisors is itself a
      prototype, an independent instance would need to be returned, so it's
      necessary to be able to obtain an instance of the prototype from the
      factory; holding a reference isn't sufficient.</span></i><p>The "person" bean definition above can be used in place of a
      Person implementation, as follows:</p><pre class="programlisting">Person person = (Person) factory.getBean("person");</pre><p>Other beans in the same IoC context can express a strongly typed
      dependency on it, as with an ordinary Java object:</p><pre class="programlisting">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
  &lt;property name="person"&gt;&lt;ref local="person" /&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">PersonUser</tt> class in this example would
      expose a property of type Person. As far as it's concerned, the AOP
      proxy can be used transparently in place of a "real" person
      implementation. However, its class would be a dynamic proxy class. It
      would be possible to cast it to the <tt class="literal">Advised</tt> interface
      (discussed below).</p><p>It's possible to conceal the distinction between target and proxy
      using an anonymous <span class="emphasis"><em>inner bean</em></span>, as follows. Only the
      <tt class="literal">ProxyFactoryBean</tt> definition is different; the advice
      is included only for completeness:</p><pre class="programlisting">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
  &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;
  &lt;!-- Use inner bean, not local reference to target --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
      &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myAdvisor&lt;/value&gt;
      &lt;value&gt;debugInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This has the advantage that there's only one object of type
      <tt class="literal">Person</tt>: useful if we want to prevent users of the
      application context obtaining a reference to the un-advised object, or
      need to avoid any ambiguity with Spring IoC
      <span class="emphasis"><em>autowiring</em></span>. There's also arguably an advantage in
      that the ProxyFactoryBean definition is self-contained. However, there
      are times when being able to obtain the un-advised target from the
      factory might actually be an <span class="emphasis"><em>advantage</em></span>: for
      example, in certain test scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4507"></a>6.5.4.&nbsp;Proxying classes</h3></div></div><div></div></div><p>What if you need to proxy a class, rather than one or more
      interfaces?</p><p>Imagine that in our example above, there was no
      <tt class="literal">Person</tt> interface: we needed to advise a class called
      <tt class="literal">Person</tt> that didn't implement any business interface.
      In this case, you can configure Spring to use CGLIB proxying, rather
      than dynamic proxies. Simply set the <tt class="literal">proxyTargetClass</tt>
      property on the ProxyFactoryBean above to true. While it's best to
      program to interfaces, rather than classes, the ability to advise
      classes that don't implement interfaces can be useful when working with
      legacy code. (In general, Spring isn't prescriptive. While it makes it
      easy to apply good practices, it avoids forcing a particular
      approach.)</p><p>If you want to you can force the use of CGLIB in any case, even if
      you do have interfaces.</p><p>CGLIB proxying works by generating a subclass of the target class
      at runtime. Spring configures this generated subclass to delegate method
      calls to the original target: the subclass is used to implement the
      <span class="emphasis"><em>Decorator</em></span> pattern, weaving in the advice.</p><p>CGLIB proxying should generally be transparent to users. However,
      there are some issues to consider:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Final</tt> methods can't be advised, as they
          can't be overridden.</p></li><li><p>You'll need the CGLIB 2 binaries on your classpath; dynamic
          proxies are available with the JDK</p></li></ul></div><p>There's little performance difference between CGLIB proxying and
      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.
      However, this may change in the future. Performance should not be a
      decisive consideration in this case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4543"></a>6.5.5.&nbsp;Using 'global' advisors</h3></div></div><div></div></div><p>
            By appending an asterisk to an interceptor name, all advisors with
            bean names matching the part before the asterisk, will be added
            to the advisor chain. This can come in handy if you need to add a
            standard set of 'global' advisors:
</p><pre class="programlisting">
&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="target" ref="service"/&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;global*&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;
</pre><p>
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-tfb"></a>6.6.&nbsp;Convenient proxy creation</h2></div></div><div></div></div><p>Often we don't need the full power of the
    <tt class="literal">ProxyFactoryBean</tt>, because we're only interested in one
    aspect: For example, transaction management.</p><p>There are a number of convenience factories we can use to create AOP
    proxies when we want to focus on a specific aspect. These are discussed in
    other chapters, so we'll just provide a quick survey of some of them
    here.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4561"></a>6.6.1.&nbsp;TransactionProxyFactoryBean</h3></div></div><div></div></div><p>The <span class="bold"><b>JPetStore</b></span> sample application
      shipped with Spring shows the use of the
      TransactionProxyFactoryBean.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> is a subclass
      of <tt class="literal">ProxyConfig</tt>, so basic configuration is shared with
      <tt class="literal">ProxyFactoryBean</tt>. (See list of
      <tt class="literal">ProxyConfig</tt> properties above.)</p><p>The following example from the JPetStore illustrates how this
      works. As with a <tt class="literal">ProxyFactoryBean</tt>, there is a target
      bean definition. Dependencies should be expressed on the proxied factory
      bean definition ("petStore" here), rather than the target POJO
      ("petStoreTarget").</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> requires a
      target, and information about "transaction attributes," specifying which
      methods should be transactional and the required propagation and other
      settings:</p><pre class="programlisting">&lt;bean id="petStoreTarget" class="org.springframework.samples.jpetstore.domain.logic.PetStoreImpl"&gt;
  &lt;property name="accountDao"&gt;&lt;ref bean="accountDao"/&gt;&lt;/property&gt;
  &lt;!-- Other dependencies omitted --&gt;
&lt;/bean&gt;

&lt;bean id="petStore" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="target" ref="petStoreTarget"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with the <tt class="literal">ProxyFactoryBean</tt>, we might choose
      to use an inner bean to set the value of <tt class="literal">target</tt>
      property, instead of a reference to a top-level target bean.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> automatically
      creates a transaction advisor, including a pointcut based on the
      transaction attributes, so only transactional methods are
      advised.</p><p>The <tt class="literal">TransactionProxyFactoryBean</tt> allows the
      specification of "pre" and "post" advice, using the preInterceptors and
      postInterceptors properties. These take Object arrays of interceptors,
      other advice or Advisors to place in the interception chain before or
      after the transaction interceptor. These can be populated using a
      &lt;list&gt; element in XML bean definitions, as follows:</p><pre class="programlisting">&lt;property name="preInterceptors"&gt;
  &lt;list&gt;
    &lt;ref bean="authorizationInterceptor"/&gt;
    &lt;ref bean="notificationBeforeAdvice"/&gt;
  &lt;/list&gt;
&lt;/property&gt;
&lt;property name="postInterceptors"&gt;
  &lt;list&gt;
    &lt;ref bean="myAdvisor"/&gt;
  &lt;/list&gt;
&lt;/property&gt;</pre><p>These properties could be added to the "petStore" bean definition
      above. A common usage is to combine transactionality with declarative
      security: a similar approach to that offered by EJB.</p><p>Because of the use of actual instance references, rather than bean
      names as in <tt class="literal">ProxyFactoryBean</tt>, pre and post
      interceptors can be used only for shared-instance advice. Thus they are
      not useful for stateful advice: for example, in mixins. This is
      consistent with the TransactionProxyFactoryBean's purpose. It provides a
      simple way of doing common transaction setup. If you need more complex,
      customized, AOP, consider using the generic
      <tt class="literal">ProxyFactoryBean</tt>, or an auto proxy creator (see
      below).</p><i><span class="remark">Especially if we view Spring AOP as, in many cases, a
      replacement for EJB, we find that most advice is fairly generic and uses
      a shared-instance model. Declarative transaction management and security
      checks are classic examples.</span></i><p>The <tt class="literal">TransactionProxyFactoryBean</tt> depends on a
      <tt class="literal">PlatformTransactionManager</tt> implementation via its
      <tt class="literal">transactionManager</tt> JavaBean property. This allows for
      pluggable transaction implementation, based on JTA, JDBC or other
      strategies. This relates to the Spring transaction abstraction, rather
      than AOP. We'll discuss the transaction infrastructure in the next
      chapter.</p><i><span class="remark">If you're interested only in declarative transaction management,
      the TransactionProxyFactoryBean is a good solution, and simpler than
      using a ProxyFactoryBean.</span></i></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4642"></a>6.6.2.&nbsp;EJB proxies</h3></div></div><div></div></div><p>Other dedicated proxies create proxies for EJBs, enabling the EJB
      "business methods" interface to be used directly by calling code.
      Calling code does not need to perform JNDI lookups or use EJB create
      methods: A significant improvement in readability and architectural
      flexibility.</p><p>See the chapter on Spring EJB services in this manual for further
      information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-concise-proxy"></a>6.7.&nbsp;Concise proxy definitions</h2></div></div><div></div></div><p>Especially when defining transactional proxies, you may end up with
    many similar proxy definitions. The use of parent and child bean
    definitions, along with inner bean definitions, can result in much cleaner
    and more concise proxy definitions.</p><p>First a parent, <span class="emphasis"><em>template</em></span>, bean definition is
    created for the proxy:</p><pre class="programlisting">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This will never be instantiated itself, so may actually be
    incomplete. Then each proxy which needs to be created is just a child bean
    definition, which to wraps the target of the proxy as an inner bean
    definition, since the target will never be used on its own
    anyways.</p><pre class="programlisting">&lt;bean id="myService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>It is of course possible to override properties from the parent
    template, such as in this case, the transaction propagation
    settings:</p><pre class="programlisting">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute, as described <a href="beans.html#beans-child-bean-definitions" title="3.5.&nbsp;Abstract and child bean definitions">previously</a>, so that it may
	not actually ever be instantiated. Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually try to pre-instantiate it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-prog"></a>6.8.&nbsp;Creating AOP proxies programmatically with the ProxyFactory</h2></div></div><div></div></div><p>It's easy to create AOP proxies programmatically using Spring. This
    enables you to use Spring AOP without dependency on Spring IoC.</p><p>The following listing shows creation of a proxy for a target object,
    with one interceptor and one advisor. The interfaces implemented by the
    target object will automatically be proxied:</p><pre class="programlisting">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addInterceptor(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</pre><p>The first step is to construct a object of type
    <tt class="literal">org.springframework.aop.framework.ProxyFactory</tt>. You can
    create this with a target object, as in the above example, or specify the
    interfaces to be proxied in an alternate constructor.</p><p>You can add interceptors or advisors, and manipulate them for the
    life of the ProxyFactory. If you add an
    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement
    additional interfaces.</p><p>There are also convenience methods on ProxyFactory (inherited from
    AdvisedSupport) allowing you to add other advice types such as before and
    throws advice. AdvisedSupport is the superclass of both ProxyFactory and
    ProxyFactoryBean.</p><i><span class="remark">Integrating AOP proxy creation with the IoC framework is best
    practice in most applications. We recommend that you externalize
    configuration from Java code with AOP, as in general.</span></i></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4708"></a>6.9.&nbsp;Manipulating advised objects</h2></div></div><div></div></div><p>However you create AOP proxies, you can manipulate them using the
    <tt class="literal">org.springframework.aop.framework.Advised</tt> interface.
    Any AOP proxy can be cast to this interface, whatever other interfaces it
    implements. This interface includes the following methods:</p><pre class="programlisting">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) 
        throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</pre><p>The <tt class="literal">getAdvisors()</tt> method will return an Advisor
    for every advisor, interceptor or other advice type that has been added to
    the factory. If you added an Advisor, the returned advisor at this index
    will be the object that you added. If you added an interceptor or other
    advice type, Spring will have wrapped this in an advisor with a pointcut
    that always returns true. Thus if you added a
    <tt class="literal">MethodInterceptor</tt>, the advisor returned for this index
    will be an <tt class="literal">DefaultPointcutAdvisor</tt> returning your
    <tt class="literal">MethodInterceptor</tt> and a pointcut that matches all
    classes and methods.</p><p>The <tt class="literal">addAdvisor()</tt> methods can be used to add any
    Advisor. Usually the advisor holding pointcut and advice will be the
    generic <tt class="literal">DefaultPointcutAdvisor</tt>, which can be used with
    any advice or pointcut (but not for introduction).</p><p>By default, it's possible to add or remove advisors or interceptors
    even once a proxy has been created. The only restriction is that it's
    impossible to add or remove an introduction advisor, as existing proxies
    from the factory will not show the interface change. (You can obtain a new
    proxy from the factory to avoid this problem.)</p><p>A simple example of casting an AOP proxy to the
    <tt class="literal">Advised</tt> interface and examining and manipulating its
    advice:</p><pre class="programlisting">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors",
     oldAdvisorCount + 2, advised.getAdvisors().length);</pre><i><span class="remark">It's questionable whether it's advisable (no pun intended) to
    modify advice on a business object in production, although there are no
    doubt legitimate usage cases. However, it can be very useful in
    development: for example, in tests. I have sometimes found it very useful
    to be able to add test code in the form of an interceptor or other advice,
    getting inside a method invocation I want to test. (For example, the
    advice can get inside a transaction created for that method: for example,
    to run SQL to check that a database was correctly updated, before marking
    the transaction for roll back.)</span></i><p>Depending on how you created the proxy, you can usually set a
    <tt class="literal">frozen</tt> flag, in which case the
    <tt class="literal">Advised</tt> <tt class="literal">isFrozen()</tt> method will
    return true, and any attempts to modify advice through addition or removal
    will result in an <tt class="literal">AopConfigException</tt>. The ability to
    freeze the state of an advised object is useful in some cases: For
    example, to prevent calling code removing a security interceptor. It may
    also be used in Spring 1.1 to allow aggressive optimization if runtime
    advice modification is known not to be required.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-autoproxy"></a>6.10.&nbsp;Using the "autoproxy" facility</h2></div></div><div></div></div><p>So far we've considered explicit creation of AOP proxies using a
    <tt class="literal">ProxyFactoryBean</tt> or similar factory bean.</p><p>Spring also allows us to use "autoproxy" bean definitions, which can
    automatically proxy selected bean definitions. This is built on Spring
    "bean post processor" infrastructure, which enables modification of any
    bean definition as the container loads.</p><p>In this model, you set up some special bean definitions in your XML
    bean definition file configuring the auto proxy infrastructure. This
    allows you just to declare the targets eligible for autoproxying: you
    don't need to use <tt class="literal">ProxyFactoryBean</tt>.</p><p>There are two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Using an autoproxy creator that refers to specific beans in the
        current context</p></li><li><p>A special case of autoproxy creation that deserves to be
        considered separately; autoproxy creation driven by source-level
        metadata attributes</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-choices"></a>6.10.1.&nbsp;Autoproxy bean definitions</h3></div></div><div></div></div><p>The <tt class="literal">org.springframework.aop.framework.autoproxy</tt>
      package provides the following standard autoproxy creators.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4798"></a>6.10.1.1.&nbsp;BeanNameAutoProxyCreator</h4></div></div><div></div></div><p>The BeanNameAutoProxyCreator automatically creates AOP proxies
        for beans with names matching literal values or wildcards.</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
  &lt;property name="beanNames"&gt;&lt;value&gt;jdk*,onlyJdk&lt;/value&gt;&lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with <tt class="literal">ProxyFactoryBean</tt>, there is an
        interceptorNames property rather than a list of interceptor, to allow
        correct behavior for prototype advisors. Named "interceptors" can be
        advisors or any advice type.</p><p>As with auto proxying in general, the main point of using
        <tt class="literal">BeanNameAutoProxyCreator</tt> is to apply the same
        configuration consistently to multiple objects, and with minimal
        volume of configuration. It is a popular choice for applying
        declarative transactions to multiple objects.</p><p>Bean definitions whose names match, such as "jdkMyBean" and
        "onlyJdk" in the above example, are plain old bean definitions with
        the target class. An AOP proxy will be created automatically by the
        <tt class="literal">BeanNameAutoProxyCreator</tt>. The same advice will be
        applied to all matching beans. Note that if advisors are used (rather
        than the interceptor in the above example), the pointcuts may apply
        differently to different beans.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4821"></a>6.10.1.2.&nbsp;DefaultAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>A more general and extremely powerful auto proxy creator is
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>. This will
        automagically apply eligible advisors in the current context, without
        the need to include specific bean names in the autoproxy advisor's
        bean definition. It offers the same merit of consistent configuration
        and avoidance of duplication as
        <tt class="literal">BeanNameAutoProxyCreator</tt>.</p><p>Using this mechanism involves:</p><div class="itemizedlist"><ul type="disc"><li><p>Specifying a
            <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
            definition</p></li><li><p>Specifying any number of Advisors in the same or related
            contexts. Note that these <span class="emphasis"><em>must</em></span> be Advisors,
            not just interceptors or other advices. This is necessary because
            there must be a pointcut to evaluate, to check the eligibility of
            each advice to candidate bean definitions.</p></li></ul></div><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> will
        automatically evaluate the pointcut contained in each advisor, to see
        what (if any) advice it should apply to each business object (such as
        "businessObject1" and "businessObject2" in the example).</p><p>This means that any number of advisors can be applied
        automatically to each business object. If no pointcut in any of the
        advisors matches any method in a business object, the object will not
        be proxied. As bean definitions are added for new business objects,
        they will automatically be proxied if necessary.</p><p>Autoproxying in general has the advantage of making it
        impossible for callers or dependencies to obtain an un-advised object.
        Calling getBean("businessObject1") on this ApplicationContext will
        return an AOP proxy, not the target business object. (The "inner bean"
        idiom shown earlier also offers this benefit.)</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
  &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;
</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> is very
        useful if you want to apply the same advice consistently to many
        business objects. Once the infrastructure definitions are in place,
        you can simply add new business objects without including specific
        proxy configuration. You can also drop in additional aspects very
        easily--for example, tracing or performance monitoring aspects--with
        minimal change to configuration.</p><p>The DefaultAdvisorAutoProxyCreator offers support for filtering
        (using a naming convention so that only certain advisors are
        evaluated, allowing use of multiple, differently configured,
        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors
        can implement the <tt class="literal">org.springframework.core.Ordered</tt>
        interface to ensure correct ordering if this is an issue. The
        TransactionAttributeSourceAdvisor used in the above example has a
        configurable order value; default is unordered.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4869"></a>6.10.1.3.&nbsp;AbstractAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>This is the superclass of DefaultAdvisorAutoProxyCreator. You
        can create your own autoproxy creators by subclassing this class, in
        the unlikely event that advisor definitions offer insufficient
        customization to the behavior of the framework
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-metadata"></a>6.10.2.&nbsp;Using metadata-driven auto-proxying</h3></div></div><div></div></div><p>A particularly important type of autoproxying is driven by
      metadata. This produces a similar programming model to .NET
      <tt class="literal">ServicedComponents</tt>. Instead of using XML deployment
      descriptors as in EJB, configuration for transaction management and
      other enterprise services is held in source-level attributes.</p><p>In this case, you use the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, in combination with
      Advisors that understand metadata attributes. The metadata specifics are
      held in the pointcut part of the candidate advisors, rather than in the
      autoproxy creation class itself.</p><p>This is really a special case of the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, but deserves
      consideration on its own. (The metadata-aware code is in the pointcuts
      contained in the advisors, not the AOP framework itself.)</p><p>The <tt class="literal">/attributes</tt> directory of the JPetStore
      sample application shows the use of attribute-driven autoproxying. In
      this case, there's no need to use the
      <tt class="literal">TransactionProxyFactoryBean</tt>. Simply defining
      transactional attributes on business objects is sufficient, because of
      the use of metadata-aware pointcuts. The bean definitions include the
      following code, in <tt class="literal">/WEB-INF/declarativeServices.xml</tt>.
      Note that this is generic, and can be used outside the JPetStore:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes"/&gt;</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
      definition (the name is not significant, hence it can even be omitted)
      will pick up all eligible pointcuts in the current application context.
      In this case, the "transactionAdvisor" bean definition, of type
      <tt class="literal">TransactionAttributeSourceAdvisor</tt>, will apply to
      classes or methods carrying a transaction attribute. The
      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,
      via constructor dependency. The example resolves this via autowiring.
      The <tt class="literal">AttributesTransactionAttributeSource</tt> depends on
      an implementation of the
      <tt class="literal">org.springframework.metadata.Attributes</tt> interface. In
      this fragment, the "attributes" bean satisfies this, using the Jakarta
      Commons Attributes API to obtain attribute information. (The application
      code must have been compiled using the Commons Attributes compilation
      task.)</p><p>The <tt class="literal">/annotation</tt> directory of the JPetStore
			sample application contains an analogous example for auto-proxying
			driven by JDK 1.5+ annotations. The following configuration enables
      automatic detection of Spring's <tt class="literal">Transactional</tt>
      annotation, leading to implicit proxies for beans containing that
      annotation:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">TransactionInterceptor</tt> defined here depends
      on a <tt class="literal">PlatformTransactionManager</tt> definition, which is
      not included in this generic file (although it could be) because it will
      be specific to the application's transaction requirements (typically
      JTA, as in this example, or Hibernate, JDO or JDBC):</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><i><span class="remark">If you require only declarative transaction management, using
      these generic XML definitions will result in Spring automatically
      proxying all classes or methods with transaction attributes. You won't
      need to work directly with AOP, and the programming model is similar to
      that of .NET ServicedComponents.</span></i><p>This mechanism is extensible. It's possible to do autoproxying
      based on custom attributes. You need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute.</p></li><li><p>Specify an Advisor with the necessary advice, including a
          pointcut that is triggered by the presence of the custom attribute
          on a class or method. You may be able to use an existing advice,
          merely implementing a static pointcut that picks up the custom
          attribute.</p></li></ul></div><p>It's possible for such advisors to be unique to each advised class
      (for example, mixins): they simply need to be defined as prototype,
      rather than singleton, bean definitions. For example, the
      <tt class="literal">LockMixin</tt> introduction interceptor from the Spring
      test suite, shown above, could be used in conjunction with an
      attribute-driven pointcut to target a mixin, as shown here. We use the
      generic <tt class="literal">DefaultPointcutAdvisor</tt>, configured using
      JavaBean properties:</p><pre class="programlisting">&lt;bean id="lockMixin" class="org.springframework.aop.LockMixin"
    singleton="false"/&gt;

&lt;bean id="lockableAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"
    singleton="false"&gt;
  &lt;property name="pointcut" ref="myAttributeAwarePointcut"/&gt;
  &lt;property name="advice" ref="lockMixin"/&gt;
&lt;/bean&gt;

&lt;bean id="anyBean" class="anyclass" ...</pre><p>If the attribute aware pointcut matches any methods in the
      <tt class="literal">anyBean</tt> or other bean definitions, the mixin will be
      applied. Note that both <tt class="literal">lockMixin</tt> and
      <tt class="literal">lockableAdvisor</tt> definitions are prototypes. The
      <tt class="literal">myAttributeAwarePointcut</tt> pointcut can be a singleton
      definition, as it doesn't hold state for individual advised
      objects.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-targetsource"></a>6.11.&nbsp;Using TargetSources</h2></div></div><div></div></div><p>Spring offers the concept of a <span class="emphasis"><em>TargetSource</em></span>,
    expressed in the <tt class="literal">org.springframework.aop.TargetSource</tt>
    interface. This interface is responsible for returning the "target object"
    implementing the joinpoint. The <tt class="literal">TargetSource</tt>
    implementation is asked for a target instance each time the AOP proxy
    handles a method invocation.</p><p>Developers using Spring AOP don't normally need to work directly
    with TargetSources, but this provides a powerful means of supporting
    pooling, hot swappable and other sophisticated targets. For example, a
    pooling TargetSource can return a different target instance for each
    invocation, using a pool to manage instances.</p><p>If you do not specify a TargetSource, a default implementation is
    used that wraps a local object. The same target is returned for each
    invocation (as you would expect).</p><p>Let's look at the standard target sources provided with Spring, and
    how you can use them.</p><i><span class="remark">When using a custom target source, your target will usually need
    to be a prototype rather than a singleton bean definition. This allows
    Spring to create a new target instance when required.</span></i><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-swap"></a>6.11.1.&nbsp;Hot swappable target sources</h3></div></div><div></div></div><p>The
      <tt class="literal">org.springframework.aop.target.HotSwappableTargetSource</tt>
      exists to allow the target of an AOP proxy to be switched while allowing
      callers to keep their references to it.</p><p>Changing the target source's target takes effect immediately. The
      <tt class="literal">HotSwappableTargetSource</tt> is threadsafe.</p><p>You can change the target via the <tt class="literal">swap()</tt> method
      on HotSwappableTargetSource as follows:</p><pre class="programlisting">HotSwappableTargetSource swapper = 
    (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</pre><p>The XML definitions required look as follows:</p><pre class="programlisting">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
  &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</pre><p>The above <tt class="literal">swap()</tt> call changes the target of the
      swappable bean. Clients who hold a reference to that bean will be
      unaware of the change, but will immediately start hitting the new
      target.</p><p>Although this example doesn't add any advice--and it's not
      necessary to add advice to use a <tt class="literal">TargetSource</tt>--of
      course any <tt class="literal">TargetSource</tt> can be used in conjunction
      with arbitrary advice.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-pool"></a>6.11.2.&nbsp;Pooling target sources</h3></div></div><div></div></div><p>Using a pooling target source provides a similar programming model
      to stateless session EJBs, in which a pool of identical instances is
      maintained, with method invocations going to free objects in the
      pool.</p><p>A crucial difference between Spring pooling and SLSB pooling is
      that Spring pooling can be applied to any POJO. As with Spring in
      general, this service can be applied in a non-invasive way.</p><p>Spring provides out-of-the-box support for Jakarta Commons Pool
      1.1, which provides a fairly efficient pooling implementation. You'll
      need the commons-pool Jar on your application's classpath to use this
      feature. It's also possible to subclass
      <tt class="literal">org.springframework.aop.target.AbstractPoolingTargetSource</tt>
      to support any other pooling API.</p><p>Sample configuration is shown below:</p><pre class="programlisting">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject" 
    singleton="false"&gt;
  ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
  &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="poolTargetSource"/&gt;
  &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</pre><p>Note that the target object--"businessObjectTarget" in the
      example--<span class="emphasis"><em>must</em></span> be a prototype. This allows the
      <tt class="literal">PoolingTargetSource</tt> implementation to create new
      instances of the target to grow the pool as necessary. See the Javadoc
      for <tt class="literal">AbstractPoolingTargetSource</tt> and the concrete
      subclass you wish to use for information about it's properties: maxSize
      is the most basic, and always guaranteed to be present.</p><p>In this case, "myInterceptor" is the name of an interceptor that
      would need to be defined in the same IoC context. However, it isn't
      necessary to specify interceptors to use pooling. If you want only
      pooling, and no other advice, don't set the interceptorNames property at
      all.</p><p>It's possible to configure Spring so as to be able to cast any
      pooled object to the
      <tt class="literal">org.springframework.aop.target.PoolingConfig</tt>
      interface, which exposes information about the configuration and current
      size of the pool through an introduction. You'll need to define an
      advisor like this:</p><pre class="programlisting">&lt;bean id="poolConfig" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject" ref="poolTargetSource"/&gt;
  &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</pre><p>This advisor is obtained by calling a convenience method on the
      <tt class="literal">AbstractPoolingTargetSource</tt> class, hence the use of
      MethodInvokingFactoryBean. This advisor's name ("poolConfigAdvisor"
      here) must be in the list of interceptors names in the ProxyFactoryBean
      exposing the pooled object.</p><p>The cast will look as follows:</p><pre class="programlisting">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</pre><i><span class="remark">Pooling stateless service objects is not usually necessary. We
      don't believe it should be the default choice, as most stateless objects
      are naturally thread safe, and instance pooling is problematic if
      resources are cached.</span></i><p>Simpler pooling is available using autoproxying. It's possible to
      set the TargetSources used by any autoproxy creator.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-prototype"></a>6.11.3.&nbsp;Prototype target sources</h3></div></div><div></div></div><p>Setting up a "prototype" target source is similar to a pooling
      TargetSource. In this case, a new instance of the target will be created
      on every method invocation. Although the cost of creating a new object
      isn't high in a modern JVM, the cost of wiring up the new object
      (satisfying its IoC dependencies) may be more expensive. Thus you
      shouldn't use this approach without very good reason.</p><p>To do this, you could modify the
      <tt class="literal">poolTargetSource</tt> definition shown above as follows.
      (I've also changed the name, for clarity.)</p><pre class="programlisting">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
  &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><p>There's only one property: the name of the target bean.
      Inheritance is used in the TargetSource implementations to ensure
      consistent naming. As with the pooling target source, the target bean
      must be a prototype bean definition.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-threadlocal"></a>6.11.4.&nbsp;ThreadLocal target sources</h3></div></div><div></div></div><p>
            ThreadLocal target sources are useful if you need an object to be created
            for each incoming request (per thread that is). The concept of a
            <tt class="literal">ThreadLocal</tt> provide a JDK-wide facility to transparently
						store resource alongside a thread. Setting up a ThreadLocalTargetSource
            is pretty much the same as was explained for the other target sources:
        </p><p>
            </p><pre class="programlisting">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><p>
        </p><p>
            <span class="emphasis"><em>ThreadLocals come with serious issues (potentially resulting in memory leaks)
            when incorrectly using them in a multi-threaded and multi-classloader environments. One should
            always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal
            itself (except of course in the wrapper class). Also, one should always remember to correctly set and unset (where the
            latter simply involved a call to ThreadLocal.set(null)) the resource local to the thread.
            Unsetting should be done in any case since not unsetting it might result in problematic behavior.
            Spring's ThreadLocal support is doing this for you and should always be considered in favor of
            using ThreadLocals without other proper handling code.</em></span>
                                           </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-extensibility"></a>6.12.&nbsp;Defining new Advice types</h2></div></div><div></div></div><p>Spring AOP is designed to be extensible. While the interception
    implementation strategy is presently used internally, it is possible to
    support arbitrary advice types in addition to interception around advice,
    before, throws advice and after returning advice, which are supported out
    of the box.</p><p>The <tt class="literal">org.springframework.aop.framework.adapter</tt>
    package is an SPI package allowing support for new custom advice types to
    be added without changing the core framework. The only constraint on a
    custom Advice type is that it must implement the
    <tt class="literal">org.aopalliance.aop.Advice</tt> tag interface.</p><p>Please refer to the
    <tt class="literal">org.springframework.aop.framework.adapter</tt> package's
    Javadocs for further information</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5144"></a>6.13.&nbsp;Further reading and resources</h2></div></div><div></div></div><p>I recommend the excellent <span class="emphasis"><em>AspectJ in Action</em></span> by
    Ramnivas Laddad (Manning, 2003) for an introduction to AOP.</p><p>Please refer to the Spring sample applications for further examples
    of Spring AOP:</p><div class="itemizedlist"><ul type="disc"><li><p>The JPetStore's default configuration illustrates the use of the
        TransactionProxyFactoryBean for declarative transaction
        management</p></li><li><p>The <tt class="literal">/attributes</tt> directory of the JPetStore
        illustrates the use of attribute-driven declarative transaction
        management</p></li></ul></div><p>If you are interested in more advanced capabilities of Spring AOP,
    take a look at the test suite. The test coverage is over 90%, and this
    illustrates advanced features not discussed in this document.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="validation.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="aspectj.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;PropertyEditors, data binding, validation and the BeanWrapper&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;7.&nbsp;AspectJ Integration</td></tr></table></div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>


<!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script>
<script type="text/javascript">var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");pageTracker._setAllowLinker(true);
pageTracker._trackPageview();var OrgTracker = _gat._getTracker("UA-2728886-2");
OrgTracker._trackPageview();</script>
 <!-- End 2nd Google code -->



</body>
</html>