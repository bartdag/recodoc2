<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;12.&nbsp;Data Access using O/R Mappers</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Spring - Java/J2EE Application Framework"><link rel="up" href="index.html" title="Spring - Java/J2EE Application Framework"><link rel="previous" href="jdbc.html" title="Chapter&nbsp;11.&nbsp;Data Access using JDBC"><link rel="next" href="mvc.html" title="Chapter&nbsp;13.&nbsp;Web MVC framework"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;12.&nbsp;Data Access using O/R Mappers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="mvc.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;12.&nbsp;Data Access using O/R Mappers</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>12.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides integration with <span class="emphasis"><em>Hibernate, JDO, Oracle
    TopLink, Apache OJB</em></span> and <span class="emphasis"><em>iBATIS SQL Maps</em></span>:
    in terms of resource management, DAO implementation support, and
    transaction strategies. For example for Hibernate, there is first-class
    support with lots of IoC convenience features, addressing many typical
    Hibernate integration issues. All of these support packages for O/R
    mappers comply with Spring's generic transaction and DAO exception
    hierarchies. There are usually two integration styles: either using
    Spring's DAO 'templates' or coding DAOs against plain
    Hibernate/JDO/TopLink/etc APIs. In both cases, DAOs can be configured
    through Dependency Injection and participate in Spring's resource and
    transaction management.</p><p>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data access applications. First of all, you
    should know that once you started using Spring's support for O/R mapping,
    you don't have to go all the way. No matter to what extent, you're invited
    to review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside an ApplicationContext does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside an ApplicationContext.</p><p>Some of the the benefits of using Spring to create your O/R mapping
    DAOs include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Ease of testing.</em></span> Spring's inversion of
        control approach makes it easy to swap the implementations and config
        locations of Hibernate SessionFactory instances, JDBC DataSources,
        transaction managers, and mapper object implementations (if needed).
        This makes it much easier to isolate and test each piece of
        persistence-related code in isolation.</p></li><li><p><span class="emphasis"><em>Common data access exceptions.</em></span>Spring can
        wrap exceptions from you O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate SessionFactory instances, JDBC DataSources, iBATIS SQL Maps
        configuration objects, and other related resources. This makes these
        values easy to manage and change. Spring offers efficient, easy and
        safe handling of persistence resources. For example: Related code
        using Hibernate generally needs to use the same Hibernate Session for
        efficiency and proper transaction handling. Spring makes it easy to
        transparently create and bind a Session to the current thread, either
        by using an explicit 'template' wrapper class at the Java code level
        or by exposing a current Session through the Hibernate SessionFactory
        (for DAOs based on plain Hibernate3 API). Thus Spring solves many of
        the issues that repeatedly arise from typical Hibernate usage, for any
        transaction environment (local or JTA).</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected: for
        example, between local transactions and JTA, with the same full
        services (such as declarative transactions) available in both
        scenarios. As an additional benefit, JDBC-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping,
        such as batch processing or streaming of BLOBs, which still needs to
        share common transactions with O/R mapping operations.</p></li><li><p><span class="emphasis"><em>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</em></span> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBATIS is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate transactions and exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        without sacrificing any of the power of Hibernate. Higher level
        service code dealing with the DAOs has no need to know anything about
        their implementation. This approach has the additional benefit of
        making it easy to intentionally implement data access with a
        mix-and-match approach (i.e. some data access performed using
        Hibernate, and some using JDBC, others using iBATIS) in a
        non-intrusive fashion, potentially providing great benefits in terms
        of continuing to use legacy code or leveraging the strength of each
        technology.</p></li></ul></div><p>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and Apache OJB. PetClinic can therefore serve
    as working sample app that illustrates the use of Hibernate, TopLink and
    OJB in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p><p>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</p><p>Beyond the samples shipped with Spring, there is a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>) and Kodo (<a href="http://www.solarmetric.com" target="_top">http://www.solarmetric.com</a>).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>12.2.&nbsp;Hibernate</h2></div></div><div></div></div><p>We will start with a coverage of Hibernate (<a href="http://www.hibernate.org" target="_top">http://www.hibernate.org</a>) in a Spring environment, using it
    to demonstrate the approach that Spring takes towards integrating O/R
    mappers. This section will cover many issues in detail and show different
    variations of DAO implementations and transaction demarcations. Most of
    these patterns can be directly translated to all other supported O/R
    mapping tools. The following sections in this chapter will then cover the
    other O/R mappers, showing briefer examples there.</p><p>The following discussion focuses on "classic" Hibernate: that is,
    Hibernate 2.1, which has been supported in Spring since its inception. All
    of this can be applied to Hibernate 3.0 as-is, using the analogous
    Hibernate 3 support package introduced in Spring 1.2 final:
    <tt class="literal">org.springframework.orm.hibernate3</tt>, mirroring
    <tt class="literal">org.springframework.orm.hibernate</tt> with analogous
    support classes for Hibernate 3. Furthermore, all references to the
    <tt class="literal">net.sf.hibernate</tt> package need to be replaced with
    <tt class="literal">org.hibernate</tt>, following the root package change in
    Hibernate 3. Simply adapt the package names (as used in the examples)
    accordingly.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7437"></a>12.2.1.&nbsp;Resource management</h3></div></div><div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <tt class="classname">JdbcTemplate</tt> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <tt class="classname">SQLException</tt> to the
      <tt class="classname">DataAccessException</tt> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</p><p>Spring also offers Hibernate and JDO support, consisting of a
      <tt class="classname">HibernateTemplate</tt> /
      <tt class="classname">JdoTemplate</tt> analogous to
      <tt class="classname">JdbcTemplate</tt>, a
      <tt class="classname">HibernateInterceptor</tt> /
      <tt class="classname">JdoInterceptor</tt>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business
      services (that use the data access objects and transaction managers),
      web view resolvers, web controllers (that use the business services),
      etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7468"></a>12.2.2.&nbsp;SessionFactory setup in a Spring application context</h3></div></div><div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate SessionFactory as beans in an application context. Application
      objects that need to access resources just receive references to such
      pre-defined instances via bean references (the DAO definition in the
      next section illustrates this). The following excerpt from an XML
      application context definition shows how to set up a JDBC
      <tt class="classname">DataSource</tt> and a Hibernate
      <tt class="classname">SessionFactory</tt> on top of it:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

   ...
&lt;/beans&gt;</pre><p>Note that switching from a local Jakarta Commons DBCP
      <tt class="classname">BasicDataSource</tt> to a JNDI-located
      <tt class="classname">DataSource</tt> (usually managed by the J2EE server)
      is just a matter of configuration:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>You can also access a JNDI-located
      <tt class="classname">SessionFactory</tt>, using Spring's
      JndiObjectFactoryBean to retrieve and expose it. However, that's
      typically not necessary outside an EJB context. See the "container
      resources versus local resources" section for a discussion.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7496"></a>12.2.3.&nbsp;Inversion of Control: HibernateTemplate and
      HibernateCallback</h3></div></div><div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <tt class="classname">SessionFactory</tt>. It can get the latter from
      anywhere, but preferably as bean reference from a Spring application
      context - via a simple <tt class="literal">setSessionFactory</tt> bean
      property setter. The following snippets show a DAO definition in a
      Spring application context, referencing the above defined
      <tt class="classname">SessionFactory,</tt> and an example for a DAO method
      implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        HibernateTemplate ht = new HibernateTemplate(this.sessionFactory);
        return (Collection) ht.execute(new HibernateCallback() {
            public Object doInHibernate(Session session) throws HibernateException {
                Query query = session.createQuery(
                    "from test.Product product where product.category=?");
                query.setString(0, category);
                return query.list();
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any
      Hibernate data access. <tt class="classname">HibernateTemplate</tt> will
      ensure that <tt class="classname">Session</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single step
      actions like a single find, load, saveOrUpdate, or delete call,
      <tt class="classname">HibernateTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">HibernateDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory</tt> method for receiving a
      <tt class="classname">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory</tt> and
      <tt class="literal">getHibernateTemplate</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7542"></a>12.2.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div><div></div></div><p>As alternative to using Spring's
      <tt class="classname">HibernateTemplate</tt> to implement DAOs, data access
      code can also be written in a more traditional fashion, without wrapping
      the Hibernate access code in a callback, while still complying to
      Spring's generic <tt class="literal">DataAccessException</tt> hierarchy.
      Spring's <tt class="literal">HibernateDaoSupport</tt> base class offers
      methods to access the current transactional Session and to convert
      exceptions in such a scenario; similar methods are also available as
      static helpers on the <tt class="literal">SessionFactoryUtils</tt> class. Note
      that such code will usually pass "false" into
      <tt class="literal">getSession</tt>'s the "allowCreate" flag, to enforce
      running within a transaction (which avoids the need to close the
      returned Session, as it its lifecycle is managed by the
      transaction).</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category)
            throws DataAccessException, MyException {

        Session session = getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</pre><p>The major advantage of such direct Hibernate access code is that
      it allows any checked application exception to be thrown within the data
      access code, while <tt class="literal">HibernateTemplate</tt> is restricted to
      unchecked exceptions within the callback. Note that one can often defer
      the corresponding checks and the throwing of application exceptions to
      after the callback, which still allows working with
      <tt class="literal">HibernateTemplate</tt>. In general,
      <tt class="classname">HibernateTemplate</tt>'s convenience methods are
      simpler and more convenient for many scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7576"></a>12.2.5.&nbsp;Implementing DAOs based on plain Hibernate3 API</h3></div></div><div></div></div><p>Hibernate 3.0.1 introduced a feature called "contextual Sessions",
      where Hibernate itself manages one current Session per transaction. This
      is roughly equivalent to Spring's synchronization of one Hibernate
      Session per transaction. A corresponding DAO implementation looks like
      as follows, based on plain Hibernate API:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</pre><p>This Hibernate access style is very similar to what you will find
      in the Hibernate documentation and examples, except for holding the
      <tt class="literal">SessionFactory</tt> in an instance variable. We strongly
      recommend such an instance-based setup over the old-school static
      <tt class="literal">HibernateUtil</tt> class from Hibernate's CaveatEmptor
      sample application! (In general, do not keep any resources in static
      variables unless absolutely necessary!)</p><p>Our DAO above follows the Dependency Injection pattern: It still
      fits nicely into a Spring application context, just like it would if
      coded against Spring's <tt class="literal">HibernateTemplate</tt>. Concretely,
      it uses Setter Injection; if desired, it could use Constructor Injection
      instead. Of course, such a DAO can also be set up in plain Java (for
      example, in unit tests): simply instantiate it and call
      <tt class="literal">setSessionFactory</tt> with the desired factory reference.
      As a Spring bean definition, it would look as follows:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and might feel
      more natural to Hibernate developers.</p><p>However, the DAO throws plain
      <tt class="literal">HibernateException</tt> (which is unchecked, so does not
      have to be declared or caught), which means that callers can only treat
      exceptions as generally fatal - unless they want to depend on
      Hibernate's own exception hierarchy. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly Hibernate-based and/or do not need any
      special exception treatment.</p><p>A further disadvantage of that DAO style is that Hibernate's
      <tt class="literal">getCurrentSession()</tt> feature just works within JTA
      transactions. It does not work with any other transaction strategy
      out-of-the-box, in particular not with local Hibernate
      transactions.</p><p>Fortunately, Spring's <tt class="literal">LocalSessionFactoryBean</tt>
      supports Hibernate's
      <tt class="literal">SessionFactory.getCurrentSession()</tt> method for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="literal">Session</tt> even with
      <tt class="literal">HibernateTransactionManager</tt>. Of course, the standard
      behavior of that method remains: returning the current
      <tt class="literal">Session</tt> associated with the ongoing JTA transaction,
      if any (no matter whether driven by Spring's
      <tt class="literal">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain Hibernate3 API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familar with
      Hibernate, feeling more natural to them. However, such DAOs will throw
      plain <tt class="literal">HibernateException</tt>; conversion to Spring's
      <tt class="literal">DataAccessException</tt> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7641"></a>12.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div><div></div></div><p>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business service here as well, it just needs a Spring
      <tt class="classname">PlatformTransactionManager</tt>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <tt class="methodname">setTransactionManager</tt> method - just like the
      <tt class="classname">productDAO</tt> should be set via a
      <tt class="methodname">setProductDao</tt> method. The following snippets
      show a transaction manager and a business service definition in a Spring
      application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    ...
                }
            }
        );
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7662"></a>12.2.7.&nbsp;Declarative transaction demarcation</h3></div></div><div></div></div><p>Alternatively, one can use Spring's AOP TransactionInterceptor,
      replacing the transaction demarcation code with an interceptor
      configuration in the application context. This allows you to keep
      business services free of repetitive transaction demarcation code in
      each business method. Furthermore, transaction semantics like
      propagation behavior and isolation level can be changed in a
      configuration file and do not affect the business service
      implementations.</p><pre class="programlisting">&lt;beans&gt;
    ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxInterceptor"
      class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="transactionAttributeSource"&gt;
      &lt;value&gt;
        product.ProductService.increasePrice*=PROPAGATION_REQUIRED
        product.ProductService.someOtherBusinessMethod=PROPAGATION_MANDATORY
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;
      &lt;value&gt;product.ProductService&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt;
        &lt;value&gt;myProductServiceTarget&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...
}</pre><p>Spring's <tt class="classname">TransactionInterceptor</tt> allows any
      checked application exception to be thrown with the callback code, while
      <tt class="classname">TransactionTemplate</tt> is restricted to unchecked
      exceptions within the callback.
      <tt class="classname">TransactionTemplate</tt> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <tt class="classname">TransactionStatus</tt>).
      <tt class="classname">TransactionInterceptor</tt> behaves the same way by
      default but allows configurable rollback policies per method. A
      convenient alternative way of setting up declarative transactions is
      <tt class="classname">TransactionProxyFactoryBean</tt>, particularly if
      there are no other AOP interceptors involved.
      <tt class="classname">TransactionProxyFactoryBean</tt> combines the proxy
      definition itself with transaction configuration for a particular target
      bean. This reduces the configuration effort to one target bean plus one
      proxy bean. Furthermore, you do not need to specify which interfaces or
      classes the transactional methods are defined in.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7696"></a>12.2.8.&nbsp;Transaction management strategies</h3></div></div><div></div></div><p>Both <tt class="classname">TransactionTemplate</tt> and
      <tt class="classname">TransactionInterceptor</tt> delegate the actual
      transaction handling to a
      <tt class="classname">PlatformTransactionManager</tt> instance, which can be
      a <tt class="classname">HibernateTransactionManager</tt> (for a single
      Hibernate SessionFactory, using a ThreadLocal Session under the hood) or
      a <tt class="classname">JtaTransactionManager</tt> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <tt class="classname">PlatformTransactionManager</tt>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs.</p><p>For distributed transactions across multiple Hibernate session
      factories, simply combine <tt class="classname">JtaTransactionManager</tt>
      as a transaction strategy with multiple
      <tt class="classname">LocalSessionFactoryBean</tt> definitions. Each of your
      DAOs then gets one specific SessionFactory reference passed into its
      respective bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <tt class="classname">JtaTransactionManager</tt> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.OracleDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <tt class="classname">HibernateTransactionManager</tt> and
      <tt class="classname">JtaTransactionManager</tt> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</p><p><tt class="classname">HibernateTransactionManager</tt> can export the
      JDBC Connection used by Hibernate to plain JDBC access code, for a
      specific DataSource. This allows for high-level transaction demarcation
      with mixed Hibernate/JDBC data access completely without JTA, as long as
      just accessing one database! HibernateTransactionManager will
      automatically expose the Hibernate transaction as JDBC transaction if
      the passed-in SessionFactory has been set up with a DataSource (through
      LocalSessionFactoryBean's "dataSource" property). Alternatively, the
      DataSource that the transactions are supposed to be exposed for can also
      be specified explicitly, through HibernateTransactionManager's
      "dataSource" property.</p><p>Note, for an alternative approach to using
      <tt class="classname">TransactionProxyFactoryBean</tt> to declaratively
      demarcate transactions, please see <a href="transaction.html#beannameautoproxycreator-for-transactions">Section&nbsp;8.5.2, &#8220;BeanNameAutoProxyCreator,
      another declarative approach&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7751"></a>12.2.9.&nbsp;Container resources versus local resources</h3></div></div><div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI SessionFactory and a local one, same for a JNDI DataSource, without
      having to change a single line of application code. Whether to keep the
      resource definitions in the container or locally within the application,
      is mainly a matter of the transaction strategy being used. Compared to a
      Spring-defined local SessionFactory, a manually registered JNDI
      SessionFactory does not provide any benefits. Deploying a SessionFactory
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</p><p>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI DataSources. For non-Spring JTA-driven Hibernate transactions,
      you have to use the Hibernate JCA connector, or extra Hibernate
      transaction code with the TransactionManagerLookup being configured -
      for proper JVM-level caching.</p><p>Spring-driven transactions can work with a locally defined
      Hibernate SessionFactory nicely, just like with a local JDBC DataSource
      - if accessing a single database, of course. Therefore you just have to
      fall back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring app with local resources and
      transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily.</p><p>All things considered: If you do not use EJB, stick with local
      SessionFactory setup and Spring's
      <tt class="classname">HibernateTransactionManager</tt> or
      <tt class="classname">JtaTransactionManager</tt>. You will get all benefits
      including proper transactional JVM-level caching and distributed
      transactions, without any container deployment hassle. JNDI registration
      of a Hibernate SessionFactory via the JCA connector only adds value for
      use within EJBs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>12.2.10.&nbsp;Spurious AppServer warnings about the transaction or DataSource
      no longer being active</h3></div></div><div></div></div><p>In some JTA environments with very strict XADataSource
      implementations -- currently only some WebLogic and WebSphere versions
      -- when using Hibernate configured without any awareness of the JTA
      <tt class="literal">TransactionManager</tt> object for that environment, it is
      is possible for spurious warning or exceptions to show up in the
      application server log. These warnings or exceptions will say something
      to the effect that the connection being accessed is no longer valid, or
      JDBC access is no longer valid, possibly because the transaction is no
      longer active. As an example, here is an actual exception from
      WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction. </pre><p>This warning is easy to resolve by simply making Hibernate
      aware of the JTA <tt class="literal">TransactionManager</tt> instance, to
      which it will also synchronize (along with Spring). This may be done in
      two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>If in your application context you are already directly
          obtaining the JTA <tt class="literal">TransactionManager</tt> object
          (presumably from JNDI via <tt class="literal">JndiObjectFactoryBean</tt>)
          and feeding it for example to Spring's
          <tt class="literal">JtaTransactionManager</tt>, then the easiest way is to
          simply specify a reference to this as the value of
          <tt class="literal">LocalSessionFactoryBean</tt>'s
          <span class="emphasis"><em>jtaTransactionManager</em></span> property. Spring will
          then make the object available to Hibernate.</p></li><li><p>More likely you do not already have the JTA
          <tt class="literal">TransactionManager</tt> instance (since Spring's
          <tt class="literal">JtaTransactionManager</tt> can find it itself) so you
          need to instead configure Hibernate to also look it up directly.
          This is done by configuring an AppServer specific
          <tt class="literal">TransactionManagerLookup</tt> class in the Hibernate
          configuration, as described in the Hibernate manual.</p></li></ul></div><p>It is not necessary to read any more for proper usage, bu the full
      sequence of events with and without Hibernate being aware of the JTA
      <tt class="literal">TransactionManager</tt> will now be described.</p><p>When Hibernate is not configured with any awareness of the JTA
      <tt class="literal">TransactionManager</tt>, the sequence of events when a JTA
      transaction commits is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction commits</p></li><li><p>Spring's <tt class="literal">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via an
          <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction
          manager.</p></li><li><p>Among other activities, this can trigger a callback by Spring
          to Hibernate, via Hibernate's <tt class="literal">afterTransactionCompletion</tt>
          callback (used to clear the Hibernate cache), followed by an explicit
					<tt class="literal">close()</tt> call on the Hibernate Session, which
          results in Hibernate trying to <tt class="literal">close()</tt> the JDBC
          Connection.</p></li><li><p>In some environments, this <tt class="literal">Connection.close()</tt>
          call then triggers the warning or error, as the application server
          no longer considers the Connection usable at all, since the
          transaction has already been committed.</p></li></ul></div><p>When Hibernate is configured with awareness of the JTA
      <tt class="literal">TransactionManager</tt>, the sequence of events when a JTA
      transaction commits is instead as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction is ready to commit</p></li><li><p>Spring's <tt class="literal">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via a
          <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
          transaction manager.</p></li><li><p>Spring is aware that Hibernate itself is synchronized to the
          JTA Transaction, and behaves differently than in the previous
          senario. Assuming the Hibernate Session needs to be closed at all,
          Spring will close it now.</p></li><li><p>JTA Transaction commits</p></li><li><p>Hibernate is synchronized to the JTA transaction, so it is
          called back via an <span class="emphasis"><em>afterCompletion</em></span> callback by
          the JTA transaction manager, and can properly clear its
          cache.</p></li></ul></div><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo"></a>12.3.&nbsp;JDO</h2></div></div><div></div></div><p>Spring supports the standard JDO 1.0/2.0 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <tt class="literal">org.springframework.orm.jdo</tt> package.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7895"></a>12.3.1.&nbsp;PersistenceManagerFactory setup</h3></div></div><div></div></div><p>Spring provides a
      <tt class="classname">LocalPersistenceManagerFactoryBean</tt> class that
      allows for defining a local JDO PersistenceManagerFactory within a
      Spring application context:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><p>Alternatively, a <tt class="literal">PersistenceManagerFactory</tt> can
      also be set up through direct instantiation of a
      <tt class="literal">PersistenceManagerFactory</tt> implementation class. A JDO
      <tt class="literal">PersistenceManagerFactory</tt> implementation class is
      supposed to follow the JavaBeans pattern, just like a JDBC
      <tt class="literal">DataSource</tt> implementation class, which is a natural
      fit for a Spring bean definition. This setup style usually supports a
      Spring-defined JDBC <tt class="literal">DataSource</tt>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>):</p><pre class="programlisting">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;
   
 ...
&lt;/beans&gt;</pre><p>A JDO <tt class="literal">PersistenceManagerFactory</tt> can also be set
      up in the JNDI environment of a J2EE application server, usually through
      the JCA connector provided by the particular JDO implementation.
      Spring's standard <tt class="literal">JndiObjectFactoryBean</tt> can be used
      to retrieve and expose such a
      <tt class="literal">PersistenceManagerFactory</tt>. However, outside an EJB
      context, there is often no compelling benefit in holding the
      <tt class="literal">PersistenceManagerFactory</tt> in JNDI: only choose such
      setup for a good reason. See "container resources versus local
      resources" in the Hibernate section for a discussion; the arguments
      there apply to JDO as well.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7942"></a>12.3.2.&nbsp;JdoTemplate and JdoDaoSupport</h3></div></div><div></div></div><p>Each JDO-based DAO will then receive the
      <tt class="literal">PersistenceManagerFactory</tt> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against plain JDO API, working with
      the given <tt class="literal">PersistenceManagerFactory</tt>, but will usually
      rather be used with Spring's <tt class="literal">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        JdoTemplate jdoTemplate = new JdoTemplate(this.persistenceManagerFactory);
        return (Collection) jdoTemplate.execute(new JdoCallback() {
            public Object doInJdo(PersistenceManager pm) throws JDOException {
                Query query = pm.newQuery(Product.class, "category = pCategory");
                query.declareParameters("String pCategory"); 
                List result = query.execute(category);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any JDO data
      access. <tt class="classname">JdoTemplate</tt> will ensure that
      <tt class="classname">PersistenceManager</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <tt class="literal">find</tt>,
      <tt class="literal">load</tt>, <tt class="literal">makePersistent</tt>, or
      <tt class="literal">delete</tt> call, <tt class="classname">JdoTemplate</tt>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <tt class="classname">JdoDaoSupport</tt> base class that provides a
      <tt class="literal">setPersistenceManagerFactory</tt> method for receiving a
      <tt class="classname">PersistenceManagerFactory</tt>, and
      <tt class="literal">getPersistenceManagerFactory</tt> and
      <tt class="literal">getJdoTemplate</tt> for use by subclasses. In combination,
      this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</pre><p>As alternative to working with Spring's
      <tt class="literal">JdoTemplate</tt>, you can also code Spring-based DAOs at
      the JDO API level, explictly opening and closing a
      <tt class="literal">PersistenceManager</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="literal">JdoDaoSupport</tt> offers a variety of support methods for
      this scenario, for fetching and releasing a transactional
      <tt class="literal">PersistenceManager</tt> as well as for converting
      exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8015"></a>12.3.3.&nbsp;Implementing DAOs based on plain JDO API</h3></div></div><div></div></div><p>DAOs can also be written against plain JDO API, without any Spring
      dependencies, directly using an injected
      <tt class="literal">PersistenceManagerFactory</tt>. A corresponding DAO
      implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        try {
            Query query = pm.newQuery(Product.class, "category = pCategory");
            query.declareParameters("String pCategory"); 
            return query.execute(category);
        }
        finally {
          pm.close();
        }
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, just like it
      would if coded against Spring's <tt class="literal">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that they always get a new
      <tt class="literal">PersistenceManager</tt> from the factory. To still access
      a Spring-managed transactional <tt class="literal">PersistenceManager</tt>,
      consider defining a
      <tt class="literal">TransactionAwarePersistenceManagerFactoryProxy</tt> (as
      included in Spring) in front of your target
      <tt class="literal">PersistenceManagerFactory</tt>, passing the proxy into
      your DAOs.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>Your data access code will then receive a transactional
      <tt class="literal">PersistenceManager</tt> (if any) from the
      <tt class="literal">PersistenceManagerFactory.getPersistenceManager()</tt>
      method that it calls. The latter method call goes through the proxy,
      which will first check for a current transactional
      <tt class="literal">PersistenceManager</tt> before getting a new one from the
      factory. <tt class="literal">close</tt> calls on the
      <tt class="literal">PersistenceManager</tt> will be ignored in case of a
      transaction <tt class="literal">PersistenceManager</tt>.</p><p>If your data access code will always run within an active
      transaction (or at least within active transaction synchronization), it
      is safe to omit the <tt class="literal">PersistenceManager.close()</tt> call
      and thus the entire <tt class="literal">finally</tt> block, which you might
      prefer to keep your DAO implementations concise:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.class, "category = pCategory");
        query.declareParameters("String pCategory"); 
        return query.execute(category);
    }
}</pre><p>With such DAOs that rely on active transactions, it is recommended
      to enforce active transactions through turning
      <tt class="literal">TransactionAwarePersistenceManagerFactoryProxy</tt>'s
      "allowCreate" flag off:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
    &lt;property name="allowCreate" value="false"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on JDO API
      only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to JDO developers.</p><p>However, the DAO throws plain <tt class="literal">JDOException</tt>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on JDO's own exception structure. Catching specific
      causes such as an optimistic locking failure is not possible without
      tying the caller to the implementation strategy. This tradeoff might be
      acceptable to applications that are strongly JDO-based and/or do not
      need any special exception treatment.</p><p>In summary: DAOs can be implemented based on plain JDO API, while
      still being able to participate in Spring-managed transactions. This
      might in particular appeal to people already familar with JDO, feeling
      more natural to them. However, such DAOs will throw plain
      <tt class="literal">JDOException</tt>; conversion to Spring's
      <tt class="literal">DataAccessException</tt> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8100"></a>12.3.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <tt class="literal">TransactionProxyFactoryBean</tt> for a
      ProductService, which in turn delegates to the JDO-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <tt class="literal">JdoTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="literal">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p><tt class="literal">JdoTransactionManager</tt> is capable of exposing a
      JDO transaction to JDBC access code that accesses the same JDBC
      <tt class="literal">DataSource</tt>, provided that the registered
      <tt class="literal">JdoDialect</tt> supports retrieval of the underlying JDBC
      <tt class="literal">Connection</tt>. This is by default the case for
      JDBC-based JDO 2.0 implementations; for JDO 1.0 implementations, a
      custom <tt class="literal">JdoDialect</tt> needs to be used. See next section
      for details on the <tt class="literal">JdoDialect</tt> mechanism.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8138"></a>12.3.5.&nbsp;JdoDialect</h3></div></div><div></div></div><p>As an advanced feature, both <tt class="literal">JdoTemplate</tt> and
      <tt class="literal">JdoTransactionManager</tt> support a custom
      <tt class="literal">JdoDialect</tt>, to be passed into the "jdoDialect" bean
      property. In such a scenario, the DAOs won't receive a
      <tt class="literal">PersistenceManagerFactory</tt> reference but rather a full
      <tt class="literal">JdoTemplate</tt> instance instead (for example, passed
      into <tt class="literal">JdoDaoSupport</tt>'s "jdoTemplate" property). A
      <tt class="literal">JdoDialect</tt> implementation can enable some advanced
      features supported by Spring, usually in a vendor-specific
      manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
          <tt class="literal">Connection</tt> (for exposure to JDBC-based
          DAOs)</p></li><li><p>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</p></li><li><p>eagerly flushing a <tt class="literal">PersistenceManager</tt> (to
          make transactional changes visible to JDBC-based data access
          code)</p></li><li><p>advanced translation of <tt class="literal">JDOExceptions</tt> to
          Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>This is particularly valuable for JDO 1.0 implementations, where
      none of those features are covered by the standard API. On JDO 2.0, most
      of those features are supported in a standard manner: Hence, Spring's
      <tt class="literal">DefaultJdoDialect</tt> uses the corresponding JDO 2.0 API
      methods by default (as of Spring 1.2). For special transaction semantics
      and for advanced translation of exception, it is still valuable to
      derive vendor-specific <tt class="literal">JdoDialect</tt> subclasses.</p><p>See the <tt class="literal">JdoDialect</tt> javadoc for more details on
      its operations and how they are used within Spring's JDO support.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-toplink"></a>12.4.&nbsp;Oracle TopLink</h2></div></div><div></div></div><p>Since Spring 1.2, Spring supports Oracle TopLink (<a href="http://www.oracle.com/technology/products/ias/toplink" target="_top">http://www.oracle.com/technology/products/ias/toplink</a>) as
    data access strategy, following the same style as the Hibernate support.
    Both TopLink 9.0.4 (the production version as of Spring 1.2) and 10.1.3
    (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <tt class="literal">org.springframework.orm.toplink</tt> package.</p><p>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8216"></a>12.4.1.&nbsp;SessionFactory abstraction</h3></div></div><div></div></div><p>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <tt class="literal">ServerSession</tt>, which in turn is able to spawn
      <tt class="literal">ClientSession</tt>s for single-threaded usage. For
      flexible setup options, Spring defines a
      <tt class="literal">SessionFactory</tt> abstraction for TopLink, enabling to
      switch between different <tt class="literal">Session</tt> creation
      strategies.</p><p>As a one-stop shop, Spring provides a
      <tt class="classname">LocalSessionFactoryBean</tt> class that allows for
      defining a TopLink <tt class="literal">SessionFactory</tt> with bean-style
      configuration. It needs to be configured with the location of the
      TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <tt class="literal">DataSource</tt> to use.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><pre class="programlisting">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</pre><p>Usually,
      <tt class="literal">LocalSessionFactoryBean</tt> will hold a multi-threaded
      TopLink <tt class="literal">ServerSession</tt> underneath and create
      appropriate client <tt class="literal">Session</tt>s for it: either a plain
      <tt class="literal">Session</tt> (typical), a managed
      <tt class="literal">ClientSession</tt>, or a transaction-aware
      <tt class="literal">Session</tt> (the latter are mainly used internally by
      Spring's TopLink support). It might also hold a single-threaded TopLink
      <tt class="literal">DatabaseSession</tt>; this is rather unusual,
      though.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8272"></a>12.4.2.&nbsp;TopLinkTemplate and TopLinkDaoSupport</h3></div></div><div></div></div><p>Each TopLink-based DAO will then receive the
      <tt class="literal">SessionFactory</tt> through dependency injection, i.e.
      through a bean property setter or through a constructor argument. Such a
      DAO could be coded against plain TopLink API, fetching a
      <tt class="literal">Session</tt> from the given
      <tt class="literal">SessionFactory</tt>, but will usually rather be used with
      Spring's <tt class="literal">TopLinkTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        TopLinkTemplate tlTemplate = new TopLinkTemplate(this.sessionFactory);
        return (Collection) tlTemplate.execute(new TopLinkCallback() {
            public Object doInTopLink(Session session) throws TopLinkException {
                ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                findOwnersQuery.addArgument("Category");
                ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                findOwnersQuery.setSelectionCriteria(
                    builder.get("category").like(builder.getParameter("Category")));

                Vector args = new Vector();
                args.add(category);
                List result = session.executeQuery(findOwnersQuery, args);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any TopLink
      data access. <tt class="classname">TopLinkTemplate</tt> will ensure that
      <tt class="classname">Session</tt>s are properly opened and closed, and
      automatically participate in transactions. The template instances are
      thread-safe and reusable, they can thus be kept as instance variables of
      the surrounding class. For simple single-step actions such as a single
      <tt class="literal">executeQuery</tt>, <tt class="literal">readAll</tt>,
      <tt class="literal">readById</tt>, or <tt class="literal">merge</tt> call,
      <tt class="classname">JdoTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">TopLinkDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory</tt> method for receiving a
      <tt class="classname">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory</tt> and
      <tt class="literal">getTopLinkTemplate</tt> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}</pre><p>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</p><p>As alternative to working with Spring's
      <tt class="literal">TopLinkTemplate</tt>, you can also code your TopLink data
      access based on the raw TopLink API, explictly opening and closing a
      <tt class="literal">Session</tt>. As elaborated in the corresponding Hibernate
      section, the main advantage of this approach is that your data access
      code is able to throw checked exceptions.
      <tt class="literal">TopLinkDaoSupport</tt> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <tt class="literal">Session</tt> as well as for converting exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8350"></a>12.4.3.&nbsp;Implementing DAOs based on plain TopLink API</h3></div></div><div></div></div><p>DAOs can also be written against plain TopLink API, without any
      Spring dependencies, directly using an injected TopLink
      <tt class="literal">Session</tt>. The latter will usually be based on a
      <tt class="literal">SessionFactory</tt> defined by a
      <tt class="literal">LocalSessionFactoryBean</tt>, exposed for bean references
      of type <tt class="literal">Session</tt> through Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt>.</p><p>The <tt class="literal">getActiveSession()</tt> method defined on
      TopLink's <tt class="literal">Session</tt> interface will return the current
      transactional <tt class="literal">Session</tt> in such a scenario. If there is
      no active transaction, it will return the shared TopLink
      <tt class="literal">ServerSession</tt> as-is, which is only supposed to be
      used directly for read-only access. There is also an analogous
      <tt class="literal">getActiveUnitOfWork()</tt> method, returning the TopLink
      <tt class="literal">UnitOfWork</tt> associated with the current transaction,
      if any (returning null else).</p><p>A corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private Session session;

    public void setSession(Session session) {
        this.session = session;
    }

    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        Vector args = new Vector();
        args.add(category);
        return session.getActiveSession().executeQuery(findOwnersQuery, args);
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, analogous to
      like it would if coded against Spring's
      <tt class="literal">TopLinkTemplate</tt>. Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> is used to expose a
      bean reference of type <tt class="literal">Session</tt>, to be passed into the
      DAO:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="mySessionAdapter"
      class="org.springframework.orm.toplink.support.TransactionAwareSessionAdapter"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="session" ref="mySessionAdapter"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on TopLink
      API only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to TopLink developers.</p><p>However, the DAO throws plain <tt class="literal">TopLinkException</tt>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on TopLink's own exception structure. Catching
      specific causes such as an optimistic locking failure is not possible
      without tying the caller to the implementation strategy. This tradeoff
      might be acceptable to applications that are strongly TopLink-based
      and/or do not need any special exception treatment.</p><p>A further disadvantage of that DAO style is that TopLink's
      standard <tt class="literal">getActiveSession()</tt> feature just works within
      JTA transactions. It does not work with any other transaction strategy
      out-of-the-box, in particular not with local TopLink
      transactions.</p><p>Fortunately, Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> exposes a
      corresponding proxy for the TopLink <tt class="literal">ServerSession</tt>
      which supports TopLink's <tt class="literal">Session.getActiveSession()</tt>
      and <tt class="literal">Session.getActiveUnitOfWork()</tt> methods for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="literal">Session</tt> even with
      <tt class="literal">TopLinkTransactionManager</tt>. Of course, the standard
      behavior of that method remains: returning the current
      <tt class="literal">Session</tt> associated with the ongoing JTA transaction,
      if any (no matter whether driven by Spring's
      <tt class="literal">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain TopLink API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familar with TopLink,
      feeling more natural to them. However, such DAOs will throw plain
      <tt class="literal">TopLinkException</tt>; conversion to Spring's
      <tt class="literal">DataAccessException</tt> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8453"></a>12.4.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <tt class="literal">TransactionProxyFactoryBean</tt> for a
      ProductService, which in turn delegates to the TopLink-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that TopLink requires an active <tt class="literal">UnitOfWork</tt>
      for modifying a persistent object. (You should never modify objects
      returned by a plain TopLink <tt class="literal">Session</tt> - those are
      usually read-only objects, directly taken from the second-level cache!)
      There is no concept like a non-transactional flush in TopLink, in
      contrast to Hibernate. For this reason, TopLink needs to be set up for a
      specific environment: in particular, it needs to be explicitly set up
      for JTA synchronization, to detect an active JTA transaction itself and
      expose a corresponding active <tt class="literal">Session</tt> and
      <tt class="literal">UnitOfWork</tt>. This is not necessary for local
      transactions as performed by Spring's
      <tt class="literal">TopLinkTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="literal">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p>Within your TopLink-based DAO code, use the
      <tt class="literal">Session.getActiveUnitOfWork()</tt> method to access the
      current <tt class="literal">UnitOfWork</tt> and perform write operations
      through it. This will only work within an active transaction (both
      within Spring-managed transactions and plain JTA transactions). For
      special needs, you can also acquire separate
      <tt class="literal">UnitOfWork</tt> instances that won't participate in the
      current transaction; this is hardly needed, though.</p><p><tt class="literal">TopLinkTransactionManager</tt> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <tt class="literal">DataSource</tt>, provided that TopLink works
      with JDBC in the backend and is thus able to expose the underlying JDBC
      <tt class="literal">Connection</tt>. The <tt class="literal">DataSource</tt> to
      expose the transactions for needs to be specified explicitly; it won't
      be autodetected.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ojb"></a>12.5.&nbsp;Apache OJB</h2></div></div><div></div></div><p>Apache OJB (<a href="http://db.apache.org/ojb" target="_top">http://db.apache.org/ojb</a>) offers
    multiple API levels, such as ODMG and JDO. Aside from supporting OJB
    through JDO, Spring also supports OJB's lowe-level PersistenceBroker API
    as data access strategy. The corresponding integration classes reside in
    the <tt class="literal">org.springframework.orm.ojb</tt> package.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8518"></a>12.5.1.&nbsp;OJB setup in a Spring environment</h3></div></div><div></div></div><p>In contrast to Hibernate or JDO, OJB does not follow a factory
      object pattern for its resources. Instead, an OJB PersistenceBroker has
      to be obtained from the static PersistenceBrokerFactory class. That
      factory initializes itself from an OJB.properties file, residing in the
      root of the class path.</p><p>In addition to supporting OJB's default initialization style,
      Spring also provides a <tt class="classname">Local</tt>OjbConfigurer class
      that allows for using Spring-managed <tt class="literal">DataSource</tt>
      instances as OJB connection providers. The <tt class="literal">DataSource</tt>
      instances are referenced in the OJB repository descriptor (the mapping
      file), through the "jcd-alias" defined there: each such alias is matched
      against the Spring-managed bean of the same name.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="ojbConfigurer" class="org.springframework.orm.ojb.support.LocalOjbConfigurer"/&gt;
   
  ...
&lt;/beans&gt;</pre><pre class="programlisting">&lt;descriptor-repository version="1.0"&gt;

  &lt;jdbc-connection-descriptor jcd-alias="dataSource" default-connection="true" ...&gt;
        ...
  &lt;/jdbc-connection-descriptor&gt;

  ...
&lt;/descriptor-repository&gt;</pre><p>A PersistenceBroker can then be opened through standard OJB API,
      specifying a corresponding "PBKey", usually through the corresponding
      "jcd-alias" (or relying on the default connection).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8542"></a>12.5.2.&nbsp;PersistenceBrokerTemplate and PersistenceBrokerDaoSupport</h3></div></div><div></div></div><p>Each OJB-based DAO will be configured with a "PBKey" through
      bean-style configuration, i.e. through a bean property setter. Such a
      DAO could be coded against plain OJB API, working with OJB's static
      <tt class="literal">PersistenceBrokerFactory</tt>, but will usually rather be
      used with Spring's <tt class="literal">PersistenceBrokerTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private String jcdAlias;

    public void setJcdAlias(String jcdAlias) {
        this.jcdAlias = jcdAlias;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        PersistenceBrokerTemplate pbTemplate =
                new PersistenceBrokerTemplate(new PBKey(this.jcdAlias);
        return (Collection) pbTemplate.execute(new PersistenceBrokerCallback() {
            public Object doInPersistenceBroker(PersistenceBroker pb)
                    throws PersistenceBrokerException {

                Criteria criteria = new Criteria();
                criteria.addLike("category", category + "%");
                Query query = new QueryByCriteria(Product.class, criteria);

                List result = pb.getCollectionByQuery(query);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any OJB data
      access. <tt class="classname">PersistenceBrokerTemplate</tt> will ensure
      that <tt class="classname">PersistenceBroker</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <tt class="literal">getObjectById</tt>,
      <tt class="literal">getObjectByQuery</tt>, <tt class="literal">store</tt>, or
      <tt class="literal">delete</tt> call,
      <tt class="classname">PersistenceBrokerTemplate</tt> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <tt class="classname">PersistenceBrokerDaoSupport</tt> base class that
      provides a <tt class="literal">setJcdAlias</tt> method for receiving an OJB
      JCD alias, and <tt class="literal">getPersistenceBrokerTemplate</tt> for use
      by subclasses. In combination, this allows for very simple DAO
      implementations for typical requirements:</p><pre class="programlisting">public class ProductDaoImpl extends PersistenceBrokerDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Criteria criteria = new Criteria();
        criteria.addLike("category", category + "%");
        Query query = new QueryByCriteria(Product.class, criteria);

        return getPersistenceBrokerTemplate().getCollectionByQuery(query);
    }
}</pre><p>As alternative to working with Spring's
      <tt class="literal">PersistenceBrokerTemplate</tt>, you can also code your OJB
      data access against plain OJB API, explictly opening and closing a
      <tt class="literal">PersistenceBroker</tt>. As elaborated in the corresponding
      Hibernate section, the main advantage of this approach is that your data
      access code is able to throw checked exceptions.
      <tt class="literal">PersistenceBrokerDaoSupport</tt> offers a variety of
      support methods for this scenario, for fetching and releasing a
      transactional <tt class="literal">PersistenceBroker</tt> as well as for
      converting exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8606"></a>12.5.3.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <tt class="literal">TransactionProxyFactoryBean</tt> for a
      ProductService, which in turn delegates to the OJB-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.ojb.PersistenceBrokerTransactionManager"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that OJB's PersistenceBroker level does not track changes of
      loaded objects. Therefore, a PersistenceBroker transaction is
      essentially simply a database transaction at the PersistenceBroker
      level, just with an additional first-level cache for persistent objects.
      Lazy loading will work both with and without the PersistenceBroker being
      open, in contrast to Hibernate and JDO (where the original Session or
      PersistenceManager, respectively, needs to remain open).</p><p><tt class="literal">PersistenceBrokerTransactionManager</tt> is capable
      of exposing an OJB transaction to JDBC access code that accesses the
      same JDBC <tt class="literal">DataSource</tt>. The
      <tt class="literal">DataSource</tt> to expose the transactions for needs to be
      specified explicitly; it won't be autodetected.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ibatis"></a>12.6.&nbsp;iBATIS SQL Maps</h2></div></div><div></div></div><p>Through the <tt class="literal">org.springframework.orm.ibatis</tt>
    package, Spring supports iBATIS SQL Maps 1.x and 2.x (<a href="http://www.ibatis.com" target="_top">http://www.ibatis.com</a>). The iBATIS support much resembles
    the JDBC / Hibernate support in that it supports the same template style
    programming and just as with JDBC or Hibernate, the iBATIS support works
    with Spring's exception hierarchy and let's you enjoy the all IoC features
    Spring has.</p><p>Transaction management can be handled through Spring's standard
    facilities, for example through
    <tt class="literal">TransactionProxyFactoryBean</tt>. There are no special
    transaction strategies for iBATIS, as there is no special transactional
    resource involved other than a JDBC <tt class="literal">Connection</tt>. Hence,
    Spring's standard JDBC <tt class="literal">DataSourceTransactionManager</tt> or
    <tt class="literal">JtaTransactionManager</tt> are perfectly sufficient.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8653"></a>12.6.1.&nbsp;Overview and differences between iBATIS 1.x and 2.x</h3></div></div><div></div></div><p>Spring supports both iBATIS SQL Maps 1.x and 2.x. First let's have
      a look at the differences between the two.</p><p>The XML config files have changed a bit, node and attribute names.
      Also the Spring classes you need to extend are different, as are some
      method names.</p><div class="table"><a name="d0e8660"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;iBATIS SQL Maps supporting classes for 1.x and 2.x</b></p><table summary="iBATIS SQL Maps supporting classes for 1.x and 2.x" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>1.x</th><th>2.x</th></tr></thead><tbody><tr><td>Creation of SqlMap(Client)</td><td><tt class="literal">SqlMapFactoryBean</tt></td><td><tt class="literal">SqlMapClientFactoryBean</tt></td></tr><tr><td>Template-style helper class</td><td><tt class="literal">SqlMapTemplate</tt></td><td><tt class="literal">SqlMapClientTemplate</tt></td></tr><tr><td>Callback to use MappedStatement</td><td><tt class="literal">SqlMapCallback</tt></td><td><tt class="literal">SqlMapClientCallback</tt></td></tr><tr><td>Super class for DAOs</td><td><tt class="literal">SqlMapDaoSupport</tt></td><td><tt class="literal">SqlMapClientDaoSupport</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8712"></a>12.6.2.&nbsp;iBATIS SQL Maps 1.x</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8715"></a>12.6.2.1.&nbsp;Setting up the SqlMap</h4></div></div><div></div></div><p>Using iBATIS SQL Maps involves creating SqlMap configuration
        files containing statements and result maps. Spring takes care of
        loading those using the <tt class="literal">SqlMapFactoryBean</tt>.</p><pre class="programlisting">public class Account {

    private String name;
    private String email;
    
    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return this.email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}</pre><p>Suppose we would want to map this class. We'd have to create
        the following <tt class="literal">SqlMap</tt>. Using the query, we can later
        on retrieve users through their email addresses.
        <tt class="literal">Account.xml</tt>:</p><pre class="programlisting">&lt;sql-map name="Account"&gt;

  &lt;result-map name="result" class="examples.Account"&gt;
    &lt;property name="name" column="NAME" columnIndex="1"/&gt;
    &lt;property name="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/result-map&gt;
    
  &lt;mapped-statement name="getAccountByEmail" result-map="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/mapped-statement&gt;
    
  &lt;mapped-statement name="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/mapped-statement&gt;

&lt;/sql-map&gt;</pre><p> After having defined the Sql Map, we have to
        create a configuration file for iBATIS
        (<tt class="literal">sqlmap-config.xml</tt>): </p><pre class="programlisting">&lt;sql-map-config&gt;

  &lt;sql-map resource="example/Account.xml"/&gt;

&lt;/sql-map-config&gt;</pre><p> iBATIS loads resources from the class
        path, so be sure to add the <tt class="literal">Account.xml</tt> file to the
        class path.</p><p>Using Spring, we can now very easily set up the
        <tt class="literal">SqlMap</tt>, using the
        <tt class="literal">SqlMapFactoryBean</tt>: </p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8755"></a>12.6.2.2.&nbsp;Using <tt class="literal">SqlMapTemplate</tt> and
        <tt class="literal">SqlMapDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="literal">SqlMapDaoSupport</tt> class offers a
        supporting class similar to the <tt class="literal">HibernateDaoSupport</tt>
        and the <tt class="literal">JdoDaoSupport</tt> classes. Let's implement a
        DAO: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapTemplate().executeUpdate("insertAccount", account);
    }
}</pre><p> As you can see, we're using the pre-configured
        <tt class="literal">SqlMapTemplate</tt> to execute the query. Spring has
        initialized the <tt class="literal">SqlMap</tt> for us using the
        <tt class="literal">SqlMapFactoryBean</tt>, and when setting up the
        <tt class="literal">SqlMapAccountDao</tt> as follows, you're all set to go.
        Note that with iBATIS SQL Maps 1.x, the JDBC
        <tt class="literal">DataSource</tt> is usually specified on the
        DAO.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="sqlMap" ref="sqlMap"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="literal">SqlMapTemplate</tt> instance could
        also be created manually, passing in the <tt class="literal">DataSource</tt>
        and the <tt class="literal">SqlMap</tt> as constructor arguments. The
        <tt class="literal">SqlMapDaoSupport</tt> base class simply pre-initializes
        a <tt class="literal">SqlMapTemplate</tt> instance for us.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8811"></a>12.6.3.&nbsp;iBATIS SQL Maps 2.x</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8814"></a>12.6.3.1.&nbsp;Setting up the SqlMapClient</h4></div></div><div></div></div><p>If we want to map the previous Account class with iBATIS 2.x we
        need to create the following SQL map <tt class="literal">Account.xml</tt>:
        </p><pre class="programlisting">&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</pre><p>The configuration file for iBATIS 2 changes a
        bit (<tt class="literal">sqlmap-config.xml</tt>): </p><pre class="programlisting">&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</pre><p>Remember that iBATIS loads resources
        from the class path, so be sure to add the
        <tt class="literal">Account.xml</tt> file to the class path.</p><p>We can use the <tt class="literal">SqlMapClientFactoryBean</tt> in the
        Spring application context. Note that with iBATIS SQL Maps 2.x, the
        JDBC <tt class="literal">DataSource</tt> is usually specified on the
        <tt class="literal">SqlMapClientFactoryBean</tt>, which enables lazy
        loading.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8847"></a>12.6.3.2.&nbsp;Using <tt class="literal">SqlMapClientTemplate</tt> and
        <tt class="literal">SqlMapClientDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="literal">SqlMapClientDaoSupport</tt> class offers a
        supporting class similar to the <tt class="literal">SqlMapDaoSupport</tt>.
        We extend it to implement our DAO: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</pre><p>In the DAO, we use the pre-configured
        <tt class="literal">SqlMapClientTemplate</tt> to execute the queries, after
        setting up the <tt class="literal">SqlMapAccountDao</tt> in the application
        context and wiring it with our <tt class="literal">SqlMapClient</tt>
        instance: </p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="literal">SqlMapTemplate</tt> instance could
        also be created manually, passing in the
        <tt class="literal">SqlMapClient</tt> as constructor argument. The
        <tt class="literal">SqlMapClientDaoSupport</tt> base class simply
        pre-initializes a <tt class="literal">SqlMapClientTemplate</tt> instance for
        us.</p><p>The <tt class="literal">SqlMapClientTemplate</tt> also offers a
        generic <tt class="literal">execute</tt> method, taking a custom
        <tt class="literal">SqlMapClientCallback</tt> implementation as argument.
        This can, for example, be used for batching: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {
    ...

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {
            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
                executor.startBatch();
                executor.update("insertAccount", account);
                executor.update("insertAddress", account.getAddress());
                executor.executeBatch();
            }
        });
    }
}</pre><p>In general, any combination of operations offered by the
        native <tt class="literal">SqlMapExecutor</tt> API can be used in such a
        callback. Any <tt class="literal">SQLException</tt> thrown will
        automatically get converted to Spring's generic
        <tt class="literal">DataAccessException</tt> hierarchy.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8914"></a>12.6.3.3.&nbsp;Implementing DAOs based on plain iBATIS API</h4></div></div><div></div></div><p>DAOs can also be written against plain iBATIS API, without any
        Spring dependencies, directly using an injected
        <tt class="literal">SqlMapClient</tt>. A corresponding DAO implementation
        looks like as follows:</p><pre class="programlisting">public class SqlMapAccountDao implements AccountDao {
        
    private SqlMapClient sqlMapClient;
    
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }

    public Account getAccount(String email) {
        try {
            return (Account) this.sqlMapClient.queryForObject("getAccountByEmail", email);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }

    public void insertAccount(Account account) throws DataAccessException {
        try {
            this.sqlMapClient.update("insertAccount", account);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }
}</pre><p>In such a scenario, the <tt class="literal">SQLException</tt>
        thrown by the iBATIS API needs to be handled in a custom fashion:
        usually, wrapping it in your own application-specific DAO exception.
        Wiring in the application context would still look like before, due to
        the fact that the plain iBATIS-based DAO still follows the Dependency
        Injection pattern: </p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="mvc.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;11.&nbsp;Data Access using JDBC&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;13.&nbsp;Web MVC framework</td></tr></table></div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>


<!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script>
<script type="text/javascript">var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");pageTracker._setAllowLinker(true);
pageTracker._trackPageview();var OrgTracker = _gat._getTracker("UA-2728886-2");
OrgTracker._trackPageview();</script>
 <!-- End 2nd Google code -->



</body>
</html>