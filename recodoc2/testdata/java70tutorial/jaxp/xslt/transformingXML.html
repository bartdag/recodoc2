<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html lang="en-US">
    <head>
        <title>Transforming XML Data with XSLT (The Java&trade; Tutorials &gt;        
            Java API for XML Processing (JAXP) &gt; Extensible Stylesheet Language Transformations)
</title>

     <meta name="description" content="This JAXP Java tutorial describes Java API for XML Processing (jaxp), XSLT, SAX, and related XML topics" />
     <meta name="keywords" content="java programming, learn java, java sample code, jaxp, xml, xslt, sax" />
        
<style type="text/css">
    .FigureCaption   { 
        margin-left: 1in; 
        margin-right: 1in; 
        font-family: sans-serif; 
        font-size: smaller; 
        text-align: justify;
    }
    #TopBar_bl {
        background: url(../../images/java_bar_bl.gif) 0 100% no-repeat;
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        background: url(../../images/java_bar_br.gif) 100% 100% no-repeat;
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        background: url(../../images/java_bar_tl.gif) 0 0 no-repeat;
        width: 100%;
        height: 60px;
    }
    #TopBar_tr {
        background: url(../../images/java_bar_tr.gif) 100% 0 no-repeat;
        width: 100%;
        height: 60px;
    }
    #TopBar {
        background: #35556B url(../../images/java_bar.gif);
        margin: 10px 10px 0 10px;
        height:60px;
        min-width:700px;
        color: white;
        font-family: sans-serif; 
        font-weight: bold;
    }
    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    #TopBar_right {
        line-height: 14px;
        float: right;
        padding-top: 2px;
        padding-right: 30px;
        text-align: center;
    }
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 12px;
        margin: 3px;
        padding: 0;
    }
    #TopBar a:visited, #TopBar a:link {
        color: white;
        text-decoration: none;
    }
    #TopBar a:hover, #TopBar a:active  {
        background-color: white;
        color: #35556B;
    }
    #BreadCrumbs {
        padding: 4px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    #BreadCrumbs a {
        color: blue;
    }
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    .LeftBar_shown {
        width: 13em;
        float: left;
        margin-left: 10px;
        margin-top: 4px;
        margin-bottom: 2em;
        margin-right: 10px;
    }
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    .LeftBar_hidden {
        display: none;
    }
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }
    
    #Footer2 {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;
    }
    .NavBit  {
        padding: 4px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    @media print {
        .NavBit {
            display: none;
        }
    }
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    #Contents a, .NavBit a, #TagNotes a {
        color: blue
    }
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #F90000;
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #F90000;
        font-family: sans-serif;
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
    }

    /t

</style>
<script type="text/javascript">
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide the TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }
    
</script>
<noscript> 
A browser with JavaScript enabled is required for this page to operate properly.
</noscript>

    </head>
<body onload="load()">
    <div id=TopBar> <div id=TopBar_tr> <div id=TopBar_tl> <div id=TopBar_br> <div id=TopBar_bl> 
                        <div id=TopBar_right> 
                            <a target="_blank"
                                href="http://java.sun.com/javase/6/download.jsp">Download
                                the JDK</a>
                            <br>
                            <a href="../../search.html" target="_blank">Search the
                                Tutorials</a>
                            <br>
                            <a href="javascript:toggleLeft()"
                                id="ToggleLeft">Hide the TOC</a>
                        </div>
                    </div> </div> </div> </div> </div>
    <div class=PrintHeaders>
        <b>Trail:</b> Java API for XML Processing (JAXP)
        <br><b>Lesson:</b> Extensible Stylesheet Language Transformations
    </div>

    <div id=LeftBar class=LeftBar_shown>
        <div id=Contents>
            <div class="linkLESSON"><a href="index.html">Extensible Stylesheet Language Transformations</a></div>
<div class="linkAHEAD"><a href="intro.html">Introducing XSL, XSLT, and XPath</a></div>
<div class="linkAHEAD"><a href="xpath.html">How XPath Works</a></div>
<div class="linkAHEAD"><a href="writingDom.html">Writing Out a DOM as an XML File</a></div>
<div class="linkAHEAD"><a href="generatingXML.html">Generating XML from an Arbitrary Data Structure</a></div>
<div class="nolinkAHEAD">Transforming XML Data with XSLT</div>
</div>
    </div>
    <div id=MainFlow class=MainFlow_indented>
            <span id=BreadCrumbs>
                <a href=../../index.html target=_top>Home Page</a>
                &gt;
                <a href=../index.html target=_top>Java API for XML Processing (JAXP)</a>
                &gt;
                <a href=index.html target=_top>Extensible Stylesheet Language Transformations</a>
            </span>
            <div class=NavBit>
                <a target=_top href=generatingXML.html>&laquo;&nbsp;Previous</a>&nbsp;&bull;&nbsp;<a target=_top href=../TOC.html>Trail</a>&nbsp;&bull;&nbsp;<a target=_top href=../stax/index.html>Next&nbsp;&raquo;</a>
            </div>
            <div id=PageTitle><h1>Transforming XML Data with XSLT</h1></div>
            <div id=PageContent>
<!-- Transforming XML Data with XSLT -->

The Extensible Stylesheet Language Transformations (XSLT) APIs can be used for many purposes.
For example, with a sufficiently intelligent stylesheet, you could generate PDF or PostScript
output from the XML data. But generally, XSLT is used to generate formatted
HTML output, or to create an alternative XML representation of the data.</p><p>In this section, an XSLT transform is used to translate XML input
data to HTML output.</p>
<hr><p><b>Note - </b>The
<a class="OutsideLink" target="_blank" href="http://www.w3.org/TR/xslt20/">XSLT specification</a> is large and complex, so this tutorial can only scratch the
surface. It will give you a little background so you can understand
simple XSLT processing tasks, but it does not examine in detail how to
write an XSLT transform, rather concentrating on how to use JAXP's XSLT transform
API. For a more thorough grounding in XSLT, consult a good reference manual,
such as Michael Kay's <i>XSLT 2.0 and XPath 2.0: Programmer's Reference</i> (Wrox, 2008).</p>
<hr>


<a name="ggyvk"></a><h2>Defining a Simple Document Type</h2>
<p>Start by defining a very simple document type that can be used
for writing articles. Our <tt>article</tt> documents will contain these structure tags:</p>
<ul><li><p><tt>&lt;TITLE></tt>: The title of the article</p></li>
<li><p><tt>&lt;SECT></tt>: A section, consisting of a heading and a body </p></li>
<li><p><tt>&lt;PARA></tt>: A paragraph</p></li>
<li><p><tt>&lt;LIST></tt>: A list </p></li>
<li><p><tt>&lt;ITEM></tt>: An entry in a list </p></li>
<li><p><tt>&lt;NOTE></tt>: An aside, that is offset from the main text</p></li></ul>
<p>The slightly unusual aspect of this structure is that we will not
create a separate element tag for a section heading. Such elements are commonly
created to distinguish the heading text (and any tags it contains) from the
body of the section (that is, any structure elements underneath the heading).</p><p>Instead, we will allow the heading to merge seamlessly into the body of
a section. That arrangement adds some complexity to the stylesheet, but it will
give us a chance to explore XSLT's template-selection mechanisms. It also matches our
intuitive expectations about document structure, where the text of a heading is followed
directly by structure elements, an arrangement that can simplify outline-oriented editing.</p>
<hr><p><b>Note - </b>This kind of structure is not easily validated, because XML's mixed-content model allows
text anywhere in a section, whereas we want to confine text and inline
elements so that they appear only before the first structure element in the
body of the section. The assertion-based validator can do it, but most other
schema mechanisms cannot. So we will dispense with defining a DTD for the
document type.</p>
<hr>
<p>In this structure, sections can be nested. The depth of the nesting will
determine what kind of HTML formatting to use for the section heading (for
example, <tt>h1</tt> or <tt>h2</tt>). Using a plain <tt>SECT</tt> tag (instead of numbered
sections) is also useful with outline-oriented editing, because it lets you move sections
around at will without having to worry about changing the numbering for any
of the affected sections.</p><p>For lists, we will use a type attribute to specify whether the
list entries are unordered (bulleted), alpha (enumerated with lowercase letters), ALPHA (enumerated with uppercase
letters), or numbered.</p><p>We will also allow for some inline tags that change the appearance
of the text.</p>
<ul><li><p><tt>&lt;B></tt>: Bold</p></li>
<li><p><tt>&lt;I></tt>: Italics</p></li>
<li><p><tt>&lt;U></tt>: Underline</p></li>
<li><p><tt>&lt;DEF></tt>: Definition</p></li>
<li><p><tt>&lt;LINK></tt>: Link to a URL </p></li></ul>

<hr><p><b>Note - </b>An inline tag does not generate a line break, so a style
change caused by an inline tag does not affect the flow of text
on the page (although it will affect the appearance of that text). A
structure tag, on the other hand, demarcates a new segment of text, so
at a minimum it always generates a line break in addition to other
format changes.</p>
<hr>
<p>The <tt>&lt;DEF></tt> tag will be used for terms that are defined in the
text. Such terms will be displayed in italics, the way they ordinarily are
in a document. But using a special tag in the XML will
allow an index program to find such definitions and add them to an
index, along with keywords in headings. In the preceding Note, for example, the
definitions of inline tags and structure tags could have been marked with <tt>&lt;DEF></tt>
tags for future indexing.</p><p>Finally, the <tt>LINK</tt> tag serves two purposes. First, it will let us create
a link to a URL without having to put the URL in
twice; so we can code <tt>&lt;link>http//...&lt;/link></tt> instead of <tt>&lt;a href="http//...">http//...&lt;/a></tt>. Of course, we will
also want to allow a form that looks like <tt>&lt;link target="...">...name...&lt;/link></tt>. That leads to
the second reason for the <tt>&lt;link></tt> tag. It will give us an opportunity
to play with conditional expressions in XSLT.</p>
<hr><p><b>Note - </b>Although the article structure is exceedingly simple (consisting of only eleven tags), it
raises enough interesting problems to give us a good view of XSLT's basic
capabilities. But we will still leave large areas of the specification untouched. In
<a href="#ggyut">What Else Can XSLT Do?</a>, we will point out the major features we skipped.</p>
<hr>


<a name="gghmv"></a><h2>Creating a Test Document</h2>
<p>Here, you will create a simple test document using nested <tt>&lt;SECT></tt> elements,
a few &lt;PARA> elements, a <tt>&lt;NOTE></tt> element, a <tt>&lt;LINK></tt>, and a <tt>&lt;LIST type="unordered"></tt>.
The idea is to create a document with one of everything so that
we can explore the more interesting translation mechanisms.</p>
<hr><p><b>Note - </b>The code discussed in this section is in <tt>article1.xml</tt>, which is found in
the <tt>xslt/data</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</p>
<hr>
<p>To make the test document, create a file called <tt>article.xml</tt> and enter the
following XML data.</p>
<div class="codeblock"><pre>
&lt;?xml version="1.0"?>
&lt;ARTICLE>
   &lt;TITLE>A Sample Article&lt;/TITLE>
   &lt;SECT>The First Major Section
      &lt;PARA>This section will introduce a subsection.&lt;/PARA>
      &lt;SECT>The Subsection Heading
         &lt;PARA>This is the text of the subsection.
         &lt;/PARA>
      &lt;/SECT>
   &lt;/SECT>
&lt;/ARTICLE>
</pre></div>
<p>Note that in the XML file, the subsection is totally contained within the
major section. (In HTML, on the other hand, headings do not contain
the body of a section). The result is an outline structure that is
harder to edit in plain text form, like this, but is much easier
to edit with an outline-oriented editor.</p><p>Someday, given a tree-oriented XML editor that understands inline tags such as <tt>&lt;B></tt>
and <tt>&lt;I></tt>, it should be possible to edit an article of this kind
in outline form, without requiring a complicated stylesheet. (Such an editor would allow
the writer to focus on the structure of the article, leaving layout until
much later in the process). In such an editor, the article fragment would
look something like this:</p>
<div class="codeblock"><pre>
&lt;ARTICLE> 
   &lt;TITLE>A Sample Article 
   &lt;SECT>The First Major Section 
      &lt;PARA>This section will introduce a subsection.
      &lt;SECT>The Subheading 
         &lt;PARA>This is the text of the subsection. Note that ...
</pre></div>
<hr><p><b>Note - </b>At the moment, tree-structured editors exist, but they treat inline tags such as
<tt>&lt;B></tt> and <tt>&lt;I></tt> in the same way that they treat structure tags, and
that can make the "outline" a bit difficult to read.</p>
<hr>


<a name="gghnb"></a><h2>Writing an XSLT Transform</h2>
<p>Now it is time to begin writing an XSLT transform that will
convert the XML article and render it in HTML.</p>
<hr><p><b>Note - </b>The code discussed in this section is in <tt>article1a.xsl</tt>, which is found in
the <tt>xslt/data</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</p>
<hr>
<p>Start by creating a normal XML document:</p>
<div class="codeblock"><pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>
</pre></div>
<p>Then add the following highlighted lines to create an XSL stylesheet:</p>
<div class="codeblock"><pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>
<b>&lt;xsl:stylesheet </b>
<b> xmlns:xsl="http://www.w3.org/1999/XSL/Transform" </b>
<b> version="1.0"</b>
<b> ></b>
<b></b>
<b>&lt;/xsl:stylesheet></b>
</pre></div>
<p>Now set it up to produce HTML-compatible output.</p>
<div class="codeblock"><pre>
&lt;xsl:stylesheet 
   [...]

   >
   <b>&lt;xsl:output method="html"/></b>

   [...]

&lt;/xsl:stylesheet>
</pre></div>
<p>We will get into the detailed reasons for that entry later in
this section. For now, note that if you want to output anything other
than well-formed XML, then you will need an <tt>&lt;xsl:output></tt> tag like the one shown,
specifying either <tt>text</tt> or <tt>html</tt>. (The default value is <tt>xml</tt>).</p>
<hr><p><b>Note - </b>When you specify XML output, you can add the indent attribute to produce
nicely indented XML output. The specification looks like this:   <tt>&lt;xsl:output method="xml" indent="yes"/></tt>.</p>
<hr>


<a name="ggyvc"></a><h2>Processing the Basic Structure Elements</h2>
<p>You will start filling in the stylesheet by processing the elements that go
into creating a table of contents: the root element, the title element, and
headings. You will also process the <tt>PARA</tt> element defined in the test document.
</p>
<hr><p><b>Note - </b>If on first reading you skipped the section that discusses the XPath addressing
mechanisms, 
<a class="TutorialLink" target="_top" href="xpath.html">How XPath Works</a>, now is a good time to go back and review that
section.</p>
<hr>
<p>Begin by adding the main instruction that processes the root element:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="/"></b>
      &lt;html>&lt;body>
         <b>&lt;xsl:apply-templates/></b>
      &lt;/body>&lt;/html>
   <b>&lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>The new XSL commands are shown in bold. (Note that they are
defined in the <tt>xsl</tt> namespace). The instruction <tt>&lt;xsl:apply-templates></tt> processes the children of the
current node. In this case, the current node is the root node.</p><p>Despite its simplicity, this example illustrates a number of important ideas, so it
is worth understanding thoroughly. The first concept is that a stylesheet contains a
number of templates, defined with the <tt>&lt;xsl:template></tt> tag. Each template contains a
match attribute, which uses the XPath addressing mechanisms described in
<a class="TutorialLink" target="_top" href="xpath.html">How XPath Works</a> to select the
elements that the template will be applied to. </p><p>Within the template, tags that do not start with the <tt>xsl: namespace</tt> prefix
are simply copied. The newlines and whitespace that follow them are also copied,
and that helps to make the resulting output readable.</p>
<hr><p><b>Note - </b>When a newline is not present, whitespace is generally ignored. To include whitespace
in the output in such cases, or to include other text, you can
use the <tt>&lt;xsl:text></tt> tag. Basically, an XSLT stylesheet expects to process tags. So
everything it sees needs to be either an <tt>&lt;xsl:..></tt> tag, some other
tag, or whitespace.</p>
<hr>
<p>In this case, the non-XSL tags are HTML tags. So when the
root tag is matched, XSLT outputs the HTML start tags, processes any templates
that apply to children of the root, and then outputs the HTML end
tags.</p>

<a name="ggyxi"></a><h2>Process the <tt>&lt;TITLE></tt> Element</h2>
<p>Next, add a template to process the article title: </p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="/ARTICLE/TITLE"></b>
<b> &lt;h1 align="center"> &lt;xsl:apply-templates/> &lt;/h1></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>In this case, you specify a complete path to the TITLE element
and output some HTML to make the text of the title into a
large, centered heading. In this case, the <tt>apply-templates</tt> tag ensures that if the title
contains any inline tags such as italics, links, or underlining, they also will
be processed.</p><p>More importantly, the <tt>apply-templates</tt> instruction causes the text of the title to be
processed. Like the DOM data model, the XSLT data model is based on
the concept of text nodes contained in element nodes (which, in turn, can
be contained in other element nodes, and so on). That hierarchical structure constitutes
the source tree. There is also a result tree, which contains the output.
</p><p>XSLT works by transforming the source tree into the result tree. To visualize
the result of XSLT operations, it is helpful to understand the structure of
those trees, and their contents. (For more on this subject, see
<a class="TutorialLink" target="_top" href="xpath.html#gchlm">XSLT/XPath Data Model</a>).</p>

<a name="ggyuk"></a><h2>Process Headings</h2>
<p>To continue processing the basic structure elements, add a template to process the
top-level headings:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="/ARTICLE/SECT"></b>
<b> &lt;h2> &lt;xsl:apply-templates</b>
<b> select="text()|B|I|U|DEF|LINK"/> &lt;/h2></b>
<b> &lt;xsl:apply-templates select="SECT|PARA|LIST|NOTE"/></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>Here, you specify the path to the topmost <tt>SECT</tt> elements. But this time,
you apply templates in two stages using the <tt>select</tt> attribute. For the first
stage, you select text nodes, as well as inline tags such as bold
and italics, using the XPath <tt>text()</tt> function. (The vertical pipe (<tt>|</tt>) is used
to match multiple items: text or a bold tag or an italics tag,
etc). In the second stage, you select the other structure elements contained in
the file, for sections, paragraphs, lists, and notes.</p><p>Using the select attribute lets you put the text and inline elements between
the <tt>&lt;h2>...&lt;/h2></tt> tags, while making sure that all the structure tags in the
section are processed afterward. In other words, you make sure that the nesting
of the headings in the XML document is not reflected in the HTML
formatting, a distinction that is important for HTML output.</p><p>In general, using the select clause lets you apply all templates to a
subset of the information available in the current context. As another example, this
template selects all attributes of the current node:</p>
<div class="codeblock"><pre>
&lt;xsl:apply-templates select="@*"/>&lt;/attributes>
</pre></div>
<p>Next, add the virtually identical template to process subheadings that are nested one
level deeper:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="/ARTICLE/SECT/SECT"></b>
<b> &lt;h3> &lt;xsl:apply-templates</b>
<b> select="text()|B|I|U|DEF|LINK"/> &lt;/h3></b>
<b> &lt;xsl:apply-templates select="SECT|PARA|LIST|NOTE"/></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>

<a name="ggyuo"></a><h2>Generate a Runtime Message</h2>
<p>You could add templates for deeper headings, too, but at some point you
must stop, if only because HTML goes down only to five levels.
For this example, you will stop at two levels of section headings. But
if the XML input happens to contain a third level, you will want
to deliver an error message to the user. This section shows you how
to do that.</p>
<hr><p><b>Note - </b>We could continue processing <tt>SECT</tt> elements that are further down, by selecting them
with the expression <tt>/SECT/SECT//SECT</tt>. The <tt>//</tt> selects any <tt>SECT</tt> elements, at any depth,
as defined by the XPath addressing mechanism. But instead we will take the
opportunity to play with messaging.</p>
<hr>
<p>Add the following template to generate an error when a section is
encountered that is nested too deep:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="/ARTICLE/SECT/SECT/SECT"></b>
<b> &lt;xsl:message terminate="yes"></b>
<b> Error: Sections can only be nested 2 deep.</b>
<b> &lt;/xsl:message></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>The <tt>terminate="yes"</tt> clause causes the transformation process to stop after the message is
generated. Without it, processing could still go on, with everything in that section
being ignored.</p><p>As an additional exercise, you could expand the stylesheet to handle sections nested
up to four sections deep, generating <tt>&lt;h2>...&lt;h5></tt> tags. Generate an error on any
section nested five levels deep.</p><p>Finally, finish the stylesheet by adding a template to process the <tt>PARA</tt>
tag:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="PARA"></b>
<b> &lt;p>&lt;xsl:apply-templates/>&lt;/p></b>
<b> &lt;/xsl:template></b>
&lt;/xsl:stylesheet>
</pre></div>

<a name="ggyvn"></a><h2>Writing the Basic Program</h2>
<p>Now you will modify the program that uses XSLT to echo an
XML file unchanged, changing it so that it uses your stylesheet.</p>
<hr><p><b>Note - </b>The code discussed in this section is in <tt>Stylizer.java</tt>, which is found in
the <tt>xslt</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory. The result
is <tt>stylizer1a.html</tt>, found in <tt>xslt/data</tt>.</p>
<hr>
<p>The <tt>Stylizer</tt> example is adapted from <tt>TransformationApp02</tt>, which parses an XML file
and writes to <tt>System.out</tt>. The main differences between the two programs are described
below.</p><p>Firstly, <tt>Stylizer</tt> uses the stylesheet when creating the <tt>Transformer</tt> object.</p>
<div class="codeblock"><pre>
...
import javax.xml.transform.dom.DOMSource; 
<b>import javax.xml.transform.stream.StreamSource;</b> 
import javax.xml.transform.stream.StreamResult; 
... 
public class Stylizer 
{
  ...
  public static void main (String argv[])
  {
    ...
    try {
      <b>File stylesheet = new File(argv[0]);</b>
<b> File datafile = new File(argv[1]);</b>

      DocumentBuilder builder =
        factory.newDocumentBuilder();
      document = builder.parse(<b>datafile</b>);
      ...
      <b>StreamSource stylesource = </b>
<b> new StreamSource(stylesheet); </b>
      Transformer transformer =
        Factory.newTransformer(<b>stylesource</b>);
</pre></div>
<p>This code uses the file to create a <tt>StreamSource</tt> object and then passes
the source object to the factory class to get the transformer. </p>
<hr><p><b>Note - </b>You can simplify the code somewhat by eliminating the <tt>DOMSource</tt> class. Instead
of creating a <tt>DOMSource</tt> object for the XML file, create a <tt>StreamSource</tt> object
for it, as well as for the stylesheet.</p>
<hr>


<a name="ghbeu"></a><h3>Running the <tt>Stylizer</tt> Sample</h3>
<ol>
<li><b>Navigate to the <tt>samples</tt> directory.</b>
<div class="codeblock"><pre>
% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.
</pre></div>
</li>
<li><b> <a href="../examples/xslt_samples.zip">Download the XSLT examples by clicking this link</a> and unzip them into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</b></li>
<li><b>Navigate to the <tt>xslt</tt> directory.</b>
<div class="codeblock"><pre>
cd xslt
</pre></div>
</li>
<li><b>Compile the <tt>Stylizer</tt> sample.</b><p>Type the following command:</p>
<div class="codeblock"><pre>
% javac Stylizer.java
</pre></div>
</li>
<li><b>Run the <tt>Stylizer</tt> sample on <tt>article1.xml</tt> using the stylesheet <tt>article1a.xsl</tt>.</b>
<div class="codeblock"><pre>
% java Stylizer data/article1a.xsl  data/article1.xml
</pre></div>
<p>You will see the following output:</p>
<div class="codeblock"><pre>
&lt;html>
&lt;body>

&lt;h1 align="center">A Sample Article&lt;/h1>
&lt;h2>The First Major Section

   &lt;/h2>
&lt;p>This section will introduce a subsection.&lt;/p>
&lt;h3>The Subsection Heading

      &lt;/h3>
&lt;p>This is the text of the subsection.

         &lt;/p>

&lt;/body>
&lt;/html>
</pre></div>
<p>At this point, there is quite a bit of excess whitespace in
the output. In the next section, you will see how to eliminate most
of it.</p></li></ol>

<a name="ggyxa"></a><h2>Trimming the Whitespace</h2>
<p>Recall that when you look at the structure of a DOM, there
are many text nodes that contain nothing but ignorable whitespace. Most of the
excess whitespace in the output comes from these nodes. Fortunately, XSL gives you a
way to eliminate them. (For more about the node structure, see
<a class="TutorialLink" target="_top" href="xpath.html#gchlm">XSLT/XPath Data Model</a>).</p>
<hr><p><b>Note - </b>The stylesheet discussed in this section is in <tt>article1b.xsl</tt>, which is found
in the <tt>xslt/data</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory. The result
is <tt>stylizer1b.html</tt>, found in <tt>xslt/data</tt>.</p>
<hr>
<p>To remove some of the excess whitespace, add the following highlighted line to
the stylesheet.</p>
<div class="codeblock"><pre>
&lt;xsl:stylesheet ...
   >
   &lt;xsl:output method="html"/> 
   <b>&lt;xsl:strip-space elements="SECT"/></b>

[...]
</pre></div>
<p>This instruction tells XSL to remove any text nodes under <tt>SECT</tt> elements that
contain nothing but whitespace. Nodes that contain text other than whitespace will not
be affected, nor will other kinds of nodes.</p>

<a name="ghbaw"></a><h3>Running the <tt>Stylizer</tt> Sample with Trimmed Whitespace</h3>
<ol>
<li><b>Navigate to the <tt>samples</tt> directory.</b>
<div class="codeblock"><pre>
% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.
</pre></div>
</li>
<li><b> <a href="../examples/xslt_samples.zip">Download the XSLT examples by clicking this link</a> and unzip them into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</b></li>
<li><b>Navigate to the <tt>xslt</tt> directory.</b>
<div class="codeblock"><pre>
cd xslt
</pre></div>
</li>
<li><b>Compile the <tt>Stylizer</tt> sample.</b><p>Type the following command:</p>
<div class="codeblock"><pre>
% javac Stylizer.java
</pre></div>
</li>
<li><b>Run the <tt>Stylizer</tt> sample on <tt>article1.xml</tt> using the stylesheet <tt>article1b.xsl</tt>.</b>
<div class="codeblock"><pre>
% java Stylizer data/article1b.xsl  data/article1.xml
</pre></div>
<p>You will see the following output:</p>
<div class="codeblock"><pre>
&lt;html>
&lt;body>

&lt;h1 align="center">A Sample Article&lt;/h1>

&lt;h2>The First Major Section
   &lt;/h2>
&lt;p>This section will introduce a subsection.&lt;/p>
&lt;h3>The Subsection Heading
      &lt;/h3>
&lt;p>This is the text of the subsection.
      &lt;/p>

&lt;/body>
&lt;/html>
</pre></div>
<p>That is quite an improvement. There are still newline characters and whitespace after
the headings, but those come from the way the XML is written:</p>
<div class="codeblock"><pre>
&lt;SECT>The First Major Section
____&lt;PARA>This section will introduce a subsection.&lt;/PARA>
^^^^
</pre></div>
<p>Here, you can see that the section heading ends with a newline
and indentation space, before the PARA entry starts. That is not a big
worry, because the browsers that will process the HTML compress and ignore the
excess space routinely. But there is still one more formatting tool at our
disposal.</p></li></ol>

<a name="ghbbz"></a><h2>Removing the Last Whitespace</h2>

<hr><p><b>Note - </b>The stylesheet discussed in this section is in <tt>article1c.xsl</tt>, which is found
in the <tt>xslt/data</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory. The result
is <tt>stylizer1c.html</tt>, found in <tt>xslt/data</tt>.</p>
<hr>
<p>That last little bit of whitespace is disposed of by adding the
following to the stylesheet: </p>
<div class="codeblock"><pre>
   <b>&lt;xsl:template match="text()"></b>
<b> &lt;xsl:value-of select="normalize-space()"/></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>Running <tt>Stylizer</tt> with this stylesheet will remove all remaining whitespace.</p>

<a name="ghbah"></a><h3>Running the <tt>Stylizer</tt> Sample with All Whitespace Trimmed</h3>
<ol>
<li><b>Navigate to the <tt>samples</tt> directory.</b>
<div class="codeblock"><pre>
% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.
</pre></div>
</li>
<li><b> <a href="../examples/xslt_samples.zip">Download the XSLT examples by clicking this link</a> and unzip them into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</b></li>
<li><b>Navigate to the <tt>xslt</tt> directory.</b>
<div class="codeblock"><pre>
cd xslt
</pre></div>
</li>
<li><b>Compile the <tt>Stylizer</tt> sample.</b><p>Type the following command:</p>
<div class="codeblock"><pre>
% javac Stylizer.java
</pre></div>
</li>
<li><b>Run the <tt>Stylizer</tt> sample on <tt>article1.xml</tt> using the stylesheet <tt>article1c.xsl</tt>.</b>
<div class="codeblock"><pre>
% java Stylizer data/article1c.xsl  data/article1.xml
</pre></div>
<p>The output now looks like this:</p>
<div class="codeblock"><pre>
&lt;html>
&lt;body>
&lt;h1 align="center">A Sample Article&lt;/h1>
&lt;h2>The First Major Section&lt;/h2>
&lt;p>This section will introduce a subsection.&lt;/p>
&lt;h3>The Subsection Heading&lt;/h3>
&lt;p>This is the text of the subsection.&lt;/p>
&lt;/body>
&lt;/html>
</pre></div>
<p>That is quite a bit better. Of course, it would be nicer
if it were indented, but that turns out to be somewhat harder than
expected. Here are some possible avenues of attack, along with the difficulties:</p><dl><dt>Indent option</dt>
<dd><p>Unfortunately, the <tt>indent="yes"</tt> option that can be applied to XML output is not available for HTML output. Even if that option were available, it would not help, because HTML elements are rarely nested! Although HTML source is frequently indented to show the implied structure, the HTML tags themselves are not nested in a way that creates a real structure.</p></dd>
<dt>Indent variables</dt>
<dd><p>The <tt>&lt;xsl:text></tt> function lets you add any text you want, including whitespace. So it could conceivably be used to output indentation space. The problem is to vary the amount of indentation space. XSLT variables seem like a good idea, but they do not work here. The reason is that when you assign a value to a variable in a template, the value is known only within that template (statically, at compile time). Even if the variable is defined globally, the assigned value is not stored in a way that lets it be dynamically known by other templates at runtime. When <tt>&lt;apply-templates/></tt> invokes other templates, those templates are unaware of any variable settings made elsewhere.</p></dd>
<dt>Parameterized templates</dt>
<dd><p>Using a parameterized template is another way to modify a template's behavior. But determining the amount of indentation space to pass as the parameter remains the crux of the problem.</p></dd>
</dl>
<p>At the moment, then, there does not appear to be any good
way to control the indentation of HTML formatted output. That would be inconvenient
if you needed to display or edit the HTML as plain text. But
it is not a problem if you do your editing on the XML
form, using the HTML version only for display in a browser. (When you
view <tt>stylizer1c.html</tt>, for example, you see the results you expect).</p></li></ol>

<a name="ghbam"></a><h2>Processing the Remaining Structure Elements</h2>
<p>In this section, you will process the <tt>LIST</tt> and <tt>NOTE</tt> elements, which
add more structure to an article. </p>
<hr><p><b>Note - </b>The sample document described in this section is <tt>article2.xml</tt>, and the stylesheet
used to manipulate it is <tt>article2.xsl</tt>. The result is <tt>stylizer2.html</tt>.  These files
are found in the <tt>xslt/data</tt> directory after you unzip <a href="../examples/xslt_samples.zip">XSLT examples</a> into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.
</p>
<hr>
<p>Start by adding some test data to the sample document:</p>
<div class="codeblock"><pre>
&lt;?xml version="1.0"?>
&lt;ARTICLE>
  &lt;TITLE>A Sample Article&lt;/TITLE>
  &lt;SECT>The First Major Section
    ...
  &lt;/SECT>
  &lt;SECT>The Second Major Section
    &lt;PARA>This section adds a LIST and a NOTE.
    &lt;PARA>Here is the LIST:
      &lt;LIST type="ordered">
        &lt;ITEM>Pears&lt;/ITEM>
        &lt;ITEM>Grapes&lt;/ITEM>
      &lt;/LIST>
    &lt;/PARA>
    &lt;PARA>And here is the NOTE:
      &lt;NOTE>Don't forget to go to the hardware store 
        on your way to the grocery!
      &lt;/NOTE>
    &lt;/PARA>
  &lt;/SECT> 
&lt;/ARTICLE>
</pre></div>
<hr><p><b>Note - </b>Although the <tt>list</tt> and <tt>note</tt> in the XML file are contained in their
respective paragraphs, it really makes no difference whether they are contained or not;
the generated HTML will be the same either way. But having them contained
will make them easier to deal with in an outline-oriented editor. </p>
<hr>


<a name="ggywf"></a><h2>Modify <tt>&lt;PARA></tt> Handling</h2>
<p>Next, modify the <tt>PARA</tt> template to account for the fact that we are
now allowing some of the structure elements to be embedded with a paragraph:</p>
<div class="codeblock"><pre>
&lt;xsl:template match="PARA">
   <b>&lt;p> &lt;xsl:apply-templates select="text()|B|I|U|DEF|LINK"/></b>
<b> &lt;/p></b>
<b> &lt;xsl:apply-templates select="PARA|LIST|NOTE"/></b>
&lt;/xsl:template>
</pre></div>
<p>This modification uses the same technique you used for section headings. The only
difference is that <tt>SECT</tt> elements are not expected within a paragraph. (However, a
paragraph could easily exist inside another paragraph-for example, as quoted material).</p>

<a name="ggyua"></a><h2>Process <tt>&lt;LIST></tt> and <tt>&lt;ITEM></tt> Elements</h2>
<p>Now you're ready to add a template to process <tt>LIST</tt> elements:</p>
<div class="codeblock"><pre>
   &lt;xsl:template match="LIST">
      &lt;xsl:if test="@type='ordered'"> 
         &lt;ol>
         &lt;xsl:apply-templates/>
         &lt;/ol>
      &lt;/xsl:if>
      &lt;xsl:if test="@type='unordered'">
         &lt;ul>
         &lt;xsl:apply-templates/>
         &lt;/ul>
      &lt;/xsl:if>
   &lt;/xsl:template>

&lt;/xsl:stylesheet>
</pre></div>
<p>The <tt>&lt;xsl:if></tt> tag uses the <tt>test=""</tt> attribute to specify a Boolean condition. In
this case, the value of the type attribute is tested, and the list
that is generated changes depending on whether the value is ordered or unordered.</p><p>Note two important things in this example:</p>
<ul><li><p>There is no else clause, nor is there a return or exit statement, so it takes two <tt>&lt;xsl:if></tt> tags to cover the two options. (Or the <tt>&lt;xsl:choose></tt> tag could have been used, which provides case-statement functionality). </p></li>
<li><p>Single quotes are required around the attribute values. Otherwise, the XSLT processor attempts to interpret the word ordered as an XPath function instead of as a string.</p></li></ul>
<p>Now finish LIST processing by handling ITEM elements:</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="ITEM"></b>
<b> &lt;li>&lt;xsl:apply-templates/></b>
<b> &lt;/li></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>

<a name="ggyvs"></a><h2>Ordering Templates in a Stylesheet</h2>
<p>By now, you should have the idea that templates are independent of
one another, so it does not generally matter where they occur in a
file. So from this point on, we will show only the template you
need to add. (For the sake of comparison, they're always added at the
end of the example stylesheet).</p><p>Order does make a difference when two templates can apply to the
same node. In that case, the one that is defined last is the
one that is found and processed. For example, to change the ordering of
an indented list to use lowercase alphabetics, you could specify a template pattern
that looks like this: <tt>//LIST//LIST</tt>. In that template, you would use the HTML option
to generate an alphabetic enumeration, instead of a numeric one.</p><p>But such an element could also be identified by the pattern <tt>//LIST</tt>.
To make sure that the proper processing is done, the template that specifies
<tt>//LIST</tt> would have to appear before the template that specifies <tt>//LIST//LIST</tt>.</p>

<a name="ggywm"></a><h2>Process <tt>&lt;NOTE></tt> Elements</h2>
<p>The last remaining structure element is the <tt>NOTE</tt> element. Add the following template
to handle that.</p>
<div class="codeblock"><pre>
<b> &lt;xsl:template match="NOTE"></b>
<b> &lt;blockquote>&lt;b>Note:&lt;/b>&lt;br/></b>
<b> &lt;xsl:apply-templates/></b>
<b> &lt;/p>&lt;/blockquote></b>
<b> &lt;/xsl:template></b>

&lt;/xsl:stylesheet>
</pre></div>
<p>This code brings up an interesting issue that results from the inclusion of
the <tt>&lt;br/></tt> tag. For the file to be well-formed XML, the tag must
be specified in the stylesheet as <tt>&lt;br/></tt>, but that tag is not recognized
by many browsers. And although most browsers recognize the sequence <tt>&lt;br>&lt;/br></tt>, they all
treat it like a paragraph break instead of a single line break.</p><p>In other words, the transformation must generate a <tt>&lt;br></tt> tag, but the stylesheet
must specify <tt>&lt;br/></tt>. That brings us to the major reason for that special
output tag we added early in the stylesheet:</p>
<div class="codeblock"><pre>
&lt;xsl:stylesheet ... >
   <b>&lt;xsl:output method="html"/></b>
   [...]
&lt;/xsl:stylesheet>
</pre></div>
<p>That output specification converts empty tags such as <tt>&lt;br/></tt> to their HTML form,
<tt>&lt;br></tt>, on output. That conversion is important, because most browsers do not recognize
the empty tags. Here is a list of the affected tags:</p>
<div class="codeblock"><pre>
area      frame   isindex
base      hr      link
basefont  img     meta
br        input   param
col
</pre></div>
<p>To summarize, by default XSLT produces well-formed XML on output. And because an
XSL stylesheet is well-formed XML to start with, you cannot easily put a
tag such as <tt>&lt;br></tt> in the middle of it. The <tt>&lt;xsl:output method="html"/></tt> tag
solves the problem so that you can code <tt>&lt;br/></tt> in the stylesheet
but get <tt>&lt;br></tt> in the output.</p><p>The other major reason for specifying <tt>&lt;xsl:output method="html"/></tt> is that, as with the
specification <tt>&lt;xsl:output method="text"/></tt>, generated text is not escaped. For example, if the stylesheet includes
the <tt>&lt;</tt> entity reference, it will appear as the <tt>&lt;</tt> character in
the generated text. When XML is generated, on the other hand, the <tt>&lt;</tt>
entity reference in the stylesheet would be unchanged, so it would appear as
<tt>&lt;</tt> in the generated text.</p>
<hr><p><b>Note - </b>If you actually want <tt>&lt;</tt> to be generated as part of the HTML
output, you will need to encode it as <tt>&amp;lt;</tt>. That sequence becomes <tt>&lt;</tt>
on output, because only the <tt>&amp;</tt> is converted to an <tt>&amp;</tt> character.</p>
<hr>


<a name="ghbeb"></a><h3>Running the <tt>Stylizer</tt> Sample With <tt>LIST</tt> and <tt>NOTE</tt> Elements Defined</h3>
<ol>
<li><b>Navigate to the <tt>samples</tt> directory.</b>
<div class="codeblock"><pre>
% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.
</pre></div>
</li>
<li><b> <a href="../examples/xslt_samples.zip">Download the XSLT examples by clicking this link</a> and unzip them into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</b></li>
<li><b>Navigate to the <tt>xslt</tt> directory.</b>
<div class="codeblock"><pre>
cd xslt
</pre></div>
</li>
<li><b>Compile the <tt>Stylizer</tt> sample.</b><p>Type the following command:</p>
<div class="codeblock"><pre>
% javac Stylizer.java
</pre></div></li>
<li><b>Run the <tt>Stylizer</tt> sample on <tt>article2.xml</tt> using the stylesheet <tt>article2.xsl</tt>.</b>
<div class="codeblock"><pre>
% java Stylizer data/article2.xsl  data/article2.xml
</pre></div>
<p>Here is the HTML that is generated for the second section when
you run the program now:</p>
<div class="codeblock"><pre>
...
&lt;h2>The Second Major Section&lt;/h2>
&lt;p>This section adds a LIST and a NOTE.&lt;/p>
&lt;p>Here is the LIST:&lt;/p>
&lt;ol>
&lt;li>Pears&lt;/li>
&lt;li>Grapes&lt;/li>
&lt;/ol>
&lt;p>And here is the NOTE:&lt;/p>
&lt;blockquote>
&lt;b>Note:&lt;/b>
&lt;br>Do not forget to go to the hardware store on your way to the grocery!
&lt;/blockquote>
</pre></div>
</li></ol>

<a name="ggywl"></a><h2>Process Inline (Content) Elements</h2>
<p>The only remaining tags in the <tt>ARTICLE</tt> type are the inline tags-the ones
that do not create a line break in the output, but instead are
integrated into the stream of text they are part of.</p><p>Inline elements are different from structure elements in that inline elements are part
of the content of a tag. If you think of an element
as a node in a document tree, then each node has both content
and structure. The content is composed of the text and inline tags it
contains. The structure consists of the other elements (structure elements) under the tag.</p>
<hr><p><b>Note - </b>The sample document described in this section is <tt>article3.xml</tt>, and the stylesheet
used to manipulate it is <tt>article3.xsl</tt>. The result is <tt>stylizer3.html</tt>.</p>
<hr>
<p>Start by adding one more bit of test data to the sample
document:</p>
<div class="codeblock"><pre>
&lt;?xml version="1.0"?>
&lt;ARTICLE>
   &lt;TITLE>A Sample Article&lt;/TITLE>
   &lt;SECT>The First Major Section
      [...]
   &lt;/SECT>
   &lt;SECT>The Second Major Section
      [...]
   &lt;/SECT> 
   <b>&lt;SECT>The &lt;I>Third&lt;/I> Major Section</b>
<b> &lt;PARA>In addition to the inline tag in the heading, </b>
<b> this section defines the term &lt;DEF>inline&lt;/DEF>,</b>
<b> which literally means "no line break". It also </b>
<b> adds a simple link to the main page for the Java</b>
<b> platform (&lt;LINK>http://java.sun.com&lt;/LINK>), </b>
<b> as well as a link to the </b>
<b> &lt;LINK target="http://java.sun.com/xml">XML&lt;/LINK></b>
<b> page.</b>
<b> &lt;/PARA></b>
<b> &lt;/SECT></b> 
&lt;/ARTICLE>
</pre></div>
<p>Now process the inline <tt>&lt;DEF></tt> elements in paragraphs, renaming them to HTML italics
tags:</p>
<div class="codeblock"><pre>
<b>&lt;xsl:template match="DEF"></b>
<b> &lt;i> &lt;xsl:apply-templates/> &lt;/i> </b>
<b>&lt;/xsl:template></b>
</pre></div>
<p>Next, comment out the text-node normalization. It has served its purpose, and now
you are to the point that you need to preserve important spaces:</p>
<div class="codeblock"><pre>
<b>&lt;!--</b>   &lt;xsl:template match="text()">
      &lt;xsl:value-of select="normalize-space()"/>
   &lt;/xsl:template>
<b>--></b>
</pre></div>
<p>This modification keeps us from losing spaces before tags such as <tt>&lt;I></tt>
and <tt>&lt;DEF></tt>. (Try the program without this modification to see the result).</p><p>Now process basic inline HTML elements such as <tt>&lt;B></tt>, <tt>&lt;I></tt>, and <tt>&lt;U></tt>
for bold, italics, and underlining.</p>
<div class="codeblock"><pre>
<b>&lt;xsl:template match="B|I|U"></b>
<b> &lt;xsl:element name="{name()}"></b>
<b> &lt;xsl:apply-templates/></b>
<b> &lt;/xsl:element> </b>
<b>&lt;/xsl:template></b>
</pre></div>
<p>The <tt>&lt;xsl:element></tt> tag lets you compute the element you want to generate. Here,
you generate the appropriate inline tag using the name of the current element.
In particular, note the use of curly braces (<tt>{}</tt>) in the <tt>name=".."</tt> expression.
Those curly braces cause the text inside the quotes to be processed as
an XPath expression instead of being interpreted as a literal string. Here, they
cause the XPath <tt>name()</tt> function to return the name of the current node.</p><p>Curly braces are recognized anywhere that an attribute value template can occur. (Attribute
value templates are defined in section 7.6.2 of the XSLT specification, and they
appear several places in the template definitions). In such expressions, curly braces can
also be used to refer to the value of an attribute, <tt>{@foo}</tt>, or
to the content of an element <tt>{foo}</tt>.</p>
<hr><p><b>Note - </b>You can also generate attributes using <tt>&lt;xsl:attribute></tt>. For more information, see section 7.1.3
of the XSLT Specification.</p>
<hr>
<p>The last remaining element is the <tt>LINK</tt> tag. The easiest way to process
that tag will be to set up a named template that we
can drive with a parameter:</p>
<div class="codeblock"><pre>
<b>&lt;xsl:template name="htmLink"></b>
<b> &lt;xsl:param name="dest" select="UNDEFINED"/> </b>
<b> &lt;xsl:element name="a"></b>
<b> &lt;xsl:attribute name="href"></b>
<b> &lt;xsl:value-of select=""/></b>
<b> &lt;/xsl:attribute></b>
<b> &lt;xsl:apply-templates/> </b>
<b> &lt;/xsl:element> </b>
<b>&lt;/xsl:template></b>
</pre></div>
<p>The major difference in this template is that, instead of specifying a match
clause, you give the template a name using the <tt>name=""</tt> clause. So this
template gets executed only when you invoke it.</p><p>Within the template, you also specify a parameter named <tt>dest</tt> using the <tt>&lt;xsl:param></tt>
tag. For a bit of error checking, you use the select clause to
give that parameter a default value of <tt>UNDEFINED</tt>. To reference the variable
in the <tt>&lt;xsl:value-of></tt> tag, you specify <tt></tt>.</p>
<hr><p><b>Note - </b>Recall that an entry in quotes is interpreted as an expression unless it
is further enclosed in single quotes. That is why the single quotes were
needed earlier in <tt>"@type='ordered'"</tt> to make sure that ordered was interpreted as a
string.</p>
<hr>
<p>The <tt>&lt;xsl:element></tt> tag generates an element. Previously, you have been able to simply
specify the element we want by coding something like <tt>&lt;html></tt>. But here you
are dynamically generating the content of the HTML anchor (<tt>&lt;a></tt>) in the body
of the <tt>&lt;xsl:element></tt> tag. And you are dynamically generating the <tt>href</tt> attribute of the
anchor using the <tt>&lt;xsl:attribute></tt> tag.</p><p>The last important part of the template is the <tt>&lt;apply-templates></tt> tag, which
inserts the text from the text node under the <tt>LINK</tt> element. Without
it, there would be no text in the generated HTML link.</p><p>Next, add the template for the <tt>LINK</tt> tag, and call the named template
from within it: </p>
<div class="codeblock"><pre>
<b>&lt;xsl:template match="LINK"></b>
<b> &lt;xsl:if test="@target"></b>
<b> &lt;!--Target attribute specified.--></b>
<b> &lt;xsl:call-template name="htmLink"></b>
<b> &lt;xsl:with-param name="dest" select="@target"/> </b>
<b> &lt;/xsl:call-template></b>
<b> &lt;/xsl:if></b>
<b>&lt;/xsl:template></b>
&lt;xsl:template name="htmLink">

[...]
</pre></div>
<p>The <tt>test="@target"</tt> clause returns true if the target attribute exists in the LINK
tag. So this <tt>&lt;xsl-if></tt> tag generates HTML links when the text of the
link and the target defined for it are different.</p><p>The <tt>&lt;xsl:call-template></tt> tag invokes the named template, whereas <tt>&lt;xsl:with-param></tt> specifies a parameter using the
name clause and specifies its value using the select clause.</p><p>As the very last step in the stylesheet construction process, add the
<tt>&lt;xsl-if></tt> tag to process <tt>LINK</tt> tags that do not have a target attribute.</p>
<div class="codeblock"><pre>
&lt;xsl:template match="LINK">
   &lt;xsl:if test="@target">
      [...]
   &lt;/xsl:if>

   <b>&lt;xsl:if test="not(@target)"></b>
<b> &lt;xsl:call-template name="htmLink"></b>
<b> &lt;xsl:with-param name="dest"></b>
<b> &lt;xsl:apply-templates/></b>
<b> &lt;/xsl:with-param></b>
<b> &lt;/xsl:call-template></b>
<b> &lt;/xsl:if></b>
&lt;/xsl:template>
</pre></div>
<p>The <tt>not(...)</tt> clause inverts the previous test (remember, there is no else clause).
So this part of the template is interpreted when the target attribute is
not specified. This time, the parameter value comes not from a select clause,
but from the contents of the <tt>&lt;xsl:with-param></tt> element.</p>
<hr><p><b>Note - </b>Just to make it explicit: Parameters and variables (which are discussed in a
few moments in <a href="#ggyut">What Else Can XSLT Do?</a> can have their value specified either by a select
clause, which lets you use XPath expressions, or by the content of the
element, which lets you use XSLT tags.</p>
<hr>
<p>In this case, the content of the parameter is generated by the
<tt>&lt;xsl:apply-templates/></tt> tag, which inserts the contents of the text node under the
<tt>LINK</tt> element.</p>

<a name="ghbdo"></a><h3>Running the <tt>Stylizer</tt> Sample With Inline Elements Defined</h3>
<ol>
<li><b>Navigate to the <tt>samples</tt> directory.</b>
<div class="codeblock"><pre>
% cd <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt>.
</pre></div>
</li>
<li><b> <a href="../examples/xslt_samples.zip">Download the XSLT examples by clicking this link</a> and unzip them into the <i>install-dir</i><tt>/jaxp-1_4_2-</tt><i>release-date</i><tt>/samples</tt> directory.</b></li>
<li><b>Navigate to the <tt>xslt</tt> directory.</b><
<div class="codeblock"><pre>
cd xslt
</pre></div>
</li>
<li><b>Compile the <tt>Stylizer</tt> sample.</b><p>Type the following command:</p>
<div class="codeblock"><pre>
% javac Stylizer.java
</pre></div>
</li>
<li><b>Run the <tt>Stylizer</tt> sample on <tt>article3.xml</tt> using the stylesheet <tt>article3.xsl</tt>.</b>
<div class="codeblock"><pre>
% java Stylizer data/article3.xsl  data/article3.xml
</pre></div>
<p>When you run the program now, the results should look something like this:</p>
<div class="codeblock"><pre>
[...]
&lt;h2>The &lt;I>Third&lt;/I> Major Section
      &lt;/h2>
&lt;p>In addition to the inline tag in the heading, this section
      defines the term &lt;i>inline&lt;/i>, which literally means
      "no line break". It also adds a simple link to the
      main page for the Java platform (&lt;a href="http://java.
      sun.com">http://java.sun.com&lt;/a>), 
      as well as a link to the 
      &lt;a href="http://java.sun.com/xml">XML&lt;/a> page.
   &lt;/p>
</pre></div>
<p>Good work! You have now converted a rather complex XML file to
HTML. (As simple as it appears at first, it certainly provides a lot
of opportunity for exploration).</p></li></ol>

<a name="ggywy"></a><h2>Printing the HTML</h2>
<p>You have now converted an XML file to HTML. One day, someone
will produce an HTML-aware printing engine that you will be able to find
and use through the Java Printing Service API. At that point, you will
have ability to print an arbitrary XML file by generating HTML. All you
will have to do is to set up a stylesheet and use your
browser. </p>

<a name="ggyut"></a><h2>What Else Can XSLT Do?</h2>
<p>As lengthy as this section has been, it has only scratched the
surface of XSLT's capabilities. Many additional possibilities await you in the XSLT specification. Here
are a few things to look for:</p><dl><dt><tt>import</tt> (Section 2.6.2) and <tt>include</tt> (section 2.6.1)</dt>
<dd><p><tt>rt</tt> (Section 2.6.2) and include (section 2.6.1) Use these statements to modularize and combine XSLT stylesheets. The include statement simply inserts any definitions from the included file. The import statement lets you override definitions in the imported file with definitions in your own stylesheet.</p></dd>
<dt><tt>for-each</tt> loops (section 8)</dt>
<dd><p>Loop over a collection of items and process each one in turn.</p></dd>
<dt><tt>choose</tt> (case statement) for conditional processing (section 9.2)</dt>
<dd><p>Branch to one of multiple processing paths depending on an input value.</p></dd>
<dt>Generating numbers (section 7.7)</dt>
<dd><p>Dynamically generate numbered sections, numbered elements, and numeric literals. XSLT provides three numbering modes:</p>
<ul><li><p>Single: Numbers items under a single heading, like an ordered list in HTML</p></li>
<li><p>Multiple: Produces multilevel numbering such as "A.1.3"</p></li>
<li><p>Any: Consecutively numbers items wherever they appear, as with footnotes in a lesson.</p></li></ul>
</dd>
<dt>Formatting numbers (section 12.3)</dt>
<dd><p>Control enumeration formatting so that you get numerics (<tt>format="1"</tt>), uppercase alphabetics (<tt>format="A"</tt>), lowercase alphabetics (<tt>format="a"</tt>), or compound numbers, like "A.1," as well as numbers and currency amounts suited for a specific international locale.</p></dd>
<dt>Sorting output (section 10)</dt>
<dd><p>Produce output in a desired sorting order.</p></dd>
<dt>Mode-based templates (section 5.7)</dt>
<dd><p>Process an element multiple times, each time in a different "mode." You add a mode attribute to templates and then specify <tt>&lt;apply-templates mode="..."></tt> to apply only the templates with a matching mode. Combine with the <tt>&lt;apply-templates select="..."></tt> attribute to apply mode-based processing to a subset of the input data.</p></dd>
<dt>Variables (section 11)</dt>
<dd><p>Variables are something like method parameters, in that they let you control a template's behavior. But they are not as valuable as you might think. The value of a variable is known only within the scope of the current template or <tt>&lt;xsl:if></tt> tag (for example) in which it is defined. You cannot pass a value from one template to another, or even from an enclosed part of a template to another part of the same template.</p><p>These statements are true even for a "global" variable. You can change its value in a template, but the change applies only to that template. And when the expression used to define the global variable is evaluated, that evaluation takes place in the context of the structure's root node. In other words, global variables are essentially runtime constants. Those constants can be useful for changing the behavior of a template, especially when coupled with include and import statements. But variables are not a general-purpose data-management mechanism.</p></dd>
</dl>


<a name="ggyuy"></a><h2>The Trouble with Variables</h2>
<p>It is tempting to create a single template and set a variable
for the destination of the link, rather than go to the trouble of
setting up a parameterized template and calling it two different ways. The idea
is to set the variable to a default value (say, the text of
the <tt>LINK</tt> tag) and then, if the target attribute exists, set the destination
variable to the value of the target attribute. </p><p>That would be a good idea-if it worked. But again, the issue
is that variables are known only in the scope within which they are
defined. So when you code an <tt>&lt;xsl:if></tt> tag to change the value of
the variable, the value is known only within the context of the <tt>&lt;xsl:if></tt>
tag. Once <tt>&lt;/xsl:if></tt> is encountered, any change to the variable's setting is lost.</p><p>A similarly tempting idea is the possibility of replacing the <tt>text()|B|I|U|DEF|LINK</tt> specification
with a variable (<tt></tt>). But because the value of the variable is determined
by where it is defined, the value of a global inline variable consists
of text nodes, <tt>&lt;B></tt> nodes, and so on, that happen to exist at
the root level. In other words, the value of such a variable, in
this case, is null.</p>
        </div>
        <div class=NavBit>
            <a target=_top href=generatingXML.html>&laquo; Previous</a>
            &bull;
            <a target=_top href=../TOC.html>Trail</a>
            &bull;
            <a target=_top href=../stax/index.html>Next &raquo;</a>
        </div>
    </div>
    <div id=Footer2>
<hr>
<div id=TagNotes>
    <p class="footertext">Problems with the examples? Try <a target="_blank"
        href=../../information/run-examples.html>Compiling and Running
        the Examples: FAQs</a>.
    <br>
    Complaints? Compliments? Suggestions? <a target="_blank"
        href="http://download.oracle.com/javase/feedback.html">Give
    us your feedback</a>.
    </p>
</div> 

<div id=Footer>
<p class="footertext"><a name="license_info">Your use of this</a> page and all the material on pages under &quot;The Java Tutorials&quot; banner,
and all the material on pages under &quot;The Java Tutorials&quot; banner is subject to the <a href="../../information/license.html">Java SE Tutorial Copyright
and License</a>.
Additionally, any example code contained in any of these Java
Tutorials pages is licensed under the
<a href="http://developers.sun.com/license/berkeley_license.html">Code
Sample License</a>.
</p>
<table border="0" cellspacing="0" cellpadding="5" summary="">
    <tr>
         <td headers="h1" width="20%">
	 <table width="100%" border="0" cellspacing="0" cellpadding="5">
            <tr>
              <td headers="h1" align="center"><img id=duke src=../../images/DukeWave.gif width=55 height=55 alt="duke image"></td>
              <td headers="h2" align="left" valign="middle"><img id=oracle src=../../images/logo_oracle_footer.gif width=100 height=29 alt="Oracle logo"></td>
           </tr>
          </table>
          </td>

          <td width="55%" valign="middle" align="center">
		<p class="footertext"><a href="http://www.oracle.com/us/corporate/index.html">About Oracle</a> | <a href="http://www.oracle.com/technology/index.html">Oracle Technology Network</a> | <a href="https://www.samplecode.oracle.com/servlets/CompulsoryClickThrough?type=TermsOfService">Terms of Service</a></p> 
	 </td>
          <td width="25%" valign="middle" align="right">
      		<p class="footertext">Copyright &copy; 1995, 2011 Oracle and/or its affiliates. All rights reserved.</p>
	 </td>
     </tr>     
</table>
</div>
    </div>
    <div class=PrintHeaders>
        <b>Previous page:</b> Generating XML from an Arbitrary Data Structure
        <br><b>Next page:</b> Streaming API for XML
    </div>

<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
<noscript> 
A browser with JavaScript enabled is required for this page to operate properly.
</noscript>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>

 
<!-- End SiteCatalyst code -->

</body>
</html> 
