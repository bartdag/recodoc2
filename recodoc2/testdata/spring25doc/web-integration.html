<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;15.&nbsp;Integrating with other web frameworks</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><!--Begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-2728886-3");
            pageTracker._setDomainName("none");
            pageTracker._setAllowLinker(true);
            pageTracker._trackPageview();
        </script><!--End Google Analytics code--><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="spring-web.html" title="Part&nbsp;III.&nbsp;The Web"><link rel="previous" href="view.html" title="Chapter&nbsp;14.&nbsp;View technologies"><link rel="next" href="portlet.html" title="Chapter&nbsp;16.&nbsp;Portlet MVC Framework"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/springsource-banner-rhs.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="web-integration"></a>Chapter&nbsp;15.&nbsp;Integrating with other web frameworks</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>15.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
      This chapter details Spring's integration with third party web frameworks
      such as <a href="http://java.sun.com/javaee/javaserverfaces/" target="_top">JSF</a>,
      <a href="http://struts.apache.org/" target="_top">Struts</a>,
      <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork</a>, and
      <a href="http://tapestry.apache.org/" target="_top">Tapestry</a>.
    </p><div class="sidebar"><p class="title"><b>Spring Web Flow</b></p><p>Spring Web Flow (SWF) aims to be the best solution for the management
  of web application page flow.</p><p>SWF integrates with existing frameworks like Spring MVC, Struts, and
  JSF, in both servlet and portlet environments. If you have a business
  process (or processes) that would benefit from a conversational model as
  opposed to a purely request model, then SWF may be the solution.</p><p>SWF allows you to capture logical page flows as self-contained modules
  that are reusable in different situations, and as such is ideal for building
  web application modules that guide the user through controlled navigations
  that drive business processes.</p><p>For more information about SWF, consult the
  <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>.
  </p></div><p>
      One of the core value propositions of the Spring Framework is that of
      enabling <span class="emphasis"><em>choice</em></span>. In a general sense, Spring does not
      force one to use or buy into any particular architecture, technology, or
      methodology (although it certainly recommends some over others). This freedom
      to pick and choose the architecture, technology, or methodology that is most
      relevant to a developer and his or her development team is arguably most evident
      in the web area, where Spring provides its own web framework
      (<a href="mvc.html" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Spring MVC</a>), while at the same time providing integration
      with a number of popular third party web frameworks. This allows one to continue
      to leverage any and all of the skills one may have acquired in a
      particular web framework such as Struts, while at the same time being able to
      enjoy the benefits afforded by Spring in other areas such as data access,
      declarative transaction management, and flexible configuration and application
      assembly.
    </p><p>
      Having dispensed with the woolly sales patter (c.f. the previous paragraph),
      the remainder of this chapter will concentrate upon the meaty details of
      integrating your favourite web framework with Spring. One thing that is often
      commented upon by developers coming to Java from other languages is the seeming
      super-abundance of web frameworks available in Java... there are indeed a great
      number of web frameworks in the Java space; in fact there are far too many to
      cover with any semblance of detail in a single chapter. This chapter thus picks
      four of the more popular web frameworks in Java, starting with the Spring
      configuration that is common to all of the supported web frameworks, and then
      detailing the specific integration options for each supported web framework.
    </p><p>
      <span class="emphasis"><em>
        Please note that this chapter does not attempt to explain how to use any
        of the supported web frameworks. For example, if you want to use Struts for
        the presentation layer of your web application, the assumption is that you
        are already familiar with Struts. If you need further details about any of
        the supported web frameworks themselves, please do consult the section
        entitled <a href="web-integration.html#web-integration-resources" title="15.7.&nbsp;Further Resources">Section&nbsp;15.7, &#8220;Further Resources&#8221;</a> at the end of this chapter.
      </em></span>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-integration-common"></a>15.2.&nbsp;Common configuration</h2></div></div><div></div></div><p>
      Before diving into the integration specifics of each supported web framework, let
      us first take a look at the Spring configuration that <span class="emphasis"><em>not</em></span>
      specific to any one web framework. (This section is equally applicable to Spring's
      own web framework, Spring MVC.)
    </p><p>
      One of the concepts (for want of a better word) espoused by (Spring's) lightweight
      application model is that of a layered architecture. Remember that in a 'classic'
      layered architecture, the web layer is but one of many layers... it serves as one
      of the entry points into a server side application, and it delegates to service
      objects (facades) defined in a service layer to satisfy business specific (and
      presentation-technology agnostic) use cases. In Spring, these service objects,
      any other business-specific objects, data access objects, etc. exist in a
      distinct 'business context', which contains <span class="emphasis"><em>no</em></span> web or
      presentation layer objects (presentation objects such as Spring MVC controllers
      are typically configured in a distinct 'presentation context'). This section
      details how one configures a Spring container (a
      <tt class="classname">WebApplicationContext</tt>) that contains all of the
      'business beans' in one's application.
    </p><p>
      Onto specifics... all that one need do is to declare a
      <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/ContextLoaderListener.html" target="_top"><tt class="classname">ContextLoaderListener</tt></a>
      in the standard J2EE servlet <tt class="literal">web.xml</tt> file of one's web application,
      and add a <tt class="literal">contextConfigLocation</tt> &lt;context-param/&gt; section
      (in the same file) that defines which set of Spring XML cpnfiguration files to load.
    </p><p>
      Find below the &lt;listener/&gt; configuration:
    </p><pre class="programlisting">&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        Listeners were added to the Servlet API in version 2.3; listener startup order was
        finally clarified in Servlet 2.4. If you have a Servlet 2.3 container, you can use the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/ContextLoaderServlet.html" target="_top"><tt class="classname">ContextLoaderServlet</tt></a>
        to achieve the same functionality in a 100% portable fashion (with respect to startup order).
      </p></td></tr></table></div><p>
      Find below the &lt;context-param/&gt; configuration:
    </p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
      If you don't specify the <tt class="literal">contextConfigLocation</tt>
      context parameter, the <tt class="classname">ContextLoaderListener</tt> will look
      for a file called <tt class="literal">/WEB-INF/applicationContext.xml</tt> to load.
      Once the context files are loaded, Spring creates a
      <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/WebApplicationContext.html" target="_top"><tt class="classname">WebApplicationContext</tt></a>
      object based on the bean definitions and stores it in the
      <span class="interface">ServletContext</span> of one's web application.
    </p><p>
      All Java web frameworks are built on top of the Servlet API, and so one can
      use the following code snippet to get access to this 'business context'
      <span class="interface">ApplicationContext</span> created by the
      <tt class="classname">ContextLoaderListener</tt>.
    </p><pre class="programlisting">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</pre><p>
      The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/support/WebApplicationContextUtils.html" target="_top"><tt class="classname">WebApplicationContextUtils</tt></a>
      class is for convenience, so you don't have to remember the name of the
      <span class="interface">ServletContext</span> attribute. Its <span class="emphasis"><em>getWebApplicationContext()</em></span>
      method will return <tt class="literal">null</tt> if an object doesn't exist under the
      <tt class="literal">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt> key. Rather
      than risk getting <tt class="classname">NullPointerExceptions</tt> in your application, it's
      better to use the <tt class="literal">getRequiredWebApplicationContext()</tt> method. This
      method throws an exception when the <span class="interface">ApplicationContext</span> is missing.
    </p><p>
      Once you have a reference to the <tt class="classname">WebApplicationContext</tt>,
      you can retrieve beans by their name or type. Most developers retrieve beans
      by name, then cast them to one of their implemented interfaces.
    </p><p>
      Fortunately, most of the frameworks in this section have simpler ways of looking up
      beans. Not only do they make it easy to get beans from a Spring container, but they
      also allow you to use dependency injection on their controllers. Each web framework
      section has more detail on its specific integration strategies.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jsf"></a>15.3.&nbsp;JavaServer Faces 1.1 and 1.2</h2></div></div><div></div></div><p>
      JavaServer Faces (JSF) is the JCP's standard component-based, event-driven
      web user interface framework. As of Java EE 5, it is an official part of
      the Java EE umbrella.
    </p><p>
      For a popular JSF runtime as well as for popular JSF component libraries, check
      out the <a href="http://myfaces.apache.org/" target="_top">Apache MyFaces project</a>.
      The MyFaces project also provides common JSF extensions such as
      <a href="http://myfaces.apache.org/orchestra/" target="_top">MyFaces Orchestra</a>:
      a Spring-based JSF extension that provides rich conversation scope support.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        Spring Web Flow 2.0 provides rich JSF support through its newly
        established Spring Faces module, both for JSF-centric usage
        (as described in this section) and for Spring-centric usage
        (using JSF views within a Spring MVC dispatcher). Check out the
        <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>
        for details!
      </p></td></tr></table></div><p>
      The key element in Spring's JSF integration is the JSF 1.1
      <tt class="classname">VariableResolver</tt> mechanism. On JSF 1.2,
      Spring supports the <tt class="classname">ELResolver</tt> mechanism
      as a next-generation version of JSF EL integration.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-delegatingvariableresolver"></a>15.3.1.&nbsp;DelegatingVariableResolver (JSF 1.1/1.2)</h3></div></div><div></div></div><p>
        The easiest way to integrate one's Spring middle-tier with one's
        JSF web layer is to use the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/jsf/DelegatingVariableResolver.html" target="_top">
        <tt class="classname">DelegatingVariableResolver</tt></a> class. To configure
        this variable resolver in one's application, one will need to edit one's
        <span class="emphasis"><em>faces-context.xml</em></span> file. After the opening
        <tt class="literal">&lt;faces-config/&gt;</tt> element, add an <tt class="literal">&lt;application/&gt;</tt>
        element and a <tt class="literal">&lt;variable-resolver/&gt;</tt> element within it.
        The value of the variable resolver should reference Spring's
        <tt class="classname">DelegatingVariableResolver</tt>; for example:</p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;
    &lt;locale-config&gt;
      &lt;default-locale&gt;en&lt;/default-locale&gt;
      &lt;supported-locale&gt;en&lt;/supported-locale&gt;
      &lt;supported-locale&gt;es&lt;/supported-locale&gt;
    &lt;/locale-config&gt;
    &lt;message-bundle&gt;messages&lt;/message-bundle&gt;
  &lt;/application&gt;
&lt;/faces-config&gt;</pre><p>
        The <tt class="classname">DelegatingVariableResolver</tt> will first delegate value
        lookups to the default resolver of the underlying JSF implementation, and
        then to Spring's 'business context' <tt class="classname">WebApplicationContext</tt>.
        This allows one to easily inject dependencies into one's JSF-managed beans.
      </p><p>
        Managed beans are defined in one's <tt class="literal">faces-config.xml</tt>
        file. Find below an example where <tt class="literal">#{userManager}</tt> is a bean
        that is retrieved from the Spring 'business context'.
      </p><pre class="programlisting">&lt;managed-bean&gt;
  &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;
  &lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;
  &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
  &lt;managed-property&gt;
    &lt;property-name&gt;userManager&lt;/property-name&gt;
    &lt;value&gt;#{userManager}&lt;/value&gt;
  &lt;/managed-property&gt;
&lt;/managed-bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-springbeanvariableresolver"></a>15.3.2.&nbsp;SpringBeanVariableResolver (JSF 1.1/1.2)</h3></div></div><div></div></div><p>
        <tt class="classname">SpringBeanVariableResolver</tt> is a variant of
        <tt class="classname">DelegatingVariableResolver</tt>. It delegates to the
        Spring's 'business context' <tt class="classname">WebApplicationContext</tt>
        <span class="emphasis"><em>first</em></span>, then to the default resolver of the
        underlying JSF implementation. This is useful in particular when
        using request/session-scoped beans with special Spring resolution rules,
        e.g. Spring <tt class="interfacename">FactoryBean</tt> implementations.
      </p><p>
        Configuration-wise, simply define <tt class="classname">SpringBeanVariableResolver</tt>
        in your <span class="emphasis"><em>faces-context.xml</em></span> file:
      </p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;variable-resolver&gt;org.springframework.web.jsf.SpringBeanVariableResolver&lt;/variable-resolver&gt;
    ...
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-springbeanfaceselresolver"></a>15.3.3.&nbsp;SpringBeanFacesELResolver (JSF 1.2+)</h3></div></div><div></div></div><p>
        <tt class="classname">SpringBeanFacesELResolver</tt> is a JSF 1.2 compliant
        <tt class="classname">ELResolver</tt> implementation, integrating with
        the standard Unified EL as used by JSF 1.2 and JSP 2.1. Like
        <tt class="classname">SpringBeanVariableResolver</tt>, it delegates to the
        Spring's 'business context' <tt class="classname">WebApplicationContext</tt>
        <span class="emphasis"><em>first</em></span>, then to the default resolver of the
        underlying JSF implementation.
      </p><p>
        Configuration-wise, simply define <tt class="classname">SpringBeanFacesELResolver</tt>
        in your JSF 1.2 <span class="emphasis"><em>faces-context.xml</em></span> file:
      </p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;/el-resolver&gt;
    ...
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-facescontextutils"></a>15.3.4.&nbsp;FacesContextUtils</h3></div></div><div></div></div><p>
        A custom <tt class="interfacename">VariableResolver</tt> works well when mapping
        one's properties to beans in <span class="emphasis"><em>faces-config.xml</em></span>, but at times
        one may need to grab a bean explicitly.  The
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/jsf/FacesContextUtils.html" target="_top">
        <tt class="classname">FacesContextUtils</tt></a> class makes this easy. It is
        similar to <tt class="classname">WebApplicationContextUtils</tt>, except that it
        takes a <tt class="classname">FacesContext</tt> parameter rather than a
        <span class="interface">ServletContext</span> parameter.
      </p><pre class="programlisting">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="struts"></a>15.4.&nbsp;Apache Struts 1.x and 2.x</h2></div></div><div></div></div><p>
      <a href="http://struts.apache.org" target="_top">Struts</a> is the
      <span class="emphasis"><em>de facto</em></span> web framework for Java applications, mainly
      because it was one of the first to be released (June 2001). Invented by
      Craig McClanahan, Struts is an open source project hosted by the Apache
      Software Foundation. At the time, it greatly simplified the JSP/Servlet
      programming paradigm and won over many developers who were using
      proprietary frameworks. It simplified the programming model, it was open
      source (and thus free as in beer), and it had a large community, which allowed
      the project to grow and become popular among Java web developers.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        <span class="emphasis"><em>The following section discusses Struts 1 a.k.a. "Struts Classic".</em></span>
      </p><p>
        Struts 2 is effectively a different product - a successor of
        WebWork 2.2 (as discussed in <a href="web-integration.html#webwork" title="15.5.&nbsp;WebWork 2.x">Section&nbsp;15.5, &#8220;WebWork 2.x&#8221;</a>),
        carrying the Struts brand now. Check out the Struts 2
        <a href="http://struts.apache.org/2.x/docs/spring-plugin.html" target="_top">Spring Plugin</a>
        for the built-in Spring integration shipped with Struts 2.
        In general, Struts 2 is closer to WebWork 2.2 than to Struts 1
        in terms of its Spring integration implications.
      </p></td></tr></table></div><p>
      To integrate your Struts 1.x application with Spring, you have two options:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          Configure Spring to manage your Actions as beans, using the
          <tt class="classname">ContextLoaderPlugin</tt>, and set their
          dependencies in a Spring context file.
        </p></li><li><p>
          Subclass Spring's <tt class="classname">ActionSupport</tt>
          classes and grab your Spring-managed beans explicitly using
          a <span class="emphasis"><em>getWebApplicationContext()</em></span> method.
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-contextloaderplugin"></a>15.4.1.&nbsp;ContextLoaderPlugin</h3></div></div><div></div></div><p>
        The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ContextLoaderPlugIn.html" target="_top"><tt class="classname">ContextLoaderPlugin</tt></a>
        is a Struts 1.1+ plug-in that loads a Spring context file for the Struts
        <tt class="classname">ActionServlet</tt>. This context refers to the root
        <tt class="classname">WebApplicationContext</tt> (loaded by the
        <tt class="classname">ContextLoaderListener</tt>) as its parent. The default
        name of the context file is the name of the mapped servlet, plus
        <span class="emphasis"><em>-servlet.xml</em></span>. If <tt class="classname">ActionServlet</tt>
        is defined in web.xml as
        <tt class="literal">&lt;servlet-name&gt;action&lt;/servlet-name&gt;</tt>, the
        default is <span class="emphasis"><em>/WEB-INF/action-servlet.xml</em></span>.
      </p><p>
        To configure this plug-in, add the following XML to the plug-ins section near
        the bottom of your <span class="emphasis"><em>struts-config.xml</em></span> file:
      </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/&gt;</pre><p>
        The location of the context configuration files can be customized using the
        '<tt class="literal">contextConfigLocation</tt>' property.
      </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt;
  &lt;set-property property="contextConfigLocation"
      value="/WEB-INF/action-servlet.xml,/WEB-INF/applicationContext.xml"/&gt;
&lt;/plug-in&gt;</pre><p>
        It is possible to use this plugin to load all your context files, which can be
        useful when using testing tools like StrutsTestCase. StrutsTestCase's
        <tt class="classname">MockStrutsTestCase</tt> won't initialize Listeners on startup
        so putting all your context files in the plugin is a workaround. (A
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562" target="_top">
        bug has been filed</a> for this issue, but has been closed as 'Wont Fix').
      </p><p>
        After configuring this plug-in in <span class="emphasis"><em>struts-config.xml</em></span>, you can
        configure your <tt class="classname">Action</tt> to be managed by Spring. Spring (1.1.3+)
        provides two ways to do this:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Override Struts' default <tt class="classname">RequestProcessor</tt>
            with Spring's <tt class="classname">DelegatingRequestProcessor</tt>.
          </p></li><li><p>
            Use the <tt class="classname">DelegatingActionProxy</tt> class
            in the <tt class="literal">type</tt> attribute of your
            <tt class="literal">&lt;action-mapping&gt;</tt>.
          </p></li></ul></div><p>
        Both of these methods allow you to manage your Actions and
        their dependencies in the <span class="emphasis"><em>action-servlet.xml</em></span> file.
        The bridge between the Action in <span class="emphasis"><em>struts-config.xml</em></span>
        and <span class="emphasis"><em>action-servlet.xml</em></span> is built with the
        action-mapping's "path" and the bean's "name". If you have the
        following in your <span class="emphasis"><em>struts-config.xml</em></span> file:
      </p><pre class="programlisting">&lt;action path="/users" .../&gt;</pre><p>
        You must define that Action's bean with the "/users" name in
        <span class="emphasis"><em>action-servlet.xml</em></span>:
      </p><pre class="programlisting">&lt;bean name="/users" .../&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingrequestprocessor"></a>15.4.1.1.&nbsp;DelegatingRequestProcessor</h4></div></div><div></div></div><p>
          To configure the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingRequestProcessor.html" target="_top">
          <tt class="literal">DelegatingRequestProcessor</tt></a> in your
          <span class="emphasis"><em>struts-config.xml</em></span> file, override the "processorClass"
          property in the &lt;controller&gt; element. These lines follow the
          &lt;action-mapping&gt; element.
        </p><pre class="programlisting">&lt;controller&gt;
  &lt;set-property property="processorClass"
      value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt;
&lt;/controller&gt;</pre><p>
          After adding this setting, your Action will automatically be
          looked up in Spring's context file, no matter what the type. In fact,
          you don't even need to specify a type. Both of the following snippets
          will work:
        </p><pre class="programlisting">&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;
&lt;action path="/user"/&gt;</pre><p>
          If you're using Struts' <span class="emphasis"><em>modules</em></span> feature,
          your bean names must contain the module prefix. For example, an action
          defined as <tt class="literal">&lt;action path="/user"/&gt;</tt> with module
          prefix "admin" requires a bean name with
          <tt class="literal">&lt;bean name="/admin/user"/&gt;</tt>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
            If you are using Tiles in your Struts application, you must configure your
            &lt;controller&gt; with the
            <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html" target="_top"><tt class="classname">DelegatingTilesRequestProcessor</tt></a>
            instead.
          </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingactionproxy"></a>15.4.1.2.&nbsp;DelegatingActionProxy</h4></div></div><div></div></div><p>
          If you have a custom <tt class="classname">RequestProcessor</tt> and
          can't use the <tt class="classname">DelegatingRequestProcessor</tt> or
          <tt class="classname">DelegatingTilesRequestProcessor</tt> approaches, you can
          use the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingActionProxy.html" target="_top">
          <tt class="classname">DelegatingActionProxy</tt></a> as the type in your
          action-mapping.
        </p><pre class="programlisting">&lt;action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
    name="userForm" scope="request" validate="false" parameter="method"&gt;
  &lt;forward name="list" path="/userList.jsp"/&gt;
  &lt;forward name="edit" path="/userForm.jsp"/&gt;
&lt;/action&gt;</pre><p>
          The bean definition in <span class="emphasis"><em>action-servlet.xml</em></span>
          remains the same, whether you use a custom <tt class="literal">RequestProcessor</tt>
          or the <tt class="classname">DelegatingActionProxy</tt>.
        </p><p>
          If you define your <tt class="classname">Action</tt> in a context file, the
          full feature set of Spring's bean container will be available for it:
          dependency injection as well as the option to instantiate a new
          <tt class="classname">Action</tt> instance for each request. To activate the latter,
          add <span class="emphasis"><em>scope="prototype"</em></span> to your Action's bean definition.
        </p><pre class="programlisting">&lt;bean name="/user" scope="prototype" autowire="byName"
    class="org.example.web.UserAction"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-actionsupport"></a>15.4.2.&nbsp;ActionSupport Classes</h3></div></div><div></div></div><p>
        As previously mentioned, you can retrieve the
        <tt class="classname">WebApplicationContext</tt> from the <span class="interface">ServletContext</span>
        using the <tt class="classname">WebApplicationContextUtils</tt> class. An
        easier way is to extend  Spring's <tt class="classname">Action</tt> classes for
        Struts. For example, instead of subclassing Struts'
        <tt class="classname">Action</tt> class, you can subclass Spring's
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ActionSupport.html" target="_top">
        <tt class="classname">ActionSupport</tt></a> class.
      </p><p>
        The <tt class="classname">ActionSupport</tt> class provides additional
        convenience methods, like <span class="emphasis"><em>getWebApplicationContext()</em></span>.
        Below is an example of how you might use this in an Action:
      </p><pre class="programlisting">public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }
        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");
        // talk to manager for business logic
        return mapping.findForward("success");
    }
}</pre><p>
      Spring includes subclasses for all of the standard Struts Actions
      - the Spring versions merely have <span class="emphasis"><em>Support</em></span> appended to the name:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ActionSupport.html" target="_top"><tt class="classname">ActionSupport</tt></a>,</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DispatchActionSupport.html" target="_top"><tt class="literal">DispatchActionSupport</tt></a>,</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/LookupDispatchActionSupport.html" target="_top"><tt class="literal">LookupDispatchActionSupport</tt></a> and</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/MappingDispatchActionSupport.html" target="_top"><tt class="literal">MappingDispatchActionSupport</tt></a>.</p></li></ul></div><p>
    </p><p>
      The recommended strategy is to use the approach that best suits
      your project. Subclassing makes your code more readable, and you know
      exactly how your dependencies are resolved. However, using the
      <tt class="classname">ContextLoaderPlugin</tt> allow you to easily add new
      dependencies in your context XML file. Either way, Spring provides some
      nice options for integrating the two frameworks.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webwork"></a>15.5.&nbsp;WebWork 2.x</h2></div></div><div></div></div><p>
      From the <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork homepage</a>...
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        WebWork is a Java web-application development framework. It is built
        specifically with developer productivity and code simplicity in mind,
        providing robust support for building reusable UI templates, such as form
        controls, UI themes, internationalization, dynamic form parameter mapping
        to JavaBeans, robust client and server side validation, and much more.
      </em></span>
    </span>&#8221;<p>
      WebWork is (in the opinion of this author) a very clean, elegant web framework.
      Its architecture and key concepts are not only very easy to understand, it has
      a rich tag library, nicely decoupled validation, and it is (again, in the opinion
      of this author) quite easy to be productive in next to no time at all (the
      documentation and tutorials are pretty good too).
    </p><p>
      One of the key enablers in WebWork's technology stack is
      <a href="http://www.opensymphony.com/webwork/wikidocs/IoC%20Overview.html" target="_top">an IoC container</a>
      to manage Webwork Actions, handle the "wiring" of business objects, etc.
      Prior to WebWork version 2.2, WebWork used its own proprietary IoC container
      (and provided integration points so that one could integrate an IoC container
      such as Springs into the mix). However, as of WebWork version 2.2, the default
      IoC container that is used within WebWork <span class="emphasis"><em>is</em></span> Spring. This
      is obviously great news if one is a Spring developer, because it means that one
      is immediately familiar with the basics of IoC configuration, idioms and suchlike
      within WebWork.
    </p><p>
      Now in the interests of adhering to the DRY (Dont Repeat Yourself) principle, it
      would be foolish to writeup the Spring-WebWork integration in light of the fact that
      the WebWork team have already written such a writeup. Please do consult the
      <a href="http://www.opensymphony.com/webwork/wikidocs/Spring.html" target="_top">Spring-WebWork integration page</a>
      on the
      <a href="http://wiki.opensymphony.com/display/WW/WebWork" target="_top">WebWork wiki</a>
      for the full lowdown.
    </p><p>
      Note that the Spring-WebWork integration code was developed (and continues
      to be maintained and improved) by the WebWork developers themselves, so in the
      first instance please do refer to the WebWork site and forums if you are having
      issues with the integration. Do feel free to post comments and queries regarding
      the Spring-WebWork integration on the
      <a href="http://forum.springframework.org/forumdisplay.php?f=25" target="_top">Spring support forums</a>
      too.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tapestry"></a>15.6.&nbsp;Tapestry 3.x and 4.x</h2></div></div><div></div></div><p>
      From the <a href="http://tapestry.apache.org/" target="_top">Tapestry homepage</a>...
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        Tapestry is an open-source framework for creating dynamic, robust, highly
        scalable web applications in Java. Tapestry complements and builds upon
        the standard Java Servlet API, and so it works in any servlet container or
        application server.
      </em></span>
    </span>&#8221;<p>
      While Spring has its own <a href="mvc.html" title="Chapter&nbsp;13.&nbsp;Web MVC framework">powerful web layer</a>, there
      are a number of unique advantages to building a J2EE application using a
      combination of Tapestry for the web  user interface and the Spring container
      for the lower layers. This section of the web integration chapter attempts
      to detail a few best practices for combining these two frameworks.
    </p><p>
      A <span class="emphasis"><em>typical</em></span> layered J2EE application built with Tapestry
      and Spring will consist of a top user interface (UI) layer built with Tapestry,
      and a number of lower layers, all wired together by one or more Spring containers.
      Tapestry's own reference documentation contains the following snippet of best
      practice advice. (Text that the author of this Spring section has added is
      contained within <tt class="literal">[]</tt> brackets.)
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        A very succesful design pattern in Tapestry is to keep pages and components
        very simple, and <span class="bold"><b>delegate</b></span> as much logic as
        possible out to HiveMind [or Spring, or whatever] services. Listener methods
        should ideally do little more than marshall together the correct information
        and pass it over to a service.
      </em></span>
    </span>&#8221;<p>
      The key question then is... how does one supply Tapestry pages with collaborating
      services? The answer, ideally, is that one would want to dependency inject those
      services directly into one's Tapestry pages. In Tapestry, one can effect this
      dependency injection by a variety of means...
      This section is only going to enumerate the dependency injection means afforded
      by Spring. The real beauty of the rest of this Spring-Tapestry integration is that
      the elegant and flexible design of Tapestry itself makes doing this dependency
      injection of Spring-managed beans a cinch. (Another nice thing is that this
      Spring-Tapestry integration code was written - and continues to be maintained -
      by the Tapestry creator
      <a href="http://howardlewisship.com/blog/" target="_top">Howard M. Lewis Ship</a>,
      so hats off to him for what is really some silky smooth integration).
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tapestry-di"></a>15.6.1.&nbsp;Injecting Spring-managed beans</h3></div></div><div></div></div><p>
        Assume we have the following simple Spring container definition (in the
        ubiquitous XML format):
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" 
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;
 
&lt;beans&gt;
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName" value="java:DefaultDS"/&gt;
    &lt;/bean&gt;

    &lt;bean id="hibSessionFactory" 
          class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionManager" 
          class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

    &lt;bean id="mapper" 
          class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory" ref="hibSessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;!-- (transactional) AuthenticationService --&gt;
    &lt;bean id="authenticationService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="target"&gt;
            &lt;bean class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
                &lt;property name="mapper" ref="mapper"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="proxyInterfacesOnly" value="true"/&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;value&gt;
                *=PROPAGATION_REQUIRED
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- (transactional) UserService --&gt;
    &lt;bean id="userService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="target"&gt;
             &lt;bean class="com.whatever.services.service.user.UserServiceImpl"&gt;
                 &lt;property name="mapper" ref="mapper"/&gt;
             &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="proxyInterfacesOnly" value="true"/&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;value&gt;
                *=PROPAGATION_REQUIRED
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</pre><p>
        Inside the Tapestry application, the above bean definitions need to
        be <a href="web-integration.html#web-integration-common" title="15.2.&nbsp;Common configuration">loaded into a Spring container</a>,
        and any relevant Tapestry pages need to be supplied (injected) with the
        <tt class="literal">authenticationService</tt> and
        <tt class="literal">userService</tt> beans, which implement the
        <tt class="interfacename">AuthenticationService</tt> and
        <tt class="interfacename">UserService</tt> interfaces, respectively.
      </p><p>
        At this point, the application context is available to a web
        application by calling Spring's static utility function
        <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>,
        where servletContext is the standard <span class="interface">ServletContext</span>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the <tt class="interfacename">UserService</tt>,
        for example, would be with code such as:
      </p><pre class="programlisting">WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
    getRequestCycle().getRequestContext().getServlet().getServletContext());
UserService userService = (UserService) appContext.getBean("userService");
<i class="lineannotation"><span class="lineannotation">... some code which uses UserService</span></i></pre><p>
        This mechanism does work... having said that, it can be made a
        lot less verbose by encapsulating most of the functionality in a
        method in the base class for the page or component. However, in
        some respects it goes against the IoC principle; ideally you would like the page to
        not have to ask the context for a specific bean by name, and in
        fact, the page would ideally not know about the context at all.
      </p><p>
        Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
          This next section is applicable to Tapestry 3.x.
          If you are using Tapestry version 4.x, please consult the section
          entitled <a href="web-integration.html#tapestry-4-style-di" title="15.6.1.4.&nbsp;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style">Section&nbsp;15.6.1.4, &#8220;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style&#8221;</a>.
        </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-pre4-style-di"></a>15.6.1.1.&nbsp;Dependency Injecting Spring Beans into Tapestry pages</h4></div></div><div></div></div><p>
          First we need to make the <span class="interface">ApplicationContext</span>
          available to the Tapestry page or Component without having to have the
          <span class="interface">ServletContext</span>; this is because at the stage in the
          page's/component's lifecycle when we need to access the
          <span class="interface">ApplicationContext</span>, the
          <span class="interface">ServletContext</span> won't be easily available to the
          page, so we can't use
          <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>
          directly. One way is by defining a custom version of the Tapestry
          <tt class="interfacename">IEngine</tt> which exposes this for us:
        </p><pre class="programlisting">package com.whatever.web.xportal;

import ...

public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</pre><p>
          This engine class places the Spring Application Context as
          an attribute called "appContext" in this Tapestry app's 'Global'
          object. Make sure to register the fact that this special IEngine
          instance should be used for this Tapestry application, with an entry
          in the Tapestry application definition file. For example:
        </p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">file: xportal.application:</span></i>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-componentdefs"></a>15.6.1.2.&nbsp;Component definition files</h4></div></div><div></div></div><p>
          Now in our page or component definition file (*.page or *.jwc),
          we simply add property-specification elements to grab the beans we
          need out of the <tt class="interfacename">ApplicationContext</tt>,
          and create page or component properties for them. For example:
        </p><pre class="programlisting">    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</pre><p>
          The OGNL expression  inside the property-specification specifies the
          initial value for the property, as a bean obtained from the context.
          The entire page definition might look like this:
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-getters"></a>15.6.1.3.&nbsp;Adding abstract accessors</h4></div></div><div></div></div><p>
          Now in the Java class definition for the page or component
          itself, all we need to do is add an abstract getter method
          for the properties we have defined (in order to be able to
          access the properties).
        </p><pre class="programlisting">// our UserService implementation; will come from page definition
public abstract UserService getUserService();
// our AuthenticationService implementation; will come from page definition
public abstract AuthenticationService getAuthenticationService();</pre><p>
          For the sake of completeness, the entire Java class, for a
          login page in this example, might look like this:
        </p><pre class="programlisting">package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /** The name of the cookie that identifies a user **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
    public abstract AuthenticationService getAuthenticationService();
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     * &lt;p&gt;
     *  If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
        if (delegate.getHasErrors()) {
            return;
        }

        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise specified
        ICallback callback = getCallback();
 
        if (callback == null) {
            cycle.activate("Home");
        }
        else {
            callback.performCallback(cycle);
        }

        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
        cycle.getRequestContext().addCookie(cookie);
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null) {
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
        }
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-4-style-di"></a>15.6.1.4.&nbsp;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style</h4></div></div><div></div></div><p>
          Effecting the dependency injection of Spring-managed beans into Tapestry
          pages in Tapestry version 4.x is <span class="emphasis"><em>so</em></span> much simpler.
          All that is needed is a single
          <a href="http://howardlewisship.com/tapestry-javaforge/tapestry-spring/" target="_top">add-on library</a>,
          and some (small) amount of (essentially boilerplate) configuration.
          Simply package and deploy this library with the (any of the) other
          libraries required by your web application (typically in
          <tt class="literal">WEB-INF/lib</tt>).
        </p><p>
          You will then need to create and expose the Spring container using the
          <a href="web-integration.html#web-integration-common" title="15.2.&nbsp;Common configuration">method detailed previously</a>.
          You can then inject Spring-managed beans into Tapestry very easily; if
          we are using Java 5, consider the <tt class="classname">Login</tt> page from above:
          we simply need to annotate the appropriate getter methods
          in order to dependency inject the Spring-managed <tt class="literal">userService</tt>
          and <tt class="literal">authenticationService</tt> objects (lots of the class
          definition has been elided for clarity)...
        </p><pre class="programlisting">package com.whatever.web.xportal.pages;

public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
    
    @InjectObject("spring:userService")
    public abstract UserService getUserService();
    
    @InjectObject("spring:authenticationService")
    public abstract AuthenticationService getAuthenticationService();

}</pre><p>
        We are almost done... all that remains is the HiveMind configuration that exposes the
        Spring container stored in the <tt class="interfacename">ServletContext</tt> as a
        HiveMind service; for example:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;module id="com.javaforge.tapestry.spring" version="0.1.1"&gt;

    &lt;service-point id="SpringApplicationInitializer"
        interface="org.apache.tapestry.services.ApplicationInitializer"
        visibility="private"&gt;
        &lt;invoke-factory&gt;
            &lt;construct class="com.javaforge.tapestry.spring.SpringApplicationInitializer"&gt;
                &lt;set-object property="beanFactoryHolder"
                    value="service:hivemind.lib.DefaultSpringBeanFactoryHolder" /&gt;
            &lt;/construct&gt;
        &lt;/invoke-factory&gt;
    &lt;/service-point&gt;

    &lt;!-- Hook the Spring setup into the overall application initialization. --&gt;
    &lt;contribution
        configuration-id="tapestry.init.ApplicationInitializers"&gt;
        &lt;command id="spring-context"
            object="service:SpringApplicationInitializer" /&gt;
    &lt;/contribution&gt;

&lt;/module&gt;</pre><p>
          If you are using Java 5 (and thus have access to annotations), then
          that really is it.
        </p><p>
          If you are not using Java 5, then one obviously doesn't annotate one's
          Tapestry page classes with annotations; instead, one simply uses
          good old fashioned XML to declare the dependency injection; for example,
          inside the <tt class="literal">.page</tt> or <tt class="literal">.jwc</tt> file
          for the <tt class="classname">Login</tt> page (or component):
        </p><pre class="programlisting">&lt;inject property="userService" object="spring:userService"/&gt;
&lt;inject property="authenticationService" object="spring:authenticationService"/&gt;</pre></div></div><p>
      In this example, we've managed to allow service beans defined in
      a Spring container to be provided to the Tapestry page in a declarative
      fashion. The page class does not know where the service implementations
      are coming from, and in fact it is easy to slip in another implementation,
      for example, during testing. This inversion  of control is one of the
      prime goals and benefits of the Spring Framework, and we have managed
      to extend it all the way up the J2EE stack in this Tapestry application.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-integration-resources"></a>15.7.&nbsp;Further Resources</h2></div></div><div></div></div><p>
      Find below links to further resources about the various web frameworks
      described in this chapter.
    </p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://java.sun.com/javaee/javaserverfaces/" target="_top">JSF</a> homepage</p></li><li><p>The <a href="http://struts.apache.org/" target="_top">Struts</a> homepage</p></li><li><p>The <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork</a> homepage</p></li><li><p>The <a href="http://tapestry.apache.org/" target="_top">Tapestry</a> homepage</p></li></ul></div></div></div><!--Begin LoopFuse code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" src="http://loopfuse.net/webrecorder/js/listen.js" type="text/javascript"></script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            _lf_cid = "LF_48be82fa";
            _lf_remora();
        </script><!--End LoopFuse code--><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="view.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="portlet.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;14.&nbsp;View technologies&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;16.&nbsp;Portlet MVC Framework</td></tr></table></div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>


<!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script>
<script type="text/javascript">var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");pageTracker._setAllowLinker(true);
pageTracker._trackPageview();var OrgTracker = _gat._getTracker("UA-2728886-2");
OrgTracker._trackPageview();</script>
 <!-- End 2nd Google code -->



</body>
</html>