<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><!--Begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-2728886-3");
            pageTracker._setDomainName("none");
            pageTracker._setAllowLinker(true);
            pageTracker._trackPageview();
        </script><!--End Google Analytics code--><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="spring-middle-tier.html" title="Part&nbsp;II.&nbsp;Middle Tier Data Access"><link rel="previous" href="jdbc.html" title="Chapter&nbsp;11.&nbsp;Data access using JDBC"><link rel="next" href="spring-web.html" title="Part&nbsp;III.&nbsp;The Web"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/springsource-banner-rhs.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>12.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The Spring Framework provides integration with <span class="emphasis"><em>Hibernate,
    JDO, Oracle TopLink, iBATIS SQL Maps</em></span> and
    <span class="emphasis"><em>JPA</em></span>: in terms of resource management, DAO
    implementation support, and transaction strategies. For example for
    Hibernate, there is first-class support with lots of IoC convenience
    features, addressing many typical Hibernate integration issues. All of
    these support packages for O/R (Object Relational) mappers comply with
    Spring's generic transaction and DAO exception hierarchies. There are
    usually two integration styles: either using Spring's DAO 'templates' or
    coding DAOs against plain Hibernate/JDO/TopLink/etc APIs. In both cases,
    DAOs can be configured through Dependency Injection and participate in
    Spring's resource and transaction management.</p><p>Spring adds significant support when using the O/R mapping layer of
    your choice to create data access applications. First of all, you should
    know that once you started using Spring's support for O/R mapping, you
    don't have to go all the way. No matter to what extent, you're invited to
    review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside a Spring IoC container does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside a Spring container.</p><p>Some of the benefits of using the Spring Framework to create your
    ORM DAOs include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Ease of testing.</em></span> Spring's IoC approach
        makes it easy to swap the implementations and config locations of
        Hibernate <tt class="interfacename">SessionFactory</tt> instances,
        JDBC <tt class="interfacename">DataSource</tt> instances, transaction
        managers, and mappes object implementations (if needed). This makes it
        much easier to isolate and test each piece of persistence-related code
        in isolation.</p></li><li><p><span class="emphasis"><em>Common data access exceptions.</em></span> Spring can
        wrap exceptions from your O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate <tt class="interfacename">SessionFactory</tt> instances,
        JDBC <tt class="interfacename">DataSource</tt> instances, iBATIS SQL
        Maps configuration objects, and other related resources. This makes
        these values easy to manage and change. Spring offers efficient, easy
        and safe handling of persistence resources. For example: related code
        using Hibernate generally needs to use the same Hibernate
        <tt class="interfacename">Session</tt> for efficiency and proper
        transaction handling. Spring makes it easy to transparently create and
        bind a <tt class="interfacename">Session</tt> to the current thread,
        either by using an explicit 'template' wrapper class at the Java code
        level or by exposing a current <tt class="interfacename">Session</tt>
        through the Hibernate <tt class="interfacename">SessionFactory</tt>
        (for DAOs based on plain Hibernate API). Thus Spring solves many of
        the issues that repeatedly arise from typical Hibernate usage, for any
        transaction environment (local or JTA).</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected: for
        example, between local transactions and JTA, with the same full
        services (such as declarative transactions) available in both
        scenarios. As an additional benefit, JDBC-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping,
        such as batch processing or streaming of BLOBs, which still needs to
        share common transactions with ORM operations.</p></li></ul></div><p>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and JPA. PetClinic can therefore serve as
    working sample app that illustrates the use of Hibernate, TopLink and JPA
    in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p><p>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</p><p>Beyond the samples shipped with Spring, there are a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<a href="http://www.jpox.org/" target="_top">http://www.jpox.org/</a>) and Kodo (<a href="http://www.bea.com/kodo/" target="_top">http://www.bea.com/kodo/</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>12.2.&nbsp;Hibernate</h2></div></div><div></div></div><p>We will start with a coverage of <a href="http://www.hibernate.org/" target="_top">Hibernate 3</a> in a Spring
    environment, using it to demonstrate the approach that Spring takes
    towards integrating O/R mappers. This section will cover many issues in
    detail and show different variations of DAO implementations and
    transaction demarcation. Most of these patterns can be directly translated
    to all other supported ORM tools. The following sections in this chapter
    will then cover the other ORM technologies, showing briefer examples
    there.</p><p><span class="emphasis"><em>Note: As of Spring 2.5, Spring requires Hibernate 3.1 or
    higher. Neither Hibernate 2.1 nor Hibernate 3.0 are supported
    anymore.</em></span></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-resource-mngmnt"></a>12.2.1.&nbsp;Resource management</h3></div></div><div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling, namely IoC via templating; for
      example infrastructure classes with callback interfaces, or applying AOP
      interceptors. The infrastructure cares for proper resource handling, and
      for appropriate conversion of specific API exceptions to an unchecked
      infrastructure exception hierarchy. Spring introduces a DAO exception
      hierarchy, applicable to any data access strategy. For direct JDBC, the
      <tt class="classname">JdbcTemplate</tt> class mentioned in a previous
      section cares for connection handling, and for proper conversion of
      <tt class="classname">SQLException</tt> to the
      <tt class="classname">DataAccessException</tt> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</p><p>Spring also offers Hibernate and JDO support, consisting of a
      <tt class="classname">HibernateTemplate</tt> /
      <tt class="classname">JdoTemplate</tt> analogous to
      <tt class="classname">JdbcTemplate</tt>, a
      <tt class="classname">HibernateInterceptor</tt> /
      <tt class="classname">JdoInterceptor</tt>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring
      application, many important objects are JavaBeans: data access
      templates, data access objects (that use the templates), transaction
      managers, business services (that use the data access objects and
      transaction managers), web view resolvers, web controllers (that use the
      business services),and so on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-session-factory-setup"></a>12.2.2.&nbsp;<tt class="interfacename">SessionFactory</tt> setup in a Spring
      container</h3></div></div><div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources such as a JDBC
      <tt class="interfacename">DataSource</tt> or a Hibernate
      <tt class="interfacename">SessionFactory</tt> as beans in the Spring
      container. Application objects that need to access resources just
      receive references to such pre-defined instances via bean references
      (the DAO definition in the next section illustrates this). The following
      excerpt from an XML application context definition shows how to set up a
      JDBC <tt class="classname">DataSource</tt> and a Hibernate
      <tt class="interfacename">SessionFactory</tt> on top of it:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.HSQLDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that switching from a local Jakarta Commons DBCP
      <tt class="classname">BasicDataSource</tt> to a JNDI-located
      <tt class="interfacename">DataSource</tt> (usually managed by an
      application server) is just a matter of configuration:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>You can also access a JNDI-located
      <tt class="interfacename">SessionFactory</tt>, using Spring's
      <tt class="classname">JndiObjectFactoryBean</tt> to retrieve and expose it.
      However, that is typically not common outside of an EJB context.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-template"></a>12.2.3.&nbsp;The <tt class="classname">HibernateTemplate</tt></h3></div></div><div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <tt class="interfacename">SessionFactory</tt>. It can get the latter
      from anywhere, but preferably as bean reference from a Spring IoC
      container - via a simple <tt class="methodname">setSessionFactory(..)</tt>
      bean property setter. The following snippets show a DAO definition in a
      Spring container, referencing the above defined
      <tt class="interfacename">SessionFactory</tt>, and an example for a DAO
      method implementation.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private HibernateTemplate hibernateTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.hibernateTemplate = new HibernateTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(String category) throws DataAccessException {
    	return this.hibernateTemplate.find("from test.Product product where product.category=?", category);
    }
}</pre><p>The <tt class="classname">HibernateTemplate</tt> class provides many
      methods that mirror the methods exposed on the Hibernate
      <tt class="interfacename">Session</tt> interface, in addition to a
      number of convenience methods such as the one shown above. If you need
      access to the <tt class="interfacename">Session</tt> to invoke methods
      that are not exposed on the <tt class="classname">HibernateTemplate</tt>,
      you can always drop down to a callback-based approach like so.</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private HibernateTemplate hibernateTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.hibernateTemplate = new HibernateTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return this.hibernateTemplate.execute(new HibernateCallback() {

            public Object doInHibernate(Session session) {
                Criteria criteria = session.createCriteria(Product.class);
                criteria.add(Expression.eq("category", category));
                criteria.setMaxResults(6);
                return criteria.list();
            }
        };
    }
}</pre><p>A callback implementation effectively can be used for any
      Hibernate data access. <tt class="classname">HibernateTemplate</tt> will
      ensure that <tt class="interfacename">Session</tt> instances are
      properly opened and closed, and automatically participate in
      transactions. The template instances are thread-safe and reusable, they
      can thus be kept as instance variables of the surrounding class. For
      simple single step actions like a single find, load, saveOrUpdate, or
      delete call, <tt class="classname">HibernateTemplate</tt> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <tt class="classname">HibernateDaoSupport</tt> base class that provides a
      <tt class="methodname">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="methodname">getSessionFactory()</tt> and
      <tt class="methodname">getHibernateTemplate()</tt>for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return this.getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-daos"></a>12.2.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div><div></div></div><p>As alternative to using Spring's
      <tt class="classname">HibernateTemplate</tt> to implement DAOs, data access
      code can also be written in a more traditional fashion, without wrapping
      the Hibernate access code in a callback, while still respecting and
      participating in Spring's generic
      <tt class="classname">DataAccessException</tt> hierarchy. The
      <tt class="classname">HibernateDaoSupport</tt> base class offers methods to
      access the current transactional <tt class="interfacename">Session</tt>
      and to convert exceptions in such a scenario; similar methods are also
      available as static helpers on the
      <tt class="classname">SessionFactoryUtils</tt> class. Note that such code
      will usually pass '<tt class="literal">false</tt>' as the value of the
      <tt class="methodname">getSession(..)</tt> methods
      '<tt class="literal">allowCreate</tt>' argument, to enforce running within a
      transaction (which avoids the need to close the returned
      <tt class="interfacename">Session</tt>, as its lifecycle is managed by
      the transaction).</p><pre class="programlisting">public class HibernateProductDao extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException, MyException {
        Session session = getSession(false);
        try {
            Query query = session.createQuery("from test.Product product where product.category=?");
            query.setString(0, category);
            List result = query.list();
            if (result == null) {
                throw new MyException("No search results.");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</pre><p>The advantage of such direct Hibernate access code is that it
      allows <span class="emphasis"><em>any</em></span> checked application exception to be
      thrown within the data access code; contrast this to the
      <tt class="classname">HibernateTemplate</tt> class which is restricted to
      throwing only unchecked exceptions within the callback. Note that you
      can often defer the corresponding checks and the throwing of application
      exceptions to after the callback, which still allows working with
      <tt class="classname">HibernateTemplate</tt>. In general, the
      <tt class="classname">HibernateTemplate</tt> class' convenience methods are
      simpler and more convenient for many scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-straight"></a>12.2.5.&nbsp;Implementing DAOs based on plain Hibernate 3 API</h3></div></div><div></div></div><p>Hibernate 3 provides a feature called "contextual Sessions", where
      Hibernate itself manages one current
      <tt class="interfacename">Session</tt> per transaction. This is roughly
      equivalent to Spring's synchronization of one Hibernate
      <tt class="interfacename">Session</tt> per transaction. A corresponding
      DAO implementation looks like as follows, based on the plain Hibernate
      API:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</pre><p>This style is very similar to what you will find in the Hibernate
      reference documentation and examples, except for holding the
      <tt class="interfacename">SessionFactory</tt> in an instance variable.
      We strongly recommend such an instance-based setup over the old-school
      <tt class="literal">static</tt> <tt class="classname">HibernateUtil</tt> class
      from Hibernate's CaveatEmptor sample application. (In general, do not
      keep any resources in <tt class="literal">static</tt> variables unless
      <span class="emphasis"><em>absolutely</em></span> necessary.)</p><p>The above DAO follows the Dependency Injection pattern: it fits
      nicely into a Spring IoC container, just like it would if coded against
      Spring's <tt class="classname">HibernateTemplate</tt>. Of course, such a DAO
      can also be set up in plain Java (for example, in unit tests): simply
      instantiate it and call <tt class="methodname">setSessionFactory(..)</tt>
      with the desired factory reference. As a Spring bean definition, it
      would look as follows:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and will no
      doubt feel more natural to Hibernate developers.</p><p>However, the DAO throws plain
      <tt class="classname">HibernateException</tt> (which is unchecked, so does
      not have to be declared or caught), which means that callers can only
      treat exceptions as generally fatal - unless they want to depend on
      Hibernate's own exception hierarchy. Catching specific causes such as an
      optimistic locking failure is not possible without tieing the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly Hibernate-based and/or do not need any
      special exception treatment.</p><p>Fortunately, Spring's
      <tt class="classname">LocalSessionFactoryBean</tt> supports Hibernate's
      <tt class="methodname">SessionFactory.getCurrentSession()</tt> method for
      any Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="classname">HibernateTransactionManager</tt>. Of course, the
      standard behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by
      JTA).</p><p>In summary: DAOs can be implemented based on the plain Hibernate 3
      API, while still being able to participate in Spring-managed
      transactions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-programmatic"></a>12.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div><div></div></div><p>Transactions can be demarcated in a higher level of the
      application, on top of such lower-level data access services spanning
      any number of operations. There are no restrictions on the
      implementation of the surrounding business service here as well, it just
      needs a Spring <tt class="classname">PlatformTransactionManager</tt>. Again,
      the latter can come from anywhere, but preferably as bean reference via
      a <tt class="methodname">setTransactionManager(..)</tt> method - just like
      the <tt class="classname">productDAO</tt> should be set via a
      <tt class="methodname">setProductDao(..)</tt> method. The following
      snippets show a transaction manager and a business service definition in
      a Spring application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {

                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = this.productDao.loadProductsByCategory(category);
                    <i class="lineannotation"><span class="lineannotation">// do the price increase...</span></i>
                }
            }
        );
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-declarative"></a>12.2.7.&nbsp;Declarative transaction demarcation</h3></div></div><div></div></div><p>Alternatively, one can use Spring's declarative transaction
      support, which essentially enables you to replace explicit transaction
      demarcation API calls in your Java code with an AOP transaction
      interceptor configured in a Spring container. This allows you to keep
      business services free of repetitive transaction demarcation code, and
      allows you to focus on adding business logic which is where the real
      value of your application lies. Furthermore, transaction semantics like
      propagation behavior and isolation level can be changed in a
      configuration file and do not affect the business service
      implementations.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="product.ProductService"/&gt;
    &lt;property name="target"&gt;
        &lt;bean class="product.DefaultProductService"&gt;
            &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- the transaction interceptor (configured elsewhere) --&gt;</span></i>
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    <i class="lineannotation"><span class="lineannotation">// notice the absence of transaction demarcation code in this method</span></i>
    <i class="lineannotation"><span class="lineannotation">// Spring's declarative transaction infrastructure will be demarcating transactions on your behalf </span></i>
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDao.loadProductsByCategory(category);
        <i class="lineannotation"><span class="lineannotation">// ...</span></i>
    }
}</pre><p>Spring's <tt class="classname">TransactionInterceptor</tt> allows any
      checked application exception to be thrown with the callback code, while
      <tt class="classname">TransactionTemplate</tt> is restricted to unchecked
      exceptions within the callback.
      <tt class="classname">TransactionTemplate</tt> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <tt class="classname">TransactionStatus</tt>).
      <tt class="classname">TransactionInterceptor</tt> behaves the same way by
      default but allows configurable rollback policies per method.</p><p>The following higher level approach to declarative transactions
      doesn't use the <tt class="classname">ProxyFactoryBean</tt>, and as such may
      be easier to use if you have a large number of service objects that you
      wish to make transactional.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read the
        section entitled <a href="transaction.html#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">Section&nbsp;9.5, &#8220;Declarative transaction management&#8221;</a> if you
        have not done so already prior to continuing.</p></td></tr></table></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="interfacename">SessionFactory</tt>, <tt class="interfacename">DataSource</tt>, etc. omitted --&gt;</span></i>

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;bean id="myProductService" class="product.SimpleProductService"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-strategies"></a>12.2.8.&nbsp;Transaction management strategies</h3></div></div><div></div></div><p>Both <tt class="classname">TransactionTemplate</tt> and
      <tt class="classname">TransactionInterceptor</tt> delegate the actual
      transaction handling to a
      <tt class="classname">PlatformTransactionManager</tt> instance, which can be
      a <tt class="classname">HibernateTransactionManager</tt> (for a single
      Hibernate <tt class="interfacename">SessionFactory</tt>, using a
      <tt class="classname">ThreadLocal</tt>
      <tt class="interfacename">Session</tt> under the hood) or a
      <tt class="classname">JtaTransactionManager</tt> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <tt class="classname">PlatformTransactionManager</tt>
      implementation. So switching from native Hibernate transaction
      management to JTA, such as when facing distributed transaction
      requirements for certain deployments of your application, is just a
      matter of configuration. Simply replace the Hibernate transaction
      manager with Spring's JTA transaction implementation. Both transaction
      demarcation and data access code will work without changes, as they just
      use the generic transaction management APIs.</p><p>For distributed transactions across multiple Hibernate session
      factories, simply combine <tt class="classname">JtaTransactionManager</tt>
      as a transaction strategy with multiple
      <tt class="classname">LocalSessionFactoryBean</tt> definitions. Each of your
      DAOs then gets one specific
      <tt class="interfacename">SessionFactory</tt> reference passed into its
      corresponding bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <tt class="classname">JtaTransactionManager</tt> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.MySQLDialect
        hibernate.show_sql=true
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.OracleDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this shows the Spring 1.x style of declarative transaction configuration --&gt;</span></i>
  <i class="lineannotation"><span class="lineannotation">&lt;!-- it is totally supported, 100% legal in Spring 2.x, but see also above for the sleeker, Spring 2.0 style --&gt;</span></i>
  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target"&gt;
      &lt;bean class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <tt class="classname">HibernateTransactionManager</tt> and
      <tt class="classname">JtaTransactionManager</tt> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</p><p><tt class="classname">HibernateTransactionManager</tt> can export the
      JDBC <tt class="interfacename">Connection</tt> used by Hibernate to
      plain JDBC access code, for a specific
      <tt class="interfacename">DataSource</tt>. This allows for high-level
      transaction demarcation with mixed Hibernate/JDBC data access completely
      without JTA, as long as you are just accessing one database!
      <tt class="classname">HibernateTransactionManager</tt> will automatically
      expose the Hibernate transaction as JDBC transaction if the passed-in
      <tt class="interfacename">SessionFactory</tt> has been set up with a
      <tt class="interfacename">DataSource</tt> (through the "dataSource"
      property of the <tt class="classname">LocalSessionFactoryBean</tt> class).
      Alternatively, the <tt class="interfacename">DataSource</tt> that the
      transactions are supposed to be exposed for can also be specified
      explicitly, through the "dataSource" property of the
      <tt class="classname">HibernateTransactionManager</tt> class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-resources"></a>12.2.9.&nbsp;Container resources versus local resources</h3></div></div><div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI <tt class="interfacename">SessionFactory</tt> and a local one,
      without having to change a single line of application code. The decision
      as to whether to keep the resource definitions in the container or
      locally within the application, is mainly a matter of the transaction
      strategy being used. Compared to a Spring-defined local
      <tt class="interfacename">SessionFactory</tt>, a manually registered
      JNDI <tt class="interfacename">SessionFactory</tt> does not provide any
      benefits. Deploying a <tt class="interfacename">SessionFactory</tt>
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</p><p>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI <tt class="interfacename">DataSource</tt> instances. For
      non-Spring JTA-driven Hibernate transactions, you have to use the
      Hibernate JCA connector, or extra Hibernate transaction code with the
      <tt class="interfacename">TransactionManagerLookup</tt> being configured
      for proper JVM-level caching.</p><p>Spring-driven transactions can work with a locally defined
      Hibernate <tt class="interfacename">SessionFactory</tt> nicely, just
      like with a local JDBC <tt class="interfacename">DataSource</tt> - if
      accessing a single database, of course. Therefore you just have to fall
      back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as for example
      WebLogic Express does not provide JCA. A Spring application with local
      resources and transactions spanning one single database will work in any
      J2EE web container (without JTA, JCA, or EJB) - like Tomcat, Resin, or
      even plain Jetty. Additionally, such a middle tier can be reused in
      desktop applications or test suites easily.</p><p>All things considered: if you do not use EJB, stick with local
      <tt class="interfacename">SessionFactory</tt> setup and Spring's
      <tt class="classname">HibernateTransactionManager</tt> or
      <tt class="classname">JtaTransactionManager</tt>. You will get all of the
      benefits including proper transactional JVM-level caching and
      distributed transactions, without any container deployment hassle. JNDI
      registration of a Hibernate
      <tt class="interfacename">SessionFactory</tt> via the JCA connector
      really only adds value when used in conjunction with EJBs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>12.2.10.&nbsp;Spurious application server warnings when using Hibernate</h3></div></div><div></div></div><p>In some JTA environments with very strict
      <tt class="interfacename">XADataSource</tt> implementations -- currently
      only some WebLogic and WebSphere versions -- when using Hibernate
      configured without any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt> object for
      that environment, it is possible for spurious warning or exceptions to
      show up in the application server log. These warnings or exceptions will
      say something to the effect that the connection being accessed is no
      longer valid, or JDBC access is no longer valid, possibly because the
      transaction is no longer active. As an example, here is an actual
      exception from WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction.</pre><p>This warning is easy to resolve by simply making Hibernate aware
      of the JTA <tt class="interfacename">PlatformTransactionManager</tt>
      instance, to which it will also synchronize (along with Spring). This
      may be done in two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>If in your application context you are already directly
          obtaining the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> object
          (presumably from JNDI via <tt class="literal">JndiObjectFactoryBean</tt>)
          and feeding it for example to Spring's
          <tt class="classname">JtaTransactionManager</tt>, then the easiest way
          is to simply specify a reference to this as the value of
          <tt class="classname">LocalSessionFactoryBean</tt>'s
          <span class="emphasis"><em>jtaTransactionManager</em></span> property. Spring will
          then make the object available to Hibernate.</p></li><li><p>More likely you do not already have the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> instance
          (since Spring's <tt class="classname">JtaTransactionManager</tt> can
          find it itself) so you need to instead configure Hibernate to also
          look it up directly. This is done by configuring an AppServer
          specific <tt class="literal">TransactionManagerLookup</tt> class in the
          Hibernate configuration, as described in the Hibernate
          manual.</p></li></ul></div><p>It is not necessary to read any more for proper usage, but the
      full sequence of events with and without Hibernate being aware of the
      JTA <tt class="interfacename">PlatformTransactionManager</tt> will now
      be described.</p><p>When Hibernate is not configured with any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction commits</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via an
          <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction
          manager.</p></li><li><p>Among other activities, this can trigger a callback by Spring
          to Hibernate, via Hibernate's
          <tt class="literal">afterTransactionCompletion</tt> callback (used to
          clear the Hibernate cache), followed by an explicit
          <tt class="literal">close()</tt> call on the Hibernate Session, which
          results in Hibernate trying to <tt class="literal">close()</tt> the JDBC
          Connection.</p></li><li><p>In some environments, this
          <tt class="methodname">Connection.close()</tt> call then triggers the
          warning or error, as the application server no longer considers the
          <tt class="interfacename">Connection</tt> usable at all, since the
          transaction has already been committed.</p></li></ul></div><p>When Hibernate is configured with awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is instead as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction is ready to commit</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via a
          <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
          transaction manager.</p></li><li><p>Spring is aware that Hibernate itself is synchronized to the
          JTA transaction, and behaves differently than in the previous
          scenario. Assuming the Hibernate
          <tt class="interfacename">Session</tt> needs to be closed at all,
          Spring will close it now.</p></li><li><p>JTA Transaction commits</p></li><li><p>Hibernate is synchronized to the JTA transaction, so it is
          called back via an <span class="emphasis"><em>afterCompletion</em></span> callback by
          the JTA transaction manager, and can properly clear its
          cache.</p></li></ul></div><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo"></a>12.3.&nbsp;JDO</h2></div></div><div></div></div><p>Spring supports the standard JDO 2.0/2.1 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <tt class="literal">org.springframework.orm.jdo</tt> package.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-setup"></a>12.3.1.&nbsp;<tt class="interfacename">PersistenceManagerFactory</tt>
      setup</h3></div></div><div></div></div><p>Spring provides a
      <tt class="classname">LocalPersistenceManagerFactoryBean</tt> class that
      allows for defining a local JDO
      <tt class="interfacename">PersistenceManagerFactory</tt> within a Spring
      application context:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Alternatively, a
      <tt class="interfacename">PersistenceManagerFactory</tt> can also be set
      up through direct instantiation of a
      <tt class="interfacename">PersistenceManagerFactory</tt> implementation
      class. A JDO <tt class="interfacename">PersistenceManagerFactory</tt>
      implementation class is supposed to follow the JavaBeans pattern, just
      like a JDBC <tt class="interfacename">DataSource</tt> implementation
      class, which is a natural fit for a Spring bean definition. This setup
      style usually supports a Spring-defined JDBC
      <tt class="interfacename">DataSource</tt>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>):</p><pre class="programlisting">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;

&lt;/beans&gt;</pre><p>A JDO <tt class="interfacename">PersistenceManagerFactory</tt> can
      also be set up in the JNDI environment of a J2EE application server,
      usually through the JCA connector provided by the particular JDO
      implementation. Spring's standard
      <tt class="literal">JndiObjectFactoryBean</tt> can be used to retrieve and
      expose such a <tt class="interfacename">PersistenceManagerFactory</tt>.
      However, outside an EJB context, there is often no compelling benefit in
      holding the <tt class="interfacename">PersistenceManagerFactory</tt> in
      JNDI: only choose such setup for a good reason. See "container resources
      versus local resources" in the Hibernate section for a discussion; the
      arguments there apply to JDO as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-template"></a>12.3.2.&nbsp;<tt class="classname">JdoTemplate</tt> and
      <tt class="classname">JdoDaoSupport</tt></h3></div></div><div></div></div><p>Each JDO-based DAO will then receive the
      <tt class="interfacename">PersistenceManagerFactory</tt> through
      dependency injection. Such a DAO could be coded against plain JDO API,
      working with the given
      <tt class="interfacename">PersistenceManagerFactory</tt>, but will
      usually rather be used with the Spring Framework's
      <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private JdoTemplate jdoTemplate;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.jdoTemplate = new JdoTemplate(pmf);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.jdoTemplate.execute(new JdoCallback() {
            public Object doInJdo(PersistenceManager pm) throws JDOException {
                Query query = pm.newQuery(Product.class, "category = pCategory");
                query.declareParameters("String pCategory"); 
                List result = query.execute(category);
                <i class="lineannotation"><span class="lineannotation">// do some further stuff with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any JDO data
      access. <tt class="classname">JdoTemplate</tt> will ensure that
      <tt class="classname">PersistenceManager</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <tt class="literal">find</tt>,
      <tt class="literal">load</tt>, <tt class="literal">makePersistent</tt>, or
      <tt class="literal">delete</tt> call, <tt class="classname">JdoTemplate</tt>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <tt class="classname">JdoDaoSupport</tt> base class that provides a
      <tt class="literal">setPersistenceManagerFactory(..)</tt> method for receiving
      a <tt class="classname">PersistenceManagerFactory</tt>, and
      <tt class="methodname">getPersistenceManagerFactory()</tt> and
      <tt class="methodname">getJdoTemplate()</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</pre><p>As alternative to working with Spring's
      <tt class="classname">JdoTemplate</tt>, you can also code Spring-based DAOs
      at the JDO API level, explicitly opening and closing a
      <tt class="interfacename">PersistenceManager</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">JdoDaoSupport</tt> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">PersistenceManager</tt> as well as for
      converting exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-daos-straight"></a>12.3.3.&nbsp;Implementing DAOs based on the plain JDO API</h3></div></div><div></div></div><p>DAOs can also be written against plain JDO API, without any Spring
      dependencies, directly using an injected
      <tt class="interfacename">PersistenceManagerFactory</tt>. A
      corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        try {
            Query query = pm.newQuery(Product.class, "category = pCategory");
            query.declareParameters("String pCategory"); 
            return query.execute(category);
        }
        finally {
          pm.close();
        }
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring container, just like it would if
      coded against Spring's <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that they always get a new
      <tt class="interfacename">PersistenceManager</tt> from the factory. To
      still access a Spring-managed transactional
      <tt class="interfacename">PersistenceManager</tt>, consider defining a
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>
      (as included in Spring) in front of your target
      <tt class="interfacename">PersistenceManagerFactory</tt>, passing the
      proxy into your DAOs.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Your data access code will then receive a transactional
      <tt class="interfacename">PersistenceManager</tt> (if any) from the
      <tt class="methodname">PersistenceManagerFactory.getPersistenceManager()</tt>
      method that it calls. The latter method call goes through the proxy,
      which will first check for a current transactional
      <tt class="interfacename">PersistenceManager</tt> before getting a new
      one from the factory. <tt class="methodname">close()</tt> calls on the
      <tt class="interfacename">PersistenceManager</tt> will be ignored in
      case of a transactional
      <tt class="interfacename">PersistenceManager</tt>.</p><p>If your data access code will always run within an active
      transaction (or at least within active transaction synchronization), it
      is safe to omit the <tt class="methodname">PersistenceManager.close()</tt>
      call and thus the entire <tt class="literal">finally</tt> block, which you
      might prefer to keep your DAO implementations concise:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.class, "category = pCategory");
        query.declareParameters("String pCategory"); 
        return query.execute(category);
    }
}</pre><p>With such DAOs that rely on active transactions, it is recommended
      to enforce active transactions through turning
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>'s
      "allowCreate" flag off:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
    &lt;property name="allowCreate" value="false"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on JDO API
      only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to JDO developers.</p><p>However, the DAO throws plain
      <tt class="exceptionname">JDOException</tt> (which is unchecked, so does
      not have to be declared or caught), which means that callers can only
      treat exceptions as generally fatal - unless they want to depend on
      JDO's own exception structure. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly JDO-based and/or do not need any special
      exception treatment.</p><p>In summary: DAOs can be implemented based on plain JDO API, while
      still being able to participate in Spring-managed transactions. This
      might in particular appeal to people already familiar with JDO, feeling
      more natural to them. However, such DAOs will throw plain
      <tt class="exceptionname">JDOException</tt>; conversion to Spring's
      <tt class="exceptionname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-tx"></a>12.3.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

&lt;/beans&gt;</pre><p>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <tt class="classname">JdoTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p><tt class="classname">JdoTransactionManager</tt> is capable of
      exposing a JDO transaction to JDBC access code that accesses the same
      JDBC <tt class="interfacename">DataSource</tt>, provided that the
      registered <tt class="classname">JdoDialect</tt> supports retrieval of the
      underlying JDBC <tt class="interfacename">Connection</tt>. This is
      the case for JDBC-based JDO 2.0 implementations by default.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-dialect"></a>12.3.5.&nbsp;<tt class="interfacename">JdoDialect</tt></h3></div></div><div></div></div><p>As an advanced feature, both <tt class="classname">JdoTemplate</tt>
      and <tt class="classname">interfacename</tt> support a custom
      <tt class="interfacename">JdoDialect</tt>, to be passed into the
      "jdoDialect" bean property. In such a scenario, the DAOs won't receive a
      <tt class="interfacename">PersistenceManagerFactory</tt> reference but
      rather a full <tt class="classname">JdoTemplate</tt> instance instead (for
      example, passed into <tt class="classname">JdoDaoSupport</tt>'s
      "jdoTemplate" property). A <tt class="interfacename">JdoDialect</tt>
      implementation can enable some advanced features supported by Spring,
      usually in a vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
          <tt class="interfacename">Connection</tt> (for exposure to
          JDBC-based DAOs)</p></li><li><p>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</p></li><li><p>eagerly flushing a
          <tt class="interfacename">PersistenceManager</tt> (to make
          transactional changes visible to JDBC-based data access code)</p></li><li><p>advanced translation of <tt class="literal">JDOExceptions</tt> to
          Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>See the <tt class="classname">JdoDialect</tt> Javadoc for more details
      on its operations and how they are used within Spring's JDO support.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-toplink"></a>12.4.&nbsp;Oracle TopLink</h2></div></div><div></div></div><p>Since Spring 1.2, Spring supports Oracle TopLink (<a href="http://www.oracle.com/technology/products/ias/toplink" target="_top">http://www.oracle.com/technology/products/ias/toplink</a>) as
    data access strategy, following the same style as the Hibernate support.
    Both TopLink 9.0.4 (the production version as of Spring 1.2) and 10.1.3
    (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <tt class="literal">org.springframework.orm.toplink</tt> package.</p><p>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-abstraction"></a>12.4.1.&nbsp;<tt class="interfacename">SessionFactory</tt> abstraction</h3></div></div><div></div></div><p>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <tt class="literal">ServerSession</tt>, which in turn is able to spawn
      <tt class="literal">ClientSession</tt> instances for single-threaded usage.
      For flexible setup options, Spring defines a
      <tt class="interfacename">SessionFactory</tt> abstraction for TopLink,
      enabling to switch between different
      <tt class="interfacename">Session</tt> creation strategies.</p><p>As a one-stop shop, Spring provides a
      <tt class="classname">LocalSessionFactoryBean</tt> class that allows for
      defining a TopLink <tt class="interfacename">SessionFactory</tt> with
      bean-style configuration. It needs to be configured with the location of
      the TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <tt class="interfacename">DataSource</tt> to
      use.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
&lt;/beans&gt;</pre><pre class="programlisting">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</pre><p>Usually, <tt class="classname">LocalSessionFactoryBean</tt> will hold
      a multi-threaded TopLink <tt class="literal">ServerSession</tt> underneath and
      create appropriate client <tt class="interfacename">Session</tt>s for
      it: either a plain <tt class="interfacename">Session</tt> (typical), a
      managed <tt class="literal">ClientSession</tt>, or a transaction-aware
      <tt class="interfacename">Session</tt> (the latter are mainly used
      internally by Spring's TopLink support). It might also hold a
      single-threaded TopLink <tt class="literal">DatabaseSession</tt>; this is
      rather unusual, though.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-template"></a>12.4.2.&nbsp;<tt class="classname">TopLinkTemplate</tt> and
      <tt class="classname">TopLinkDaoSupport</tt></h3></div></div><div></div></div><p>Each TopLink-based DAO will then receive the
      <tt class="interfacename">SessionFactory</tt> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against plain TopLink API, fetching
      a <tt class="interfacename">Session</tt> from the given
      <tt class="interfacename">SessionFactory</tt>, but will usually rather
      be used with Spring's <tt class="literal">TopLinkTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class TopLinkProductDao implements ProductDao {
  
    private TopLinkTemplate tlTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.tlTemplate = new TopLinkTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.tlTemplate.execute(new TopLinkCallback() {
            public Object doInTopLink(Session session) throws TopLinkException {
                ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                findOwnersQuery.addArgument("Category");
                ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                findOwnersQuery.setSelectionCriteria(
                    builder.get("category").like(builder.getParameter("Category")));

                Vector args = new Vector();
                args.add(category);
                List result = session.executeQuery(findOwnersQuery, args);
                <i class="lineannotation"><span class="lineannotation">// do some further stuff with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any TopLink
      data access. <tt class="classname">TopLinkTemplate</tt> will ensure that
      <tt class="interfacename">Session</tt>s are properly opened and closed,
      and automatically participate in transactions. The template instances
      are thread-safe and reusable, they can thus be kept as instance
      variables of the surrounding class. For simple single-step actions such
      as a single <tt class="literal">executeQuery</tt>, <tt class="literal">readAll</tt>,
      <tt class="literal">readById</tt>, or <tt class="literal">merge</tt> call,
      <tt class="classname">JdoTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">TopLinkDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory()</tt> and
      <tt class="literal">getTopLinkTemplate()</tt> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}</pre><p>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</p><p>As alternative to working with Spring's
      <tt class="classname">TopLinkTemplate</tt>, you can also code your TopLink
      data access based on the raw TopLink API, explicitly opening and closing
      a <tt class="interfacename">Session</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">TopLinkDaoSupport</tt> offers a variety of support
      methods for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">Session</tt> as well as for converting
      exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-straight"></a>12.4.3.&nbsp;Implementing DAOs based on plain TopLink API</h3></div></div><div></div></div><p>DAOs can also be written against plain TopLink API, without any
      Spring dependencies, directly using an injected TopLink
      <tt class="interfacename">Session</tt>. The latter will usually be based
      on a <tt class="interfacename">SessionFactory</tt> defined by a
      <tt class="classname">LocalSessionFactoryBean</tt>, exposed for bean
      references of type <tt class="interfacename">Session</tt> through
      Spring's <tt class="literal">TransactionAwareSessionAdapter</tt>.</p><p>The <tt class="literal">getActiveSession()</tt> method defined on
      TopLink's <tt class="interfacename">Session</tt> interface will return
      the current transactional <tt class="interfacename">Session</tt> in such
      a scenario. If there is no active transaction, it will return the shared
      TopLink <tt class="literal">ServerSession</tt> as-is, which is only supposed
      to be used directly for read-only access. There is also an analogous
      <tt class="methodname">getActiveUnitOfWork()</tt> method, returning the
      TopLink <tt class="interfacename">UnitOfWork</tt> associated with the
      current transaction, if any (returning <tt class="literal">null</tt>
      else).</p><p>A corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private Session session;

    public void setSession(Session session) {
        this.session = session;
    }

    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        Vector args = new Vector();
        args.add(category);
        return session.getActiveSession().executeQuery(findOwnersQuery, args);
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, analogous to
      like it would if coded against Spring's
      <tt class="classname">TopLinkTemplate</tt>. Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> is used to expose a
      bean reference of type <tt class="interfacename">Session</tt>, to be
      passed into the DAO:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="mySessionAdapter"
      class="org.springframework.orm.toplink.support.TransactionAwareSessionAdapter"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="session" ref="mySessionAdapter"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on TopLink
      API only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to TopLink developers.</p><p>However, the DAO throws plain
      <tt class="exceptionname">TopLinkException</tt> (which is unchecked, so
      does not have to be declared or caught), which means that callers can
      only treat exceptions as generally fatal - unless they want to depend on
      TopLink's own exception structure. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly TopLink-based and/or do not need any
      special exception treatment.</p><p>A further disadvantage of that DAO style is that TopLink's
      standard <tt class="methodname">getActiveSession()</tt> feature just works
      within JTA transactions. It does <span class="emphasis"><em>not</em></span> work with any
      other transaction strategy out-of-the-box, in particular not with local
      TopLink transactions.</p><p>Fortunately, Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> exposes a
      corresponding proxy for the TopLink <tt class="literal">ServerSession</tt>
      which supports TopLink's <tt class="literal">Session.getActiveSession()</tt>
      and <tt class="literal">Session.getActiveUnitOfWork()</tt> methods for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="literal">TopLinkTransactionManager</tt>. Of course, the standard
      behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain TopLink API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familiar with TopLink,
      feeling more natural to them. However, such DAOs will throw plain
      <tt class="exceptionname">TopLinkException</tt>; conversion to Spring's
      <tt class="classname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-tx"></a>12.4.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Note that TopLink requires an active
      <tt class="interfacename">UnitOfWork</tt> for modifying a persistent
      object. (You should never modify objects returned by a plain TopLink
      <tt class="interfacename">Session</tt> - those are usually read-only
      objects, directly taken from the second-level cache!) There is no
      concept like a non-transactional flush in TopLink, in contrast to
      Hibernate. For this reason, TopLink needs to be set up for a specific
      environment: in particular, it needs to be explicitly set up for JTA
      synchronization, to detect an active JTA transaction itself and expose a
      corresponding active <tt class="interfacename">Session</tt> and
      <tt class="interfacename">UnitOfWork</tt>. This is not necessary for
      local transactions as performed by Spring's
      <tt class="literal">TopLinkTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p>Within your TopLink-based DAO code, use the
      <tt class="literal">Session.getActiveUnitOfWork()</tt> method to access the
      current <tt class="interfacename">UnitOfWork</tt> and perform write
      operations through it. This will only work within an active transaction
      (both within Spring-managed transactions and plain JTA transactions).
      For special needs, you can also acquire separate
      <tt class="interfacename">UnitOfWork</tt> instances that won't
      participate in the current transaction; this is hardly needed,
      though.</p><p><tt class="classname">TopLinkTransactionManager</tt> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <tt class="interfacename">DataSource</tt>, provided that
      TopLink works with JDBC in the backend and is thus able to expose the
      underlying JDBC <tt class="interfacename">Connection</tt>. The
      <tt class="interfacename">DataSource</tt> to expose the transactions for
      needs to be specified explicitly; it won't be autodetected.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ibatis"></a>12.5.&nbsp;iBATIS SQL Maps</h2></div></div><div></div></div><p>The iBATIS support in the Spring Framework much resembles the JDBC /
    Hibernate support in that it supports the same template style programming
    and just as with JDBC or Hibernate, the iBATIS support works with Spring's
    exception hierarchy and let's you enjoy the all IoC features Spring
    has.</p><p>Transaction management can be handled through Spring's standard
    facilities. There are no special transaction strategies for iBATIS, as
    there is no special transactional resource involved other than a JDBC
    <tt class="interfacename">Connection</tt>. Hence, Spring's standard JDBC
    <tt class="classname">DataSourceTransactionManager</tt> or
    <tt class="classname">JtaTransactionManager</tt> are perfectly
    sufficient.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Spring does actually support both iBatis 1.x and 2.x. However,
      only support for iBatis 2.x is actually shipped with the core Spring
      distribution. The iBatis 1.x support classes were moved to the Spring
      Modules project as of Spring 2.0, and you are directed there for
      documentation.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-setup"></a>12.5.1.&nbsp;Setting up the <tt class="classname">SqlMapClient</tt></h3></div></div><div></div></div><p>If we want to map the previous Account class with iBATIS 2.x we
      need to create the following SQL map
      <tt class="filename">'Account.xml'</tt>:</p><pre class="programlisting">&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</pre><p>The configuration file for iBATIS 2 looks like this:</p><pre class="programlisting">&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</pre><p>Remember that iBATIS loads resources from the class path, so be
      sure to add the <tt class="filename">'Account.xml'</tt> file to the class
      path.</p><p>We can use the <tt class="classname">SqlMapClientFactoryBean</tt> in
      the Spring container. Note that with iBATIS SQL Maps 2.x, the JDBC
      <tt class="interfacename">DataSource</tt> is usually specified on the
      <tt class="classname">SqlMapClientFactoryBean</tt>, which enables lazy
      loading.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-template"></a>12.5.2.&nbsp;Using <tt class="classname">SqlMapClientTemplate</tt> and
      <tt class="classname">SqlMapClientDaoSupport</tt></h3></div></div><div></div></div><p>The <tt class="classname">SqlMapClientDaoSupport</tt> class offers a
      supporting class similar to the <tt class="classname">SqlMapDaoSupport</tt>.
      We extend it to implement our DAO:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</pre><p>In the DAO, we use the pre-configured
      <tt class="classname">SqlMapClientTemplate</tt> to execute the queries,
      after setting up the <tt class="literal">SqlMapAccountDao</tt> in the
      application context and wiring it with our
      <tt class="literal">SqlMapClient</tt> instance:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="classname">SqlMapTemplate</tt> instance could
      also be created manually, passing in the <tt class="literal">SqlMapClient</tt>
      as constructor argument. The <tt class="literal">SqlMapClientDaoSupport</tt>
      base class simply pre-initializes a
      <tt class="classname">SqlMapClientTemplate</tt> instance for us.</p><p>The <tt class="classname">SqlMapClientTemplate</tt> also offers a
      generic <tt class="literal">execute</tt> method, taking a custom
      <tt class="literal">SqlMapClientCallback</tt> implementation as argument. This
      can, for example, be used for batching:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {
            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
                executor.startBatch();
                executor.update("insertAccount", account);
                executor.update("insertAddress", account.getAddress());
                executor.executeBatch();
            }
        });
    }
}</pre><p>In general, any combination of operations offered by the native
      <tt class="literal">SqlMapExecutor</tt> API can be used in such a callback.
      Any <tt class="literal">SQLException</tt> thrown will automatically get
      converted to Spring's generic <tt class="classname">DataAccessException</tt>
      hierarchy.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-straight"></a>12.5.3.&nbsp;Implementing DAOs based on plain iBATIS API</h3></div></div><div></div></div><p>DAOs can also be written against plain iBATIS API, without any
      Spring dependencies, directly using an injected
      <tt class="literal">SqlMapClient</tt>. A corresponding DAO implementation
      looks like as follows:</p><pre class="programlisting">public class SqlMapAccountDao implements AccountDao {
        
    private SqlMapClient sqlMapClient;
    
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }

    public Account getAccount(String email) {
        try {
            return (Account) this.sqlMapClient.queryForObject("getAccountByEmail", email);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }

    public void insertAccount(Account account) throws DataAccessException {
        try {
            this.sqlMapClient.update("insertAccount", account);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }
}</pre><p>In such a scenario, the <tt class="literal">SQLException</tt> thrown by
      the iBATIS API needs to be handled in a custom fashion: usually,
      wrapping it in your own application-specific DAO exception. Wiring in
      the application context would still look like before, due to the fact
      that the plain iBATIS-based DAO still follows the Dependency Injection
      pattern:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa"></a>12.6.&nbsp;JPA</h2></div></div><div></div></div><p>Spring JPA (available under the
    <tt class="literal">org.springframework.orm.jpa</tt> package) offers
    comprehensive support for the <a href="http://java.sun.com/developer/technicalArticles/J2EE/jpa/index.html" target="_top">Java
    Persistence API</a> in a similar manner to the integration with
    Hibernate or JDO, while being aware of the underlying implementation in
    order to provide additional features.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-setup"></a>12.6.1.&nbsp;JPA setup in a Spring environment</h3></div></div><div></div></div><p>Spring JPA offers three ways of setting up JPA
      <tt class="interfacename">EntityManagerFactory</tt>:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lemfb"></a>12.6.1.1.&nbsp;<tt class="classname">LocalEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The <tt class="classname">LocalEntityManagerFactoryBean</tt> creates
        an <tt class="interfacename">EntityManagerFactory</tt> suitable for
        environments which solely use JPA for data access. The factory bean
        will use the JPA <tt class="interfacename">PersistenceProvider</tt>
        autodetection mechanism (according to JPA's Java SE bootstrapping)
        and, in most cases, requires only the persistence unit name to be
        specified:</p><pre class="programlisting">&lt;beans&gt;

   &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
      &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre><p>This is the simplest but also most limited form of JPA
        deployment. There is no way to link to an existing JDBC
        <tt class="interfacename">DataSource</tt> and no support for global
        transactions, for example. Furthermore, weaving (byte-code
        transformation) of persistent classes is provider-specific, often
        requiring a specific JVM agent to specified on startup. All in all,
        this option is only really sufficient for standalone applications and
        test environments (which is exactly what the JPA specification
        designed it for).</p><p><span class="emphasis"><em>Only use this option in simple deployment environments
        like standalone applications and integration tests.</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-jndi"></a>12.6.1.2.&nbsp;<tt class="classname">Obtaining an EntityManagerFactory from
        JNDI</tt></h4></div></div><div></div></div><p>Obtaining an <tt class="interfacename">EntityManagerFactory</tt>
        from JNDI (for example in a Java EE 5 environment), is just a matter
        of changing the XML configuration:</p><pre class="programlisting">&lt;beans&gt;

    &lt;jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/&gt;

&lt;/beans&gt;</pre><p>This assumes standard Java EE 5 bootstrapping, with the Java EE
        server autodetecting persistence units (i.e.
        <tt class="literal">META-INF/persistence.xml</tt> files in application jars)
        and <tt class="literal">persistence-unit-ref</tt> entries in the Java EE
        deployment descriptor (e.g. <tt class="literal">web.xml</tt>) defining
        environment naming context locations for those persistence
        units.</p><p>In such a scenario, the entire persistence unit deployment,
        including the weaving (byte-code transformation) of persistent
        classes, is up to the Java EE server. The JDBC
        <tt class="interfacename">DataSource</tt> is defined through a JNDI
        location in the <tt class="literal">META-INF/persistence.xml</tt> file;
        EntityManager transactions are integrated with the server's JTA
        subsystem. Spring merely uses the obtained
        <tt class="interfacename">EntityManagerFactory</tt>, passing it on to
        application objects via dependency injection, and managing
        transactions for it (typically through
        <tt class="classname">JtaTransactionManager</tt>).</p><p>Note that, in case of multiple persistence units used in the
        same application, the bean names of such a JNDI-retrieved persistence
        units should match the persistence unit names that the application
        uses to refer to them (e.g. in <tt class="literal">@PersistenceUnit</tt> and
        <tt class="literal">@PersistenceContext</tt> annotations).</p><p><span class="emphasis"><em>Use this option when deploying to a Java EE 5 server.
        Check your server's documentation on how to deploy a custom JPA
        provider into your server, allowing for a different provider than the
        server's default. </em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lcemfb"></a>12.6.1.3.&nbsp;<tt class="classname">LocalContainerEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> gives
        full control over <tt class="interfacename">EntityManagerFactory</tt>
        configuration and is appropriate for environments where fine-grained
        customization is required. The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> will
        create a <tt class="interfacename">PersistenceUnitInfo</tt> based on
        the <tt class="literal">persistence.xml</tt> file, the supplied
        <tt class="literal">dataSourceLookup</tt> strategy and the specified
        <tt class="literal">loadTimeWeaver</tt>. It is thus possible to work with
        custom DataSources outside of JNDI and to control the weaving
        process.</p><pre class="programlisting">&lt;beans&gt;
        
 &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="someDataSource"/&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
 &lt;/bean&gt;
 
&lt;/beans&gt;</pre><p>A typical <tt class="literal">persistence.xml</tt> file looks as follows:</p><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0"&gt;

  &lt;persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;mapping-file&gt;META-INF/orm.xml&lt;/mapping-file&gt;
    &lt;exclude-unlisted-classes/&gt;
  &lt;/persistence-unit&gt;

&lt;/persistence&gt;</pre><p><span class="emphasis"><em>NOTE: The "exclude-unlisted-classes" element always
        indicates that NO scanning for annotated entity classes is supposed
        to happen, in order to support the
        <tt class="literal">&lt;exclude-unlisted-classes/&gt;</tt> shortcut.
        This is in line with the JPA specification (which suggests that shortcut)
        but unfortunately in conflict with the JPA XSD (which implies "false"
        for that shortcut). As a consequence,
        "<tt class="literal">&lt;exclude-unlisted-classes&gt; false &lt;/exclude-unlisted-classes/&gt;</tt>"
        is not supported! Simply omit the "exclude-unlisted-classes" element if
        you would like entity class scanning to actually happen.</em></span></p><p>This is the most powerful JPA setup option, allowing for
        flexible local configuration within the application. It supports links
        to an existing JDBC <tt class="interfacename">DataSource</tt>,
        supports both local and global transactions, etc. However, it also
        imposes requirements onto the runtime environment, such as the
        availability of a weaving-capable ClassLoader if the persistence
        provider demands byte-code transformation.</p><p>Note that this option may conflict with the built-in JPA
        capabilities of a Java EE 5 server. So when running in a full Java EE
        5 environment, consider obtaining your
        <tt class="interfacename">EntityManagerFactory</tt> from JNDI.
        Alternatively, specify a custom "persistenceXmlLocation" on your
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>
        definition, e.g. "META-INF/my-persistence.xml", and only include a
        descriptor with that name in your application jar files. Since the
        Java EE 5 server will only look for default
        <tt class="literal">META-INF/persistence.xml</tt> files, it will ignore such
        custom persistence units and hence avoid conflicts with a
        Spring-driven JPA setup upfront. (This applies to Resin 3.1, for
        example.)</p><p><span class="emphasis"><em>Use this option for full JPA capabilities in a
        Spring-based application environment. This includes web containers
        such as Tomcat as well as standalone applications and integration
        tests with sophisticated persistence requirements.</em></span></p><div class="sidebar"><p class="title"><b>When is load-time weaving required?</b></p><p>Not all JPA providers impose the need of a JVM agent
          (Hibernate being an example). If your provider does not require an
          agent or you have other alternatives (for example applying
          enhancements at build time through a custom compiler or an ant task)
          the load-time weaver <span class="bold"><b>should not</b></span> be
          used.</p></div><p>The <tt class="interfacename">LoadTimeWeaver</tt> interface is a
        Spring-provided class that allows JPA
        <tt class="interfacename">ClassTransformer</tt> instances to be
        plugged in a specific manner depending on the environment (web
        container/application server). Hooking
        <tt class="literal">ClassTransformers</tt> through a Java 5 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_top">agent</a>
        is typically not efficient - the agents work against the
        <span class="emphasis"><em>entire virtual machine</em></span> and inspect
        <span class="emphasis"><em>every</em></span> class that is loaded - something that is
        typically undesirable in a production server enviroment.</p><p>Spring provides a number of
        <tt class="interfacename">LoadTimeWeaver</tt> implementations for
        various environments, allowing
        <tt class="interfacename">ClassTransformer</tt> instances to be
        applied only <span class="emphasis"><em>per ClassLoader</em></span> and not per VM.</p><p>The following sections will discuss typical JPA weaving setup on
        Tomcat as well as using Spring's VM agent. See the AOP chapter section
        entitled <a href="aop.html#aop-aj-ltw-spring" title="6.8.4.5.&nbsp;Spring configuration">Section&nbsp;6.8.4.5, &#8220;Spring configuration&#8221;</a> for details on how to set
        up general load-time weaving, covering Tomcat and the VM agent as well
        as WebLogic, OC4J, GlassFish and Resin.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-tomcat"></a>12.6.1.3.1.&nbsp;Tomcat load-time weaving setup (5.0+)</h5></div></div><div></div></div><p><a href="http://tomcat.apache.org/" target="_top">Apache
          Tomcat's</a> default ClassLoader does not support class
          transformation but allows custom ClassLoaders to be used. Spring
          offers the <tt class="classname">TomcatInstrumentableClassLoader</tt>
          (inside the
          <tt class="literal">org.springframework.instrument.classloading.tomcat</tt>
          package) which extends the Tomcat ClassLoader
          (<tt class="classname">WebappClassLoader</tt>) and allows JPA
          <tt class="classname">ClassTransformer</tt> instances to 'enhance' all
          classes loaded by it. In short, JPA transformers will be applied
          only inside a specific web application (which uses the
          <tt class="classname">TomcatInstrumentableClassLoader</tt>).</p><p>In order to use the custom ClassLoader on:</p><div class="itemizedlist"><div class="orderedlist"><ol type="1"><li><p>Copy <tt class="literal">spring-tomcat-weaver.jar</tt> into
                <span class="emphasis"><em>$CATALINA_HOME</em></span>/server/lib (where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation).</p></li><li><p>Instruct Tomcat to use the custom ClassLoader (instead
                of the default one) by editing the web application context
                file:</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre><p>Tomcat 5.0.x and 5.5.x series support several context
                locations: server configuration file
                (<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>), the
                default context configuration
                (<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>) that
                affects all deployed web applications and per-webapp
                configurations, deployed on the server
                <span class="emphasis"><em>($CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>)
                side or along with the webapp
                (<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>).
                For efficiency, inside the web-app configuration style is
                recommended since only applications which use JPA will use the
                custom ClassLoader. See the Tomcat 5.x <a href="http://tomcat.apache.org/tomcat-5.5-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p><p>Note that versions prior to 5.5.20 contained a bug in
                the XML configuration parsing preventing usage of
                <tt class="literal">Loader</tt> tag inside
                <span class="emphasis"><em>server.xml</em></span> (no matter if a ClassLoader is
                specified or not (be it the official or a custom one). See
                Tomcat's bugzilla for <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=39704" target="_top">more
                details</a>.</p><p>If you are using Tomcat 5.5.20+ you can set
                <span class="emphasis"><em>useSystemClassLoaderAsParent</em></span> to
                <tt class="literal">false</tt> to fix the problem: </p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"
            useSystemClassLoaderAsParent="false"/&gt;
&lt;/Context&gt;</pre></li></ol></div><div class="orderedlist"><ol type="1"><li><p>Copy <tt class="literal">spring-tomcat-weaver.jar</tt> into
                <span class="emphasis"><em>$CATALINA_HOME</em></span>/lib (where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation).</p></li><li><p>Instruct Tomcat to use the custom ClassLoader (instead
                of the default one) by editing the web application context
                file:</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre><p>Tomcat 6.0.x (similar to 5.0.x/5.5.x) series support
                several context locations: server configuration file
                (<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>), the
                default context configuration
                (<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>) that
                affects all deployed web applications and per-webapp
                configurations, deployed on the server
                <span class="emphasis"><em>($CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>)
                side or along with the webapp
                (<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>).
                For efficiency, inside the web-app configuration style is
                recommended since only applications which use JPA will use the
                custom ClassLoader. See the Tomcat 5.x <a href="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p></li></ol></div><ul type="disc"><li><p>Tomcat 5.0.x/5.5.x</p></li><li><p>Tomcat 6.0.x</p></li></ul></div><p>The last step required on all Tomcat versions, is to use the
          appropriate the <tt class="interfacename">LoadTimeWeaver</tt> when
          configuring
          <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>:</p><pre class="programlisting">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Using this technique, JPA applications relying on
          instrumentation, can run in Tomcat without the need of an agent.
          This is important especially when hosting applications which rely on
          different JPA implementations since the JPA transformers are applied
          only at ClassLoader level and thus, are isolated from each
          other.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If TopLink is being used a JPA provider under Tomcat, please
            place the toplink-essentials jar under
            <span class="emphasis"><em>$CATALINA_HOME</em></span>/shared/lib folder instead of
            your war.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-agent"></a>12.6.1.3.2.&nbsp;General load-time weaving using the VM agent</h5></div></div><div></div></div><p>For environments where class instrumentation is required but
          are not supported by the existing LoadTimeWeaver implementations, a
          JDK agent can be the only solution. For such cases, Spring provides
          <tt class="classname">InstrumentationLoadTimeWeaver</tt> which requires
          a Spring-specific (but very general) VM agent (<tt class="filename">spring-agent.jar</tt>):</p><pre class="programlisting">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the virtual machine has to be started with the
          Spring agent, by supplying the following JVM options:</p><pre class="programlisting">-javaagent:/path/to/spring-agent.jar</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-weaver"></a>12.6.1.3.3.&nbsp;Context-wide load-time weaver setup</h5></div></div><div></div></div><p>Since Spring 2.5, a context-wide <tt class="interfacename">LoadTimeWeaver</tt>
          can be configured using the <tt class="literal">context:load-time-weaver</tt> configuration
          element. Such a 'global' weaver will be picked up by all JPA
          <tt class="classname">LocalContainerEntityManagerFactoryBeans</tt> automatically.</p><p>This is the preferred way of setting up a load-time weaver, delivering
          autodetection of the platform (WebLogic, OC4J, GlassFish, Tomcat, Resin, VM agent)
          as well as automatic propagation of the weaver to all weaver-aware beans.</p><pre class="programlisting">&lt;context:load-time-weaver/&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    ...
&lt;/bean&gt;</pre><p>See the section entitled <a href="aop.html#aop-aj-ltw-spring" title="6.8.4.5.&nbsp;Spring configuration">Section&nbsp;6.8.4.5, &#8220;Spring configuration&#8221;</a>
          for details on how to set up general load-time weaving, covering Tomcat
          and the VM agent as well as WebLogic, OC4J, GlassFish and Resin.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-multiple-pu"></a>12.6.1.4.&nbsp;Dealing with multiple persistence units</h4></div></div><div></div></div><p>For applications that rely on multiple persistence units
        locations (stored in various jars in the classpath for example),
        Spring offers the
        <tt class="interfacename">PersistenceUnitManager</tt> to act as a
        central repository and avoid the (potentially expensive) persistence
        units discovery process. The default implementation allows multiple
        locations to be specified (by default, the classpath is searched for
        <tt class="filename">'META-INF/persistence.xml'</tt> files) which are
        parsed and later on retrieved through the persistence unit
        name:</p><pre class="programlisting">&lt;bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
  &lt;property name="persistenceXmlLocation"&gt;
    &lt;list&gt;
     &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
     &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
     &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="dataSources"&gt;
   &lt;map&gt;
    &lt;entry key="localDataSource" value-ref="local-db"/&gt;
    &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
   &lt;/map&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- if no datasource is specified, use this one --&gt;</span></i>
  &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager" ref="pum"/&gt;
&lt;/bean&gt;</pre><p>Note that the default implementation allows customization of the
        persistence unit infos before feeding them to the JPA provider
        declaratively through its properties (which affect <span class="emphasis"><em>all</em></span>
        hosted units) or programmatically, through the
        <tt class="interfacename">PersistenceUnitPostProcessor</tt>
        (which allows persistence unit selection). If no
        <tt class="interfacename">PersistenceUnitManager</tt> is
        specified, one will be created and used internally by
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-template"></a>12.6.2.&nbsp;<tt class="classname">JpaTemplate</tt> and
      <tt class="classname">JpaDaoSupport</tt></h3></div></div><div></div></div><p>Each JPA-based DAO will then receive a
      <tt class="interfacename">EntityManagerFactory</tt> via dependency
      injection. Such a DAO can be coded against plain JPA and work with the
      given <tt class="interfacename">EntityManagerFactory</tt> or through
      Spring's <tt class="classname">JpaTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="entityManagerFactory" ref="myEmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class JpaProductDao implements ProductDao {
  
    private JpaTemplate jpaTemplate;

    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.jpaTemplate = new JpaTemplate(emf);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.jpaTemplate.execute(new JpaCallback() {
            public Object doInJpa(EntityManager em) throws PersistenceException {
                Query query = em.createQuery("from Product as p where p.category = :category");
                query.setParameter("category", category);
                List result = query.getResultList(); 
                <i class="lineannotation"><span class="lineannotation">// do some further processing with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>The <tt class="interfacename">JpaCallback</tt> implementation
      allows any type of JPA data access. The
      <tt class="classname">JpaTemplate</tt> will ensure that
      <tt class="interfacename">EntityManager</tt>s are properly opened and
      closed and automatically participate in transactions. Moreover, the
      <tt class="classname">JpaTemplate</tt> properly handles exceptions, making
      sure resources are cleaned up and the appropriate transactions rolled
      back. The template instances are thread-safe and reusable and they can
      be kept as instance variable of the enclosing class. Note that
      <tt class="classname">JpaTemplate</tt> offers single-step actions such as
      find, load, merge, etc along with alternative convenience methods that
      can replace one line callback implementations.</p><p>Furthermore, Spring provides a convenient
      <tt class="classname">JpaDaoSupport</tt> base class that provides the
      <tt class="literal">get/setEntityManagerFactory</tt> and
      <tt class="methodname">getJpaTemplate()</tt> to be used by
      subclasses:</p><pre class="programlisting">public class ProductDaoImpl extends JpaDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
        params.put("category", category);
        return getJpaTemplate().findByNamedParams("from Product as p where p.category = :category", params);
    }
}</pre><p>Besides working with Spring's <tt class="classname">JpaTemplate</tt>,
      one can also code Spring-based DAOs against the JPA, doing one's own
      explicit <tt class="interfacename">EntityManager</tt> handling. As also
      elaborated in the corresponding Hibernate section, the main advantage of
      this approach is that your data access code is able to throw checked
      exceptions. <tt class="classname">JpaDaoSupport</tt> offers a variety of
      support methods for this scenario, for retrieving and releasing a
      transaction <tt class="interfacename">EntityManager</tt>, as well as for
      converting exceptions.</p><p><span class="emphasis"><em>JpaTemplate mainly exists as a sibling of JdoTemplate
      and HibernateTemplate, offering the same style for people used to it.
      For newly started projects, consider adopting the native JPA style of
      coding data access objects instead, based on a "shared EntityManager"
      reference obtained through the JPA
      <tt class="literal">@PersistenceContext</tt> annotation (using Spring's
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt>; see below
      for details.)</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-straight"></a>12.6.3.&nbsp;Implementing DAOs based on plain JPA</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>While <tt class="interfacename">EntityManagerFactory</tt>
        instances are thread-safe,
        <tt class="interfacename">EntityManager</tt> instances are not. The
        injected JPA <tt class="interfacename">EntityManager</tt> behave just
        like an <tt class="interfacename">EntityManager</tt> fetched from an
        application server's JNDI environment, as defined by the JPA
        specification. It will delegate all calls to the current transactional
        <tt class="interfacename">EntityManager</tt>, if any; else, it will
        fall back to a newly created
        <tt class="interfacename">EntityManager</tt> per operation, making it
        thread-safe.</p></td></tr></table></div><p>It is possible to write code against the plain JPA without using
      any Spring dependencies, using an injected
      <tt class="interfacename">EntityManagerFactory</tt> or
      <tt class="interfacename">EntityManager</tt>. Note that Spring can
      understand <tt class="interfacename">@PersistenceUnit</tt> and
      <tt class="interfacename">@PersistenceContext</tt> annotations both at
      field and method level if a
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt> is
      enabled. A corresponding DAO implementation might look like this:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        EntityManager em = this.emf.createEntityManager();
        try {
             Query query = em.createQuery("from Product as p where p.category = ?1");
             query.setParameter(1, category);
             return query.getResultList();
        }
        finally {
            if (em != null) {
                em.close();
            }
        }
    }
}</pre><p>The DAO above has no dependency on Spring and still fits nicely
      into a Spring application context, just like it would if coded against
      Spring's <tt class="classname">JpaTemplate</tt>. Moreover, the DAO takes
      advantage of annotations to require the injection of the default
      <tt class="interfacename">EntityManagerFactory</tt>:</p><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- bean post-processor for JPA annotations --&gt;</span></i>
  &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>Note: As alternative to defining a
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt>
      explicitly, consider using Spring 2.5's
      <tt class="literal">context:annotation-config</tt> XML element in your
      application context configuration. This will automatically register all
      of Spring's standard post-processors for annotation-based configuration
      (including <tt class="classname">CommonAnnotationBeanPostProcessor</tt>
      etc).</p><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- post-processors for all standard config annotations --&gt;</span></i>
  &lt;context:annotation-config/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The main issue with such a DAO is that it always creates a new
      <tt class="interfacename">EntityManager</tt> via the factory. This can
      be easily overcome by requesting a transactional
      <tt class="interfacename">EntityManager</tt> (also called "shared
      EntityManager", since it is a shared, thread-safe proxy for the actual
      transactional EntityManager) to be injected instead of the
      factory:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
       Query query = em.createQuery("from Product as p where p.category = :category");
       query.setParameter("category", category);
       return query.getResultList(); 
    }
}</pre><p>Note that the <tt class="literal">@PersistenceContext</tt> annotation
      has an optional attribute <tt class="literal">type</tt>, which defaults to
      <tt class="literal">PersistenceContextType.TRANSACTION</tt>. This default is
      what you need to receive a "shared EntityManager" proxy. The
      alternative, <tt class="literal">PersistenceContextType.EXTENDED</tt>, is a
      completely different affair: This results in a so-called "extended
      EntityManager", which is <span class="emphasis"><em>not thread-safe</em></span> and hence
      must not be used in a concurrently accessed component such as a
      Spring-managed singleton bean. Extended EntityManagers are only supposed
      to be used in stateful components that, for example, reside in a
      session, with the lifecycle of the EntityManager not tied to a current
      transaction but rather being completely up to the application.</p><div class="sidebar"><p class="title"><b>Method and Field level Injection</b></p><p>Annotations that indicate dependency injections (such as
        <tt class="literal">@PersistenceUnit</tt> and
        <tt class="literal">@PersistenceContext</tt>) can be applied on field or
        methods inside a class, therefore the expression "method/field level
        injection". Field-level annotations concise and easier to use while
        method-level allow for processing the injected dependency. In both
        cases the member visibility (public, protected, private) does not
        matter.</p><p>What about class level annotations?</p><p>On the Java EE 5 platform, they are used for dependency declaration
        and not for resource injection.</p></div><p>The injected <tt class="interfacename">EntityManager</tt> is
      Spring-managed (aware of the ongoing transaction). It is important to
      note that even though the new implementation prefers method level
      injection (of an <tt class="interfacename">EntityManager</tt> instead of
      an <tt class="interfacename">EntityManagerFactory)</tt>, no change is
      required in the application context XML due to annotation usage.</p><p>The main advantage of this DAO style is that it depends on Java
      Persistence API; no import of any Spring class is required. Moreover, as
      the JPA annotations are understood, the injections are applied
      automatically by the Spring container. This is of course appealing from
      a non-invasiveness perspective, and might feel more natural to JPA
      developers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-exceptions"></a>12.6.4.&nbsp;Exception Translation</h3></div></div><div></div></div><p>However, the DAO throws the plain
      <tt class="classname">PersistenceException</tt> exception class (which is
      unchecked, and so does not have to be declared or caught) but also
      <tt class="classname">IllegalArgumentException</tt> and
      <tt class="classname">IllegalStateException</tt>, which means that callers
      can only treat exceptions as generally fatal - unless they want to
      depend on JPA's own exception structure. Catching specific causes such
      as an optimistic locking failure is not possible without tying the
      caller to the implementation strategy. This tradeoff might be acceptable
      to applications that are strongly JPA-based and/or do not need any
      special exception treatment. However, Spring offers a solution allowing
      exception translation to be applied transparently through the
      <tt class="interfacename">@Repository</tt> annotation:</p><pre class="programlisting">@Repository
public class ProductDaoImpl implements ProductDao {

    <i class="lineannotation"><span class="lineannotation">// class body here...</span></i>

}</pre><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="classname">Exception</tt> translation bean post processor --&gt;</span></i>
  &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The postprocessor will automatically look for all exception
      translators (implementations of the
      <tt class="interfacename">PersistenceExceptionTranslator</tt> interface)
      and advise all beans marked with the
      <tt class="interfacename">@Repository</tt> annotation so that the
      discovered translators can intercept and apply the appropriate
      translation on the thrown exceptions.</p><p>In summary: DAOs can be implemented based on the plain Java
      Persistence API and annotations, while still being able to benefit from
      Spring-managed transactions, dependency injection, and transparent
      exception conversion (if desired) to Spring's custom exception
      hierarchies.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa-tx"></a>12.7.&nbsp;Transaction Management</h2></div></div><div></div></div><p>To execute service operations within transactions, you can use
    Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="myEmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Spring JPA allows a configured
    <tt class="classname">JpaTransactionManager</tt> to expose a JPA transaction
    to JDBC access code that accesses the same JDBC
    <tt class="interfacename">DataSource</tt>, provided that the registered
    <tt class="interfacename">JpaDialect</tt> supports retrieval of the
    underlying JDBC <tt class="interfacename">Connection</tt>. Out of the box,
    Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA
    implementations. See the next section for details on the
    <tt class="interfacename">JpaDialect</tt> mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa-dialect"></a>12.8.&nbsp;<tt class="interfacename">JpaDialect</tt></h2></div></div><div></div></div><p>As an advanced feature <tt class="classname">JpaTemplate</tt>,
    <tt class="classname">JpaTransactionManager</tt> and subclasses of
    <tt class="classname">AbstractEntityManagerFactoryBean</tt> support a custom
    <tt class="interfacename">JpaDialect</tt>, to be passed into the
    "jpaDialect" bean property. In such a scenario, the DAOs won't receive an
    <tt class="interfacename">EntityManagerFactory</tt> reference but rather a
    full <tt class="classname">JpaTemplate</tt> instance instead (for example,
    passed into <tt class="classname">JpaDaoSupport</tt>'s "jpaTemplate"
    property). A <tt class="interfacename">JpaDialect</tt> implementation can
    enable some advanced features supported by Spring, usually in a
    vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
        isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
        <tt class="interfacename">Connection</tt> (for exposure to JDBC-based
        DAOs)</p></li><li><p>advanced translation of <tt class="literal">PersistenceExceptions</tt>
        to Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>This is particularly valuable for special transaction semantics and
    for advanced translation of exception. Note that the default
    implementation used (<tt class="classname">DefaultJpaDialect</tt>) doesn't
    provide any special capabilities and if the above features are required,
    the appropriate dialect has to be specified.</p><p>See the <tt class="interfacename">JpaDialect</tt> Javadoc for more
    details of its operations and how they are used within Spring's JPA
    support.</p></div></div><!--Begin LoopFuse code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" src="http://loopfuse.net/webrecorder/js/listen.js" type="text/javascript"></script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            _lf_cid = "LF_48be82fa";
            _lf_remora();
        </script><!--End LoopFuse code--><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-web.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;11.&nbsp;Data access using JDBC&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;The Web</td></tr></table></div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>


<!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script>
<script type="text/javascript">var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");pageTracker._setAllowLinker(true);
pageTracker._trackPageview();var OrgTracker = _gat._getTracker("UA-2728886-2");
OrgTracker._trackPageview();</script>
 <!-- End 2nd Google code -->



</body>
</html>