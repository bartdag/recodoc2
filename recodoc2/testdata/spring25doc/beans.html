<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;The IoC container</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><!--Begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-2728886-3");
            pageTracker._setDomainName("none");
            pageTracker._setAllowLinker(true);
            pageTracker._trackPageview();
        </script><!--End Google Analytics code--><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="spring-core.html" title="Part&nbsp;I.&nbsp;Core Technologies"><link rel="previous" href="spring-core.html" title="Part&nbsp;I.&nbsp;Core Technologies"><link rel="next" href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/springsource-banner-rhs.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>Chapter&nbsp;3.&nbsp;The IoC container</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-introduction"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>This chapter covers the Spring Framework's implementation of the
    Inversion of Control (IoC)
    <sup>[<a name="d0e1168" href="#ftn.d0e1168">1</a>]</sup>
    principle.</p><div class="sidebar"><p class="title"><b><tt class="interfacename">BeanFactory</tt> or
      <tt class="interfacename">ApplicationContext</tt>?</b></p><p>Users are sometimes unsure whether a
      <tt class="interfacename">BeanFactory</tt> or an
      <tt class="interfacename">ApplicationContext</tt> is best suited for use
      in a particular situation. A <tt class="interfacename">BeanFactory</tt>
      pretty much just instantiates and configures beans. An
      <tt class="interfacename">ApplicationContext</tt> also does that,
      <span class="emphasis"><em>and</em></span> it provides the supporting infrastructure to
      enable <span class="emphasis"><em>lots</em></span> of enterprise-specific features such as
      transactions and AOP.</p><p><span class="bold"><b>In short, favor the use of an
      <tt class="interfacename">ApplicationContext</tt>.</b></span></p><p>(For the specific details behind this recommendation, see <a href="beans.html#context-introduction-ctx-vs-beanfactory" title="3.8.1.&nbsp;BeanFactory or&#xA;      ApplicationContext?">this
      section</a>.)</p></div><p>The <tt class="literal">org.springframework.beans</tt> and
    <tt class="literal">org.springframework.context</tt> packages provide the basis
    for the Spring Framework's IoC container. The <tt class="interfacename"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></tt>
    interface provides an advanced configuration mechanism capable of managing
    objects of any nature. The <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></tt>
    interface builds on top of the <tt class="interfacename">BeanFactory</tt>
    (it is a sub-interface) and adds other functionality such as easier
    integration with Spring's AOP features, message resource handling (for use
    in internationalization), event propagation, and application-layer
    specific contexts such as the
    <tt class="interfacename">WebApplicationContext</tt> for use in web
    applications.</p><p>In short, the <tt class="interfacename">BeanFactory</tt> provides
    the configuration framework and basic functionality, while the
    <tt class="interfacename">ApplicationContext</tt> adds more
    enterprise-centric functionality to it. The
    <tt class="interfacename">ApplicationContext</tt> is a complete superset
    of the <tt class="interfacename">BeanFactory</tt>, and any description of
    <tt class="interfacename">BeanFactory</tt> capabilities and behavior is to
    be considered to apply to the
    <tt class="interfacename">ApplicationContext</tt> as well.</p><p>This chapter is divided into two parts, with the <a href="beans.html#beans-basics" title="3.2.&nbsp;Basics - containers and beans">first part</a> covering the basic principles
    that apply to both the <tt class="interfacename">BeanFactory</tt> and
    <tt class="interfacename">ApplicationContext</tt>, and with the <a href="beans.html#context-introduction" title="3.8.&nbsp;The ApplicationContext">second part</a> covering those features
    that apply only to the <tt class="interfacename">ApplicationContext</tt>
    interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-basics"></a>3.2.&nbsp;Basics - containers and beans</h2></div></div><div></div></div><p>In Spring, those objects that form the backbone of your application
    and that are managed by the Spring IoC <i class="firstterm">container</i>
    are referred to as <i class="firstterm">beans</i>. A bean is simply an
    object that is instantiated, assembled and otherwise managed by a Spring
    IoC container; other than that, there is nothing special about a bean (it
    is in all other respects one of probably many objects in your
    application). These beans, and the <i class="firstterm">dependencies</i>
    between them, are reflected in the <i class="firstterm">configuration
    metadata</i> used by a container.</p><div class="sidebar"><p class="title"><b>Why... <span class="emphasis"><em>bean</em></span>?</b></p><p>The motivation for using the name <span class="emphasis"><em>'bean'</em></span>, as
      opposed to <span class="emphasis"><em>'component'</em></span> or
      <span class="emphasis"><em>'object'</em></span> is rooted in the origins of the Spring
      Framework itself (it arose partly as a response to the complexity of
      Enterprise Java<span class="emphasis"><em>Beans</em></span>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory"></a>3.2.1.&nbsp;The container</h3></div></div><div></div></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.BeanFactory</tt>
      is the actual representation of the Spring IoC
      <span class="emphasis"><em>container</em></span> that is responsible for containing and
      otherwise managing the aforementioned beans.</p><p>The <tt class="interfacename">BeanFactory</tt> interface is the
      central IoC container interface in Spring. Its responsibilities include
      instantiating or sourcing application objects, configuring such objects,
      and assembling the dependencies between these objects.</p><p>There are a number of implementations of the
      <tt class="interfacename">BeanFactory</tt> interface that come supplied
      straight out-of-the-box with Spring. The most commonly used
      <tt class="interfacename">BeanFactory</tt> implementation is the
      <tt class="classname">XmlBeanFactory</tt> class. This implementation allows
      you to express the objects that compose your application, and the
      doubtless rich interdependencies between such objects, in terms of XML.
      The <tt class="classname">XmlBeanFactory</tt> takes this XML
      <i class="firstterm">configuration metadata</i> and uses it to create a
      fully configured system or application.</p><p>
        </p><div class="mediaobject" align="center"><img src="images/container-magic.png" align="middle"><div class="caption"><p>The Spring IoC container</p></div></div><p>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-metadata"></a>3.2.1.1.&nbsp;Configuration metadata</h4></div></div><div></div></div><p>As can be seen in the above image, the Spring IoC container
        consumes some form of <span class="emphasis"><em>configuration metadata</em></span>;
        this configuration metadata is nothing more than how you (as an
        application developer) inform the Spring container as to how to
        <span class="emphasis"><em>&#8220;<span class="quote">instantiate, configure, and assemble [the objects in
        your application]</span>&#8221;.</em></span> This configuration metadata is
        typically supplied in a simple and intuitive XML format. When using
        XML-based configuration metadata, you write <span class="emphasis"><em>bean
        definitions</em></span> for those beans that you want the Spring IoC
        container to manage, and then let the container do its stuff.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>XML-based metadata is by far the most commonly used form of
          configuration metadata. It is <span class="emphasis"><em>not</em></span> however the
          only form of configuration metadata that is allowed. The Spring IoC
          container itself is <span class="emphasis"><em>totally</em></span> decoupled from the
          format in which this configuration metadata is actually written. The
          XML-based configuration metadata format really is simple though, and
          so the majority of this chapter will use the XML format to convey
          key concepts and features of the Spring IoC container.</p><p>You can find details of another form of metadata that the
          Spring container can consume in the section entitled <a href="beans.html#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a></p></td></tr></table></div></div><div class="sidebar"><p class="title"><b>Resources</b></p><p>The location path or paths supplied to an
        <tt class="interfacename">ApplicationContext</tt> constructor are
        actually resource strings that allow the container to load
        configuration metadata from a variety of external resources such as
        the local file system, from the Java <tt class="literal">CLASSPATH</tt>,
        etc.</p><p>Once you have learned about Spring's IoC container, you may wish
        to learn a little more about Spring's
        <tt class="interfacename">Resource</tt> abstraction, as described in
        the chapter entitled <a href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.</p></div><p>In the vast majority of application scenarios, explicit user code
      is not required to instantiate one or more instances of a Spring IoC
      container. For example, in a web application scenario, a simple eight
      (or so) lines of boilerplate J2EE web descriptor XML in the
      <tt class="literal">web.xml</tt> file of the application will typically
      suffice (see <a href="beans.html#context-create" title="3.8.5.&nbsp;Convenient ApplicationContext&#xA;      instantiation for web applications">Section&nbsp;3.8.5, &#8220;Convenient ApplicationContext
      instantiation for web applications&#8221;</a>).</p></div><p>Spring configuration consists of at least one bean definition that
    the container must manage, but typically there will be more than one bean
    definition. When using XML-based configuration metadata, these beans are
    configured as <tt class="literal">&lt;bean/&gt;</tt> elements inside a top-level
    <tt class="literal">&lt;beans/&gt;</tt> element.</p><p>These bean definitions correspond to the actual objects that make up
    your application. Typically you will have bean definitions for your
    service layer objects, your data access objects (DAOs), presentation
    objects such as Struts <tt class="interfacename">Action</tt> instances,
    infrastructure objects such as Hibernate
    <tt class="interfacename">SessionFactories</tt>, JMS
    <tt class="interfacename">Queues</tt>, and so forth. Typically one does
    not configure fine-grained domain objects in the container, because it is
    usually the responsibility of DAOs and business logic to create/load
    domain objects.</p><p>Find below an example of the basic structure of XML-based
    configuration metadata.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;

  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- more bean definitions go here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-instantiation"></a>3.2.2.&nbsp;Instantiating a container</h3></div></div><div></div></div><p>Instantiating a Spring IoC container is straightforward.</p><pre class="programlisting">ApplicationContext context = new ClassPathXmlApplicationContext(
        new String[] {"services.xml", "daos.xml"});

<i class="lineannotation"><span class="lineannotation">// an <tt class="interfacename">ApplicationContext</tt> is also a <tt class="interfacename">BeanFactory</tt> (via inheritance)</span></i>
BeanFactory factory = context;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-xml-import"></a>3.2.2.1.&nbsp;Composing XML-based configuration metadata</h4></div></div><div></div></div><p>It can often be useful to split up container definitions into
        multiple XML files. One way to then load an application context which
        is configured from all these XML fragments is to use the application
        context constructor which takes multiple
        <tt class="interfacename">Resource</tt> locations. With a bean
        factory, a bean definition reader can be used multiple times to read
        definitions from each file in turn.</p><p>Generally, the Spring team prefers the above approach, since it
        keeps container configuration files unaware of the fact that they are
        being combined with others. An alternate approach is to use one or
        more occurrences of the <tt class="literal">&lt;import/&gt;</tt> element to
        load bean definitions from another file (or files). Let's look at a
        sample:</p><pre class="programlisting">&lt;beans&gt;

    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;

&lt;/beans&gt;</pre><p>In this example, external bean definitions are being loaded from
        3 files, <tt class="literal">services.xml</tt>,
        <tt class="literal">messageSource.xml</tt>, and
        <tt class="literal">themeSource.xml</tt>. All location paths are considered
        relative to the definition file doing the importing, so
        <tt class="literal">services.xml</tt> in this case must be in the same
        directory or classpath location as the file doing the importing, while
        <tt class="literal">messageSource.xml</tt> and
        <tt class="literal">themeSource.xml</tt> must be in a
        <tt class="literal">resources</tt> location below the location of the
        importing file. As you can see, a leading slash is actually ignored,
        but given that these are considered relative paths, it is probably
        better form not to use the slash at all. The contents of the files
        being imported must be valid XML bean definition files according to
        the Spring Schema or DTD, including the top level
        <tt class="literal">&lt;beans/&gt;</tt> element.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It is possible to reference files in parent directories using a relative "../"
        path. However, this is not recommended because it creates a dependency on a file
        that is outside the current application. This is in particular not recommended
        for "classpath:" URLs (e.g. "classpath:../services.xml") where the runtime
        resolution process will pick the "nearest" classpath root and then look into
        its parent directory. This is fragile since classpath configuration changes
        may lead to a different directory being picked.</p><p>Note that you can always use fully qualified resource locations
        instead of relative paths: e.g. "file:C:/config/services.xml" or
        "classpath:/config/services.xml". However, be aware that you are coupling
        your application's configuration to specific absolute locations then.
        It is generally preferable to keep an indirection for such absolute
        locations, e.g. through "${...}" placeholders that are resolved
        against JVM system properties at runtime.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-definition"></a>3.2.3.&nbsp;The beans</h3></div></div><div></div></div><p>A Spring IoC container manages one or more
      <span class="emphasis"><em>beans</em></span>. These beans are created using the
      configuration metadata that has been supplied to the container
      (typically in the form of XML <tt class="literal">&lt;bean/&gt;</tt>
      definitions).</p><p>Within the container itself, these bean definitions are
      represented as <tt class="interfacename">BeanDefinition</tt> objects,
      which contain (among other information) the following metadata:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>a package-qualified class name:</em></span> typically
          this is the actual implementation class of the bean being
          defined.</p></li><li><p>bean behavioral configuration elements, which state how the
          bean should behave in the container (scope, lifecycle callbacks, and
          so forth).</p></li><li><p>references to other beans which are needed for the bean to do
          its work; these references are also called
          <span class="emphasis"><em>collaborators</em></span> or
          <span class="emphasis"><em>dependencies</em></span>.</p></li><li><p>other configuration settings to set in the newly created
          object. An example would be the number of connections to use in a
          bean that manages a connection pool, or the size limit of the
          pool.</p></li></ul></div><p>The concepts listed above directly translate to a set of
      properties that each bean definition consists of. Some of these
      properties are listed below, along with a link to further documentation
      about each of them.</p><div class="table"><a name="beans-factory-bean-definition-tbl"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;The bean definition</b></p><table summary="The bean definition" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explained in...</th></tr></thead><tbody><tr><td>class</td><td><p>
                  <a href="beans.html#beans-factory-class" title="3.2.3.2.&nbsp;Instantiating beans">Section&nbsp;3.2.3.2, &#8220;Instantiating beans&#8221;</a>
                </p></td></tr><tr><td>name</td><td><p>
                  <a href="beans.html#beans-beanname" title="3.2.3.1.&nbsp;Naming beans">Section&nbsp;3.2.3.1, &#8220;Naming beans&#8221;</a>
                </p></td></tr><tr><td>scope</td><td><p>
                  <a href="beans.html#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">Section&nbsp;3.4, &#8220;Bean scopes&#8221;</a>
                </p></td></tr><tr><td>constructor arguments</td><td><p>
                  <a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a>
                </p></td></tr><tr><td>properties</td><td><p>
                  <a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a>
                </p></td></tr><tr><td>autowiring mode</td><td><p>
                  <a href="beans.html#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a>
                </p></td></tr><tr><td>dependency checking mode</td><td><p>
                  <a href="beans.html#beans-factory-dependencies" title="3.3.6.&nbsp;Checking for dependencies">Section&nbsp;3.3.6, &#8220;Checking for dependencies&#8221;</a>
                </p></td></tr><tr><td>lazy-initialization mode</td><td><p>
                  <a href="beans.html#beans-factory-lazy-init" title="3.3.4.&nbsp;Lazily-instantiated beans">Section&nbsp;3.3.4, &#8220;Lazily-instantiated beans&#8221;</a>
                </p></td></tr><tr><td>initialization method</td><td><p>
                  <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">Section&nbsp;3.5.1.1, &#8220;Initialization callbacks&#8221;</a>
                </p></td></tr><tr><td>destruction method</td><td><p>
                  <a href="beans.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks">Section&nbsp;3.5.1.2, &#8220;Destruction callbacks&#8221;</a>
                </p></td></tr></tbody></table></div><p>Besides bean definitions which contain information on how to
      create a specific bean, certain
      <tt class="interfacename">BeanFactory</tt> implementations also permit
      the registration of existing objects that have been created outside the
      factory (by user code). The
      <tt class="classname">DefaultListableBeanFactory</tt> class supports this
      through the <tt class="methodname">registerSingleton(..)</tt> method.
      (Typical applications solely work with beans defined through metadata
      bean definitions though.)</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beanname"></a>3.2.3.1.&nbsp;Naming beans</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Bean naming conventions</b></p><p>The convention (at least amongst the Spring development team)
          is to use the standard Java convention for instance field names when
          naming beans. That is, bean names start with a lowercase letter, and
          are camel-cased from then on. Examples of such names would be
          (without quotes) <tt class="literal">'accountManager'</tt>,
          <tt class="literal">'accountService'</tt>, <tt class="literal">'userDao'</tt>,
          <tt class="literal">'loginController'</tt>, and so forth.</p><p>Adopting a consistent way of naming your beans will go a long
          way towards making your configuration easier to read and understand;
          adopting such naming standards is not hard to do, and if you are
          using Spring AOP it can pay off handsomely when it comes to applying
          advice to a set of beans related by name.</p></div><p>Every bean has one or more <tt class="literal">id</tt>s (also called
        identifiers, or names; these terms refer to the same thing). These
        <tt class="literal">id</tt>s must be unique within the container the bean is
        hosted in. A bean will almost always have only one id, but if a bean
        has more than one id, the extra ones can essentially be considered
        aliases.</p><p>When using XML-based configuration metadata, you use the
        <tt class="literal">'id'</tt> or <tt class="literal">'name'</tt> attributes to
        specify the bean identifier(s). The <tt class="literal">'id'</tt> attribute
        allows you to specify exactly one id, and as it is a real XML element
        ID attribute, the XML parser is able to do some extra validation when
        other elements reference the id; as such, it is the preferred way to
        specify a bean id. However, the XML specification does limit the
        characters which are legal in XML IDs. This is usually not a
        constraint, but if you have a need to use one of these special XML
        characters, or want to introduce other aliases to the bean, you may
        also or instead specify one or more bean <tt class="literal">id</tt>s,
        separated by a comma (<tt class="literal">,</tt>), semicolon
        (<tt class="literal">;</tt>), or whitespace in the <tt class="literal">'name'</tt>
        attribute.</p><p>Please note that you are not required to supply a name for a
        bean. If no name is supplied explicitly, the container will generate a
        unique name for that bean. The motivations for not supplying a name
        for a bean will be discussed later (one use case is <a href="beans.html#beans-inner-beans" title="3.3.2.3.&nbsp;Inner beans">inner beans</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beanname-alias"></a>3.2.3.1.1.&nbsp;Aliasing beans</h5></div></div><div></div></div><p>In a bean definition itself, you may supply more than one name
          for the bean, by using a combination of up to one name specified via
          the <tt class="literal">id</tt> attribute, and any number of other names
          via the <tt class="literal">name</tt> attribute. All these names can be
          considered equivalent aliases to the same bean, and are useful for
          some situations, such as allowing each component used in an
          application to refer to a common dependency using a bean name that
          is specific to that component itself.</p><p>Having to specify all aliases when the bean is actually
          defined is not always adequate however. It is sometimes desirable to
          introduce an alias for a bean which is defined elsewhere. In
          XML-based configuration metadata this may be accomplished via the
          use of the <tt class="literal">&lt;alias/&gt;</tt> element.</p><pre class="programlisting">&lt;alias name="fromName" alias="toName"/&gt;</pre><p>In this case, a bean in the same container which is named
          <tt class="literal">'fromName'</tt>, may also after the use of this alias
          definition, be referred to as <tt class="literal">'toName'</tt>.</p><p>As a concrete example, consider the case where component A
          defines a DataSource bean called componentA-dataSource, in its XML
          fragment. Component B would however like to refer to the DataSource
          as componentB-dataSource in its XML fragment. And the main
          application, MyApp, defines its own XML fragment and assembles the
          final application context from all three fragments, and would like
          to refer to the DataSource as myApp-dataSource. This scenario can be
          easily handled by adding to the MyApp XML fragment the following
          standalone aliases:</p><pre class="programlisting">&lt;alias name="componentA-dataSource" alias="componentB-dataSource"/&gt;
&lt;alias name="componentA-dataSource" alias="myApp-dataSource" /&gt;</pre><p>Now each component and the main application can refer to the
          dataSource via a name that is unique and guaranteed not to clash
          with any other definition (effectively there is a namespace), yet
          they refer to the same bean.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-class"></a>3.2.3.2.&nbsp;Instantiating beans</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Inner class names</b></p><p>If for whatever reason you want to configure a bean definition
          for a <tt class="literal">static</tt> inner class, you have to use the
          <span class="emphasis"><em>binary</em></span> name of the inner class.</p><p>For example, if you have a class called
          <tt class="classname">Foo</tt> in the <tt class="literal">com.example</tt>
          package, and this <tt class="classname">Foo</tt> class has a
          <tt class="literal">static</tt> inner class called
          <tt class="classname">Bar</tt>, the value of the
          <tt class="literal">'class'</tt> attribute on a bean definition would
          be...</p><p>
            <tt class="classname">com.example.Foo$Bar</tt>
          </p><p>Notice the use of the <tt class="literal">$</tt> character in the
          name to separate the inner class name from the outer class
          name.</p></div><p>A bean definition essentially is a recipe for creating one or
        more objects. The container looks at the recipe for a named bean when
        asked, and uses the configuration metadata encapsulated by that bean
        definition to create (or acquire) an actual object.</p><p>If you are using XML-based configuration metadata, you can
        specify the type (or class) of object that is to be instantiated using
        the <tt class="literal">'class'</tt> attribute of the
        <tt class="literal">&lt;bean/&gt;</tt> element. This
        <tt class="literal">'class'</tt> attribute (which internally eventually
        boils down to being a <tt class="classname">Class</tt> property on a
        <tt class="interfacename">BeanDefinition</tt> instance) is normally
        mandatory (see <a href="beans.html#beans-factory-class-instance-factory-method" title="3.2.3.2.3.&nbsp;Instantiation using an instance factory method">Section&nbsp;3.2.3.2.3, &#8220;Instantiation using an instance factory method&#8221;</a> and <a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">Section&nbsp;3.6, &#8220;Bean definition inheritance&#8221;</a> for the two exceptions) and
        is used for one of two purposes. The class property specifies the
        class of the bean to be constructed in the common case where the
        container itself directly creates the bean by calling its constructor
        reflectively (somewhat equivalent to Java code using the
        <span class="emphasis"><em>'new'</em></span> operator). In the less common case where
        the container invokes a <tt class="literal">static</tt>,
        <span class="emphasis"><em>factory</em></span> method on a class to create the bean, the
        class property specifies the actual class containing the
        <tt class="literal">static</tt> factory method that is to be invoked to
        create the object (the type of the object returned from the invocation
        of the <tt class="literal">static</tt> factory method may be the same class
        or another class entirely, it doesn't matter).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-ctor"></a>3.2.3.2.1.&nbsp;Instantiation using a constructor</h5></div></div><div></div></div><p>When creating a bean using the constructor approach, all
          normal classes are usable by and compatible with Spring. That is,
          the class being created does not need to implement any specific
          interfaces or be coded in a specific fashion. Just specifying the
          bean class should be enough. However, depending on what type of IoC
          you are going to use for that specific bean, you may need a default
          (empty) constructor.</p><p>Additionally, the Spring IoC container isn't limited to just
          managing true JavaBeans, it is also able to manage virtually
          <span class="emphasis"><em>any</em></span> class you want it to manage. Most people
          using Spring prefer to have actual JavaBeans (having just a default
          (no-argument) constructor and appropriate setters and getters
          modeled after the properties) in the container, but it is also
          possible to have more exotic non-bean-style classes in your
          container. If, for example, you need to use a legacy connection pool
          that absolutely does not adhere to the JavaBean specification,
          Spring can manage it as well.</p><p>When using XML-based configuration metadata you can specify
          your bean class like so:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</pre><p>The mechanism for supplying arguments to the constructor (if
          required), or setting properties of the object instance after it has
          been constructed, <a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">is
          described shortly</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-static-factory-method"></a>3.2.3.2.2.&nbsp;Instantiation using a static factory method</h5></div></div><div></div></div><p>When defining a bean which is to be created using a static
          factory method, along with the <tt class="literal">class</tt> attribute
          which specifies the class containing the <tt class="literal">static</tt>
          factory method, another attribute named
          <tt class="literal">factory-method</tt> is needed to specify the name of
          the factory method itself. Spring expects to be able to call this
          method (with an optional list of arguments as described later) and
          get back a live object, which from that point on is treated as if it
          had been created normally via a constructor. One use for such a bean
          definition is to call <tt class="literal">static</tt> factories in legacy
          code.</p><p>The following example shows a bean definition which specifies
          that the bean is to be created by calling a factory-method. Note
          that the definition does not specify the type (class) of the
          returned object, only the class containing the factory method. In
          this example, the <tt class="methodname">createInstance()</tt> method
          must be a <span class="emphasis"><em>static</em></span> method.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</pre><p>The mechanism for supplying (optional) arguments to the
          factory method, or setting properties of the object instance after
          it has been returned from the factory, will be <a href="beans.html#beans-factory-properties-detailed" title="3.3.2.&nbsp;Dependencies and configuration in detail">described
          shortly</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-instance-factory-method"></a>3.2.3.2.3.&nbsp;Instantiation using an instance factory method</h5></div></div><div></div></div><p>In a fashion similar to instantiation via a <a href="beans.html#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">static factory
          method</a>, instantiation using an instance factory method is
          where a non-static method of an existing bean from the container is
          invoked to create a new bean. To use this mechanism, the
          <tt class="literal">'class'</tt> attribute must be left empty, and the
          <tt class="literal">'factory-bean'</tt> attribute must specify the name of
          a bean in the current (or parent/ancestor) container that contains
          the instance method that is to be invoked to create the object. The
          name of the factory method itself must be set using the
          <tt class="literal">'factory-method'</tt> attribute.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- the factory bean, which contains a method called <tt class="methodname">createInstance()</tt> --&gt;</span></i>
&lt;bean id="serviceLocator" class="com.foo.DefaultServiceLocator"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></i>
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the bean to be created via the factory bean --&gt;</span></i>
&lt;bean id="exampleBean"
      factory-bean="serviceLocator"
      factory-method="createInstance"/&gt;</pre><p>Although the mechanisms for <a href="beans.html#beans-factory-properties-detailed" title="3.3.2.&nbsp;Dependencies and configuration in detail">setting bean
          properties</a> are still to be discussed, one implication of this
          approach is that the factory bean itself can be managed and
          configured via DI.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>When the Spring documentation makes mention of a 'factory
          bean', this will be a reference to a bean that is configured in the
          Spring container that will create objects via an <a href="beans.html#beans-factory-class-instance-factory-method" title="3.2.3.2.3.&nbsp;Instantiation using an instance factory method">instance</a>
          or <a href="beans.html#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">static</a>
          factory method. When the documentation mentions a
          <tt class="interfacename">FactoryBean</tt> (notice the
          capitalization) this is a reference to a Spring-specific <a href="beans.html#beans-factory-extension-factorybean" title="3.7.3.&nbsp;Customizing instantiation logic using&#xA;      FactoryBeans">
              <tt class="interfacename">FactoryBean</tt>
            </a>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-client"></a>3.2.4.&nbsp;Using the container</h3></div></div><div></div></div><p>A <tt class="interfacename">BeanFactory</tt> is essentially
      nothing more than the interface for an advanced factory capable of
      maintaining a registry of different beans and their dependencies. The
      <tt class="interfacename">BeanFactory</tt> enables you to read bean
      definitions and access them using the bean factory. When using just the
      <tt class="interfacename">BeanFactory</tt> you would create one and read
      in some bean definitions in the XML format as follows:</p><pre class="programlisting">Resource res = new FileSystemResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(res);</pre><p>Basically that is all there is to it. Using
      <tt class="methodname">getBean(String)</tt> you can retrieve instances of
      your beans; the client-side view of the
      <tt class="interfacename">BeanFactory</tt> is simple. The
      <tt class="interfacename">BeanFactory</tt> interface has just a few
      other methods, but ideally your application code should never use
      them... indeed, your application code should have no calls to the
      <tt class="methodname">getBean(String)</tt> method at all, and thus no
      dependency on Spring APIs at all.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-dependencies"></a>3.3.&nbsp;Dependencies</h2></div></div><div></div></div><p>Your typical enterprise application is not made up of a single
    object (or bean in the Spring parlance). Even the simplest of applications
    will no doubt have at least a handful of objects that work together to
    present what the end-user sees as a coherent application. This next
    section explains how you go from defining a number of bean definitions
    that stand-alone, each to themselves, to a fully realized application
    where objects work (or collaborate) together to achieve some goal (usually
    an application that does what the end-user wants).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-collaborators"></a>3.3.1.&nbsp;Injecting dependencies</h3></div></div><div></div></div><p>The basic principle behind <span class="emphasis"><em>Dependency
      Injection</em></span> (DI) is that objects define their dependencies
      (that is to say the other objects they work with) only through
      constructor arguments, arguments to a factory method, or properties
      which are set on the object instance after it has been constructed or
      returned from a factory method. Then, it is the job of the container to
      actually <span class="emphasis"><em>inject</em></span> those dependencies when it creates
      the bean. This is fundamentally the inverse, hence the name
      <span class="emphasis"><em>Inversion of Control</em></span> (IoC), of the bean itself
      being in control of instantiating or locating its dependencies on its
      own using direct construction of classes, or something like the
      <span class="emphasis"><em>Service Locator</em></span> pattern.</p><p>It becomes evident upon usage that code gets much cleaner when the
      DI principle is applied, and reaching a higher grade of decoupling is
      much easier when objects do not look up their dependencies, but are
      provided with them (and additionally do not even know where the
      dependencies are located and of what concrete class they are). DI exists
      in two major variants, namely <a href="beans.html#beans-constructor-injection" title="3.3.1.1.&nbsp;Constructor Injection">Constructor Injection</a> and
      <a href="beans.html#beans-setter-injection" title="3.3.1.2.&nbsp;Setter Injection">Setter Injection</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-constructor-injection"></a>3.3.1.1.&nbsp;Constructor Injection</h4></div></div><div></div></div><p><span class="emphasis"><em>Constructor-based</em></span> DI is effected by
        invoking a constructor with a number of arguments, each representing a
        dependency. Additionally, calling a <tt class="literal">static</tt> factory
        method with specific arguments to construct the bean, can be
        considered almost equivalent, and the rest of this text will consider
        arguments to a constructor and arguments to a
        <tt class="literal">static</tt> factory method similarly. Find below an
        example of a class that could only be dependency injected using
        constructor injection. Notice that there is nothing
        <span class="emphasis"><em>special</em></span> about this class.</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on a <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a constructor so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-ctor-arguments-resolution"></a>3.3.1.1.1.&nbsp;Constructor Argument Resolution</h5></div></div><div></div></div><p>Constructor argument resolution matching occurs using the
          argument's type. If there is no potential for ambiguity in the
          constructor arguments of a bean definition, then the order in which
          the constructor arguments are defined in a bean definition is the
          order in which those arguments will be supplied to the appropriate
          constructor when it is being instantiated. Consider the following
          class:</p><pre class="programlisting">package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        <i class="lineannotation"><span class="lineannotation">// ...</span></i>
    }
}</pre><p>There is no potential for ambiguity here (assuming of course
          that <tt class="classname">Bar</tt> and <tt class="classname">Baz</tt>
          classes are not related in an inheritance hierarchy). Thus the
          following configuration will work just fine, and you do not need to
          specify the constructor argument indexes and / or types
          explicitly.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean name="foo" class="x.y.Foo"&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Bar"/&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Baz"/&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>When another bean is referenced, the type is known, and
          matching can occur (as was the case with the preceding example).
          When a simple type is used, such as
          <tt class="literal">&lt;value&gt;true&lt;value&gt;</tt>, Spring cannot
          determine the type of the value, and so cannot match by type without
          help. Consider the following class:</p><pre class="programlisting">package examples;

public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// No. of years to the calculate the Ultimate Answer</span></i>
    private int years;

    <i class="lineannotation"><span class="lineannotation">// The Answer to Life, the Universe, and Everything</span></i>
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="beans-factory-ctor-arguments-type"></a>3.3.1.1.1.1.&nbsp;Constructor Argument Type Matching</h6></div></div><div></div></div><p>The above scenario <span class="emphasis"><em>can</em></span> use type
            matching with simple types by explicitly specifying the type of
            the constructor argument using the <tt class="literal">'type'</tt>
            attribute. For example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="7500000"/&gt;
  &lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="beans-factory-ctor-arguments-index"></a>3.3.1.1.1.2.&nbsp;Constructor Argument Index</h6></div></div><div></div></div><p>Constructor arguments can have their index specified
            explicitly by use of the <tt class="literal">index</tt> attribute. For
            example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg index="0" value="7500000"/&gt;
  &lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</pre><p>As well as solving the ambiguity problem of multiple simple
            values, specifying an index also solves the problem of ambiguity
            where a constructor may have two arguments of the same type. Note
            that the <span class="emphasis"><em>index is 0 based</em></span>.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-setter-injection"></a>3.3.1.2.&nbsp;Setter Injection</h4></div></div><div></div></div><p><span class="emphasis"><em>Setter-based</em></span> DI is realized by calling
        setter methods on your beans after invoking a no-argument constructor
        or no-argument <tt class="literal">static</tt> factory method to instantiate
        your bean.</p><p>Find below an example of a class that can only be dependency
        injected using pure setter injection. Note that there is nothing
        <span class="emphasis"><em>special</em></span> about this class... it is plain old
        Java.</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on the <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a setter method so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre></div><div class="sidebar"><p class="title"><b>Constructor- or Setter-based DI?</b></p><p>The Spring team generally advocates the usage of setter
        injection, since a large number of constructor arguments can get
        unwieldy, especially when some properties are optional. The presence
        of setter methods also makes objects of that class amenable to being
        re-configured (or re-injected) at some later time (for management via
        <a href="jmx.html" title="Chapter&nbsp;20.&nbsp;JMX">JMX MBeans</a> is a particularly compelling use
        case).</p><p>Constructor-injection is favored by some purists though (and
        with good reason). Supplying all of an object's dependencies means
        that that object is never returned to client (calling) code in a less
        than totally initialized state. The flip side is that the object
        becomes less amenable to re-configuration (or re-injection).</p><p>There is no hard and fast rule here. Use whatever type of DI
        makes the most sense for a particular class; sometimes, when dealing
        with third party classes to which you do not have the source, the
        choice will already have been made for you - a legacy class may not
        expose any setter methods, and so constructor injection will be the
        only type of DI available to you.</p></div><p>The <tt class="interfacename">BeanFactory</tt> supports both of
      these variants for injecting dependencies into beans it manages. (It in
      fact also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <tt class="interfacename">BeanDefinition</tt>, which is used together
      with <tt class="interfacename">PropertyEditor</tt> instances to know how
      to convert properties from one format to another. However, most users of
      Spring will not be dealing with these classes directly (that is
      programmatically), but rather with an XML definition file which will be
      converted internally into instances of these classes, and used to load
      an entire Spring IoC container instance.</p><p>Bean dependency resolution generally happens as follows:</p><div class="orderedlist"><ol type="1"><li><p>The <tt class="interfacename">BeanFactory</tt> is created and
          initialized with a configuration which describes all the beans.
          (Most Spring users use a <tt class="interfacename">BeanFactory</tt>
          or <tt class="interfacename">ApplicationContext</tt> implementation
          that supports XML format configuration files.)</p></li><li><p>Each bean has dependencies expressed in the form of
          properties, constructor arguments, or arguments to the
          static-factory method when that is used instead of a normal
          constructor. These dependencies will be provided to the bean,
          <span class="emphasis"><em>when the bean is actually created</em></span>.</p></li><li><p>Each property or constructor argument is either an actual
          definition of the value to set, or a reference to another bean in
          the container.</p></li><li><p><a name="beans-factory-collaborators-propertyeditor"></a>
          Each property or constructor argument which is a value must be able
          to be converted from whatever format it was specified in, to the
          actual type of that property or constructor argument. By default
          Spring can convert a value supplied in string format to all built-in
          types, such as <tt class="literal">int</tt>, <tt class="literal">long</tt>,
          <tt class="literal">String</tt>, <tt class="literal">boolean</tt>, etc.</p></li></ol></div><p>The Spring container validates the configuration of each bean as
      the container is created, including the validation that properties which
      are bean references are actually referring to valid beans. However, the
      bean properties themselves are not set until the bean <span class="emphasis"><em>is
      actually created</em></span>. For those beans that are singleton-scoped
      and set to be pre-instantiated (such as singleton beans in an
      <tt class="interfacename">ApplicationContext</tt>), creation happens at
      the time that the container is created, but otherwise this is only when
      the bean is requested. When a bean actually has to be created, this will
      potentially cause a graph of other beans to be created, as its
      dependencies and its dependencies' dependencies (and so on) are created
      and assigned.</p><div class="sidebar"><p class="title"><b>Circular dependencies</b></p><p>If you are using predominantly constructor injection it is
        possible to write and configure your classes and beans such that an
        unresolvable circular dependency scenario is created.</p><p>Consider the scenario where you have class A, which requires an
        instance of class B to be provided via constructor injection, and
        class B, which requires an instance of class A to be provided via
        constructor injection. If you configure beans for classes A and B to
        be injected into each other, the Spring IoC container will detect this
        circular reference at runtime, and throw a
        <tt class="classname">BeanCurrentlyInCreationException</tt>.</p><p>One possible solution to this issue is to edit the source code
        of some of your classes to be configured via setters instead of via
        constructors. Another solution is not to use constructor injection and
        stick to setter injection only. In other words, while it should
        generally be avoided in all but the rarest of circumstances, it is
        possible to configure circular dependencies with setter
        injection.</p><p>Unlike the <span class="emphasis"><em>typical</em></span> case (with no circular
        dependencies), a circular dependency between bean A and bean B will
        force one of the beans to be injected into the other prior to being
        fully initialized itself (a classic chicken/egg scenario).</p></div><p>You can generally trust Spring to do the right thing. It will
      detect misconfiguration issues, such as references to non-existent beans
      and circular dependencies, at container load-time. It will actually set
      properties and resolve dependencies as late as possible, which is when
      the bean is actually created. This means that a Spring container which
      has loaded correctly can later generate an exception when you request a
      bean if there is a problem creating that bean or one of its
      dependencies. This could happen if the bean throws an exception as a
      result of a missing or invalid property, for example. This potentially
      delayed visibility of some configuration issues is why
      <tt class="interfacename">ApplicationContext</tt> implementations by
      default pre-instantiate singleton beans. At the cost of some upfront
      time and memory to create these beans before they are actually needed,
      you find out about configuration issues when the
      <tt class="interfacename">ApplicationContext</tt> is created, not later.
      If you wish, you can still override this default behavior and set any of
      these singleton beans to lazy-initialize (that is not be
      pre-instantiated).</p><p>If no circular dependencies are involved (see sidebar for a
      discussion of circular dependencies), when one or more collaborating
      beans are being injected into a dependent bean, each collaborating bean
      is <span class="emphasis"><em>totally</em></span> configured prior to being passed (via
      one of the DI flavors) to the dependent bean. This means that if bean A
      has a dependency on bean B, the Spring IoC container will
      <span class="emphasis"><em>totally</em></span> configure bean B prior to invoking the
      setter method on bean A; you can read '<span class="emphasis"><em>totally
      configure</em></span>' to mean that the bean will be instantiated (if not
      a pre-instantiated singleton), all of its dependencies will be set, and
      the relevant lifecycle methods (such as a <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">configured init
      method</a> or the <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">IntializingBean
      callback method</a>) will all be invoked.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-some-examples"></a>3.3.1.3.&nbsp;Some examples</h4></div></div><div></div></div><p>First, an example of using XML-based configuration metadata for
        setter-based DI. Find below a small part of a Spring XML configuration
        file specifying some bean definitions.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
  &lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</pre><p>As you can see, setters have been declared to match against the
        properties specified in the XML file. Find below an example of using
        constructor-based DI.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;constructor-arg&gt;
    &lt;ref bean="anotherExampleBean"/&gt;
  &lt;/constructor-arg&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  
  &lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</pre><p>As you can see, the constructor arguments specified in the bean
        definition will be used to pass in as arguments to the constructor of
        the <tt class="classname">ExampleBean</tt>.</p><p>Now consider a variant of this where instead of using a
        constructor, Spring is told to call a <tt class="literal">static</tt>
        factory method to return an instance of the object:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
  &lt;constructor-arg ref="anotherExampleBean"/&gt;
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  &lt;constructor-arg value="1"/&gt; 
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// a private constructor</span></i>
    private ExampleBean(...) {
      ...
    }
    <i class="lineannotation"><span class="lineannotation">
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.</span></i>
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        <i class="lineannotation"><span class="lineannotation">// some other operations...</span></i>
        return eb;
    }
}</pre><p>Note that arguments to the <tt class="literal">static</tt> factory
        method are supplied via <tt class="literal">&lt;constructor-arg/&gt;</tt>
        elements, exactly the same as if a constructor had actually been used.
        Also, it is important to realize that the type of the class being
        returned by the factory method does not have to be of the same type as
        the class which contains the <tt class="literal">static</tt> factory method,
        although in this example it is. An instance (non-static) factory
        method would be used in an essentially identical fashion (aside from
        the use of the <tt class="literal">factory-bean</tt> attribute instead of
        the <tt class="literal">class</tt> attribute), so details will not be
        discussed here.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-properties-detailed"></a>3.3.2.&nbsp;Dependencies and configuration in detail</h3></div></div><div></div></div><p>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. Spring's
      XML-based configuration metadata supports a number of sub-element types
      within its <tt class="literal">&lt;property/&gt;</tt> and
      <tt class="literal">&lt;constructor-arg/&gt;</tt> elements for just this
      purpose.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-value-element"></a>3.3.2.1.&nbsp;Straight values (primitives, <tt class="literal">Strings</tt>,
        etc.)</h4></div></div><div></div></div><p>The <tt class="literal">&lt;value/&gt;</tt> element specifies a
        property or constructor argument as a human-readable string
        representation. <a href="beans.html#beans-factory-collaborators-propertyeditor">As mentioned
        previously</a>, JavaBeans <tt class="literal">PropertyEditors</tt> are
        used to convert these string values from a
        <tt class="classname">String</tt> to the actual type of the property or
        argument.</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a <tt class="methodname">setDriverClassName(String)</tt> call --&gt;</span></i>
  &lt;property name="driverClassName"&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="username"&gt;
    &lt;value&gt;root&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="password"&gt;
    &lt;value&gt;masterkaoli&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">&lt;property/&gt;</tt> and
        <tt class="literal">&lt;constructor-arg/&gt;</tt> elements also support the
        use of the <tt class="literal">'value'</tt> attribute, which can lead to
        much more succinct configuration. When using the
        <tt class="literal">'value'</tt> attribute, the above bean definition reads
        like so:</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a <tt class="methodname">setDriverClassName(String)</tt> call --&gt;</span></i>
  &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
  &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt;
  &lt;property name="username" value="root"/&gt;
  &lt;property name="password" value="masterkaoli"/&gt;
&lt;/bean&gt;</pre><p>The Spring team generally prefer the attribute style over the
        use of nested <tt class="literal">&lt;value/&gt;</tt> elements. If you are
        reading this reference manual straight through from top to bottom
        (wow!) then we are getting slightly ahead of ourselves here, but you
        can also configure a <tt class="classname">java.util.Properties</tt>
        instance like so:</p><pre class="programlisting">&lt;bean id="mappings" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
            
   <i class="lineannotation"><span class="lineannotation">&lt;!-- typed as a <tt class="classname">java.util.Properties</tt> --&gt;</span></i>
   &lt;property name="properties"&gt;
      &lt;value&gt;
         jdbc.driver.className=com.mysql.jdbc.Driver
         jdbc.url=jdbc:mysql://localhost:3306/mydb
      &lt;/value&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><p>Can you see what is happening? The Spring container is
        converting the text inside the <tt class="literal">&lt;value/&gt;</tt>
        element into a <tt class="classname">java.util.Properties</tt> instance
        using the JavaBeans <tt class="interfacename">PropertyEditor</tt>
        mechanism. This is a nice shortcut, and is one of a few places where
        the Spring team do favor the use of the nested
        <tt class="literal">&lt;value/&gt;</tt> element over the
        <tt class="literal">'value'</tt> attribute style.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-idref-element"></a>3.3.2.1.1.&nbsp;The <tt class="literal">idref</tt> element</h5></div></div><div></div></div><p>The <tt class="literal">idref</tt> element is simply an error-proof
          way to pass the <span class="emphasis"><em>id</em></span> of another bean in the
          container (to a <tt class="literal">&lt;constructor-arg/&gt;</tt> or
          <tt class="literal">&lt;property/&gt;</tt> element).</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above bean definition snippet is
          <span class="emphasis"><em>exactly</em></span> equivalent (at runtime) to the
          following snippet:</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..." /&gt;

&lt;bean id="client" class="..."&gt;
    &lt;property name="targetName" value="theTargetBean" /&gt;
&lt;/bean&gt;</pre><p>The main reason the first form is preferable to the second is
          that using the <tt class="literal">idref</tt> tag allows the container to
          validate <span class="emphasis"><em>at deployment time</em></span> that the
          referenced, named bean actually exists. In the second variation, no
          validation is performed on the value that is passed to the
          <tt class="literal">'targetName'</tt> property of the
          <tt class="literal">'client'</tt> bean. Any typo will only be discovered
          (with most likely fatal results) when the
          <tt class="literal">'client'</tt> bean is actually instantiated. If the
          <tt class="literal">'client'</tt> bean is a <a href="beans.html#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">prototype</a> bean, this typo (and
          the resulting exception) may only be discovered long after the
          container is actually deployed.</p><p>Additionally, if the bean being referred to is in the same XML
          unit, and the bean name is the bean <span class="emphasis"><em>id</em></span>, the
          <tt class="literal">'local'</tt> attribute may be used, which allows the
          XML parser itself to validate the bean id even earlier, at XML
          document parse time.</p><pre class="programlisting">&lt;property name="targetName"&gt;
   <i class="lineannotation"><span class="lineannotation">&lt;!-- a bean with an id of '<tt class="literal">theTargetBean</tt>' must exist; otherwise an XML exception will be thrown --&gt;</span></i>
   &lt;idref local="theTargetBean"/&gt;
&lt;/property&gt;</pre><p>By way of an example, one common place (at least in pre-Spring
          2.0 configuration) where the &lt;idref/&gt; element brings value is
          in the configuration of <a href="aop-api.html#aop-pfb-1" title="7.5.1.&nbsp;Basics">AOP
          interceptors</a> in a <tt class="classname">ProxyFactoryBean</tt>
          bean definition. If you use &lt;idref/&gt; elements when specifying
          the interceptor names, there is no chance of inadvertently
          misspelling an interceptor id.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-ref-element"></a>3.3.2.2.&nbsp;References to other beans (collaborators)</h4></div></div><div></div></div><p>The <tt class="literal">ref</tt> element is the final element allowed
        inside a <tt class="literal">&lt;constructor-arg/&gt;</tt> or
        <tt class="literal">&lt;property/&gt;</tt> definition element. It is used to
        set the value of the specified property to be a reference to another
        bean managed by the container (a collaborator). As mentioned in a
        previous section, the referred-to bean is considered to be a
        dependency of the bean who's property is being set, and will be
        initialized on demand as needed (if it is a singleton bean it may have
        already been initialized by the container) before the property is set.
        All references are ultimately just a reference to another object, but
        there are 3 variations on how the id/name of the other object may be
        specified, which determines how scoping and validation is
        handled.</p><p>Specifying the target bean by using the <tt class="literal">bean</tt>
        attribute of the <tt class="literal">&lt;ref/&gt;</tt> tag is the most
        general form, and will allow creating a reference to any bean in the
        same container (whether or not in the same XML file), or parent
        container. The value of the <tt class="literal">'bean'</tt> attribute may be
        the same as either the <tt class="literal">'id'</tt> attribute of the target
        bean, or one of the values in the <tt class="literal">'name'</tt> attribute
        of the target bean.</p><pre class="programlisting">&lt;ref bean="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">local</tt>
        attribute leverages the ability of the XML parser to validate XML id
        references within the same file. The value of the
        <tt class="literal">local</tt> attribute must be the same as the
        <tt class="literal">id</tt> attribute of the target bean. The XML parser
        will issue an error if no matching element is found in the same file.
        As such, using the local variant is the best choice (in order to know
        about errors as early as possible) if the target bean is in the same
        XML file.</p><pre class="programlisting">&lt;ref local="someBean"/&gt;</pre><p>Specifying the target bean by using the
        <tt class="literal">'parent'</tt> attribute allows a reference to be created
        to a bean which is in a parent container of the current container. The
        value of the <tt class="literal">'parent'</tt> attribute may be the same as
        either the <tt class="literal">'id'</tt> attribute of the target bean, or
        one of the values in the <tt class="literal">'name'</tt> attribute of the
        target bean, and the target bean must be in a parent container to the
        current one. The main use of this bean reference variant is when you
        have a hierarchy of containers and you want to wrap an existing bean
        in a parent container with some sort of proxy which will have the same
        name as the parent bean.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the parent context --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the child (descendant) context --&gt;</span></i>
&lt;bean id="accountService"  <i class="lineannotation"><span class="lineannotation">&lt;-- notice that the name of this bean is the <span class="bold"><b>same</b></span> as the name of the <tt class="literal">'parent'</tt> bean</span></i>
      class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
      &lt;property name="target"&gt;
          &lt;ref parent="accountService"/&gt;  <i class="lineannotation"><span class="lineannotation">&lt;-- notice how we refer to the <span class="bold"><b>parent</b></span> bean</span></i>
      &lt;/property&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert other configuration and dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-inner-beans"></a>3.3.2.3.&nbsp;Inner beans</h4></div></div><div></div></div><p>A <tt class="literal">&lt;bean/&gt;</tt> element inside the
        <tt class="literal">&lt;property/&gt;</tt> or
        <tt class="literal">&lt;constructor-arg/&gt;</tt> elements is used to define
        a so-called <i class="firstterm">inner bean</i>. An inner bean
        definition does not need to have any id or name defined, and it is
        best not to even specify any id or name value because the id or name
        value simply will be ignored by the container.</p><pre class="programlisting">&lt;bean id="outer" class="..."&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></i>
  &lt;property name="target"&gt;
    &lt;bean class="com.example.Person"&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the inner bean --&gt;</span></i>
      &lt;property name="name" value="Fiona Apple"/&gt;
      &lt;property name="age" value="25"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the specific case of inner beans, the
        <tt class="literal">'scope'</tt> flag and any <tt class="literal">'id'</tt> or
        <tt class="literal">'name'</tt> attribute are effectively ignored. Inner
        beans are <span class="emphasis"><em>always</em></span> anonymous and they are
        <span class="emphasis"><em>always</em></span> scoped as <a href="beans.html#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototypes</a>. Please
        also note that it is <span class="emphasis"><em>not</em></span> possible to inject inner
        beans into collaborating beans other than the enclosing bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-collection-elements"></a>3.3.2.4.&nbsp;Collections</h4></div></div><div></div></div><p>The <tt class="literal">&lt;list/&gt;</tt>,
        <tt class="literal">&lt;set/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>, and
        <tt class="literal">&lt;props/&gt;</tt> elements allow properties and
        arguments of the Java <tt class="interfacename">Collection</tt> type
        <tt class="interfacename">List</tt>,
        <tt class="interfacename">Set</tt>,
        <tt class="interfacename">Map</tt>, and
        <tt class="interfacename">Properties</tt>, respectively, to be defined
        and set.</p><pre class="programlisting">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setAdminEmails(<tt class="classname">java.util.Properties</tt>) call --&gt;</span></i>
  &lt;property name="adminEmails"&gt;
    &lt;props&gt;
        &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt;
        &lt;prop key="support"&gt;support@example.org&lt;/prop&gt;
        &lt;prop key="development"&gt;development@example.org&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeList(<tt class="interfacename">java.util.List</tt>) call --&gt;</span></i>
  &lt;property name="someList"&gt;
    &lt;list&gt;
        &lt;value&gt;a list element followed by a reference&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeMap(<tt class="interfacename">java.util.Map</tt>) call --&gt;</span></i>
  &lt;property name="someMap"&gt;
    &lt;map&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;an entry&lt;/value&gt;
            &lt;/key&gt;
            &lt;value&gt;just some string&lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;a ref&lt;/value&gt;
            &lt;/key&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></i>
  &lt;property name="someSet"&gt;
    &lt;set&gt;
        &lt;value&gt;just some string&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The nested element style used this initial
        example tends to become quite verbose. Fortunately, there are
        attribute shortcuts for most elements, which you can read about in 
        <a href="beans.html#xml-config-shortcuts" title="3.3.2.6.&nbsp;Shortcuts and other convenience options for XML-based&#xA;        configuration metadata">Section&nbsp;3.3.2.6, &#8220;Shortcuts and other convenience options for XML-based
        configuration metadata&#8221;</a>.</p></td></tr></table></div><p><span class="emphasis"><em>Note that the value of a map key or value, or a set
        value, can also again be any of the following
        elements:</em></span></p><pre class="programlisting">bean | ref | idref | list | set | map | props | value | null</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-collection-elements-merging"></a>3.3.2.4.1.&nbsp;Collection merging</h5></div></div><div></div></div><p>As of Spring 2.0, the container also supports the
          <span class="emphasis"><em>merging</em></span> of collections. This allows an
          application developer to define a parent-style
          <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
          <tt class="literal">&lt;set/&gt;</tt> or <tt class="literal">&lt;props/&gt;</tt>
          element, and have child-style <tt class="literal">&lt;list/&gt;</tt>,
          <tt class="literal">&lt;map/&gt;</tt>, <tt class="literal">&lt;set/&gt;</tt> or
          <tt class="literal">&lt;props/&gt;</tt> elements inherit and override
          values from the parent collection; that is to say the child
          collection's values will be the result obtained from the merging of
          the elements of the parent and child collections, with the child's
          collection elements overriding values specified in the parent
          collection.</p><p><span class="emphasis"><em>Please note that this section on merging makes use
          of the parent-child bean mechanism. This concept has not yet been
          introduced, so readers unfamiliar with the concept of parent and
          child bean definitions may wish to read the <a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">relevant section</a>
          before continuing.</em></span></p><p>Find below an example of the collection merging
          feature:</p><pre class="programlisting">&lt;beans&gt;
&lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
    &lt;property name="adminEmails"&gt;
        &lt;props&gt;
            &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@example.com&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="child" parent="parent"&gt;
    &lt;property name="adminEmails"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- the merge is specified on the *child* collection definition --&gt;</span></i>
        &lt;props merge="true"&gt;
            &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;beans&gt;</pre><p>Notice the use of the <tt class="literal">merge=true</tt> attribute
          on the <tt class="literal">&lt;props/&gt;</tt> element of the
          <tt class="literal">adminEmails</tt> property of the
          <tt class="literal">child</tt> bean definition. When the
          <tt class="literal">child</tt> bean is actually resolved and instantiated
          by the container, the resulting instance will have an
          <tt class="literal">adminEmails</tt> <tt class="classname">Properties</tt>
          collection that contains the result of the merging of the child's
          <tt class="literal">adminEmails</tt> collection with the parent's
          <tt class="literal">adminEmails</tt> collection.</p><pre class="programlisting">administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</pre><p>Notice how the child <tt class="classname">Properties</tt>
          collection's value set will have inherited all the property elements
          from the parent <tt class="literal">&lt;props/&gt;</tt>. Notice also how
          the child's value for the <tt class="literal">support</tt> value overrides
          the value in the parent collection.</p><p>This merging behavior applies similarly to the
          <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
          and <tt class="literal">&lt;set/&gt;</tt> collection types. In the
          specific case of the <tt class="literal">&lt;list/&gt;</tt> element, the
          semantics associated with the <tt class="classname">List</tt> collection
          type, that is the notion of an <tt class="literal">ordered</tt> collection
          of values, is maintained; the parent's values will precede all of
          the child list's values. In the case of the
          <tt class="interfacename">Map</tt>,
          <tt class="interfacename">Set</tt>, and
          <tt class="interfacename">Properties</tt> collection types, there is
          no notion of ordering and hence no ordering semantics are in effect
          for the collection types that underlie the associated
          <tt class="interfacename">Map</tt>,
          <tt class="interfacename">Set</tt> and
          <tt class="interfacename">Properties</tt> implementation types used
          internally by the container.</p><p>Finally, some minor notes about the merging support are in
          order; you cannot merge different collection types (e.g. a
          <tt class="interfacename">Map</tt> and a
          <tt class="interfacename">List</tt>), and if you do attempt to do so
          an appropriate <tt class="classname">Exception</tt> will be thrown; and
          in case it is not immediately obvious, the
          <tt class="literal">'merge'</tt> attribute must be specified on the lower
          level, inherited, child definition; specifying the
          <tt class="literal">'merge'</tt> attribute on a parent collection
          definition is redundant and will not result in the desired merging;
          and (lastly), please note that this merging feature is only
          available in Spring 2.0 (and later versions).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-collection-elements-strongly-typed"></a>3.3.2.4.2.&nbsp;Strongly-typed collection (Java 5+ only)</h5></div></div><div></div></div><p>If you are using Java 5 or Java 6, you will be aware that it
          is possible to have strongly typed collections (using generic
          types). That is, it is possible to declare a
          <tt class="interfacename">Collection</tt> type such that it can only
          contain <tt class="classname">String</tt> elements (for example). If you
          are using Spring to dependency inject a strongly-typed
          <tt class="interfacename">Collection</tt> into a bean, you can take
          advantage of Spring's type-conversion support such that the elements
          of your strongly-typed <tt class="interfacename">Collection</tt>
          instances will be converted to the appropriate type prior to being
          added to the <tt class="interfacename">Collection</tt>.</p><pre class="programlisting">public class Foo {
                
    private Map&lt;String, Float&gt; accounts;
    
    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}</pre><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="accounts"&gt;
            &lt;map&gt;
                &lt;entry key="one" value="9.99"/&gt;
                &lt;entry key="two" value="2.75"/&gt;
                &lt;entry key="six" value="3.99"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>When the <tt class="literal">'accounts'</tt> property of the
          <tt class="literal">'foo'</tt> bean is being prepared for injection, the
          generics information about the element type of the strongly-typed
          <tt class="classname">Map&lt;String, Float&gt;</tt> is actually
          available via reflection, and so Spring's type conversion
          infrastructure will actually recognize the various value elements as
          being of type <tt class="classname">Float</tt> and so the string values
          <tt class="literal">'9.99', '2.75'</tt>, and <tt class="literal">'3.99'</tt>
          will be converted into an actual <tt class="classname">Float</tt>
          type.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-null-element"></a>3.3.2.5.&nbsp;<tt class="literal">Nulls</tt></h4></div></div><div></div></div><p>The <tt class="literal">&lt;null/&gt;</tt> element is used to handle
        <tt class="literal">null</tt> values. Spring treats empty arguments for
        properties and the like as empty <tt class="literal">Strings</tt>. The
        following XML-based configuration metadata snippet results in the
        email property being set to the empty <tt class="classname">String</tt>
        value ("")</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;value/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>This is equivalent to the following Java code:
        <tt class="methodname">exampleBean.setEmail("")</tt>. The special
        <tt class="literal">&lt;null&gt;</tt> element may be used to indicate a
        <tt class="literal">null</tt> value. For example:</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration is equivalent to the following Java
        code: <tt class="methodname">exampleBean.setEmail(null)</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml-config-shortcuts"></a>3.3.2.6.&nbsp;Shortcuts and other convenience options for XML-based
        configuration metadata</h4></div></div><div></div></div><p>The configuration metadata shown so far is a tad verbose. That
        is why there are several options available for you to limit the amount
        of XML you have to write to configure your components. The first is a
        shortcut to define values and references to other beans as part of a
        <tt class="literal">&lt;property/&gt;</tt> definition. The second is
        slightly different format of specifying properties altogether.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-value-ref-shortcuts"></a>3.3.2.6.1.&nbsp;XML-based configuration metadata shortcuts</h5></div></div><div></div></div><p>The <tt class="literal">&lt;property/&gt;</tt>,
          <tt class="literal">&lt;constructor-arg/&gt;</tt>, and
          <tt class="literal">&lt;entry/&gt;</tt> elements all support a
          <tt class="literal">'value'</tt> attribute which may be used instead of
          embedding a full <tt class="literal">&lt;value/&gt;</tt> element.
          Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</pre><pre class="programlisting">&lt;entry key="myKey"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" value="hello"/&gt;</pre><pre class="programlisting">&lt;constructor-arg value="hello"/&gt;</pre><pre class="programlisting">&lt;entry key="myKey" value="hello"/&gt;</pre><p>The <tt class="literal">&lt;property/&gt;</tt> and
          <tt class="literal">&lt;constructor-arg/&gt;</tt> elements support a
          similar shortcut <tt class="literal">'ref'</tt> attribute which may be
          used instead of a full nested <tt class="literal">&lt;ref/&gt;</tt>
          element. Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;ref bean="myBean"&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;ref bean="myBean"&gt;
&lt;/constructor-arg&gt;</pre><p>... are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" ref="myBean"/&gt;</pre><pre class="programlisting">&lt;constructor-arg ref="myBean"/&gt;</pre><p>Note however that the shortcut form is equivalent to a
          <tt class="literal">&lt;ref bean="xxx"&gt;</tt> element; there is no
          shortcut for <tt class="literal">&lt;ref local="xxx"</tt>&gt;. To enforce
          a strict local reference, you must use the long form.</p><p>Finally, the entry element allows a shortcut form to specify
          the key and/or value of the map, in the form of the
          <tt class="literal">'key'</tt> / <tt class="literal">'key-ref'</tt> and
          <tt class="literal">'value'</tt> / <tt class="literal">'value-ref'</tt>
          attributes. Therefore, the following:</p><pre class="programlisting">&lt;entry&gt;
  &lt;key&gt;
    &lt;ref bean="myKeyBean" /&gt;
  &lt;/key&gt;
  &lt;ref bean="myValueBean" /&gt;
&lt;/entry&gt;</pre><p>is equivalent to:</p><pre class="programlisting">&lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&gt;</pre><p>Again, the shortcut form is equivalent to a <tt class="literal">&lt;ref
          bean="xxx"&gt;</tt> element; there is no shortcut for
          <tt class="literal">&lt;ref local="xxx"</tt>&gt;.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-p-namespace"></a>3.3.2.6.2.&nbsp;The p-namespace and how to use it to configure
          properties</h5></div></div><div></div></div><p>The second option you have to limit the amount of XML you have
          to write to configure your components is to use the special
          "p-namespace". Spring 2.0 and later features support for extensible
          configuration formats <a href="xsd-config.html" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">using
          namespaces</a>. Those namespaces are all based on an XML Schema
          definition. In fact, the <tt class="literal">beans</tt> configuration
          format that you've been reading about is defined in an XML Schema
          document.</p><p>One special namespace is not defined in an XSD file, and only
          exists in the core of Spring itself. The so-called p-namespace
          doesn't need a schema definition and is an alternative way of
          configuring your properties differently than the way you have seen
          so far. Instead of using nested <tt class="literal">&lt;property/&gt;</tt>
          elements, using the p-namespace you can use attributes as part of
          the <tt class="literal">bean</tt> element that describe your property
          values. The values of the attributes will be taken as the values for
          your properties.</p><p>The following two XML snippets boil down to the same thing in
          the end: the first is using the standard XML format whereas the
          second example is using the p-namespace.</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;
    
    &lt;bean name="classic" class="com.example.ExampleBean"&gt;
        &lt;property name="email" value="foo@bar.com/&gt;
    &lt;/bean&gt;
    
    &lt;bean name="p-namespace" class="com.example.ExampleBean"
          p:email="foo@bar.com"/&gt;
&lt;/beans&gt;</pre><p>As you can see, we are including an attribute in the
          p-namespace called email in the bean definition - this is telling
          Spring that it should include a property declaration. As previously
          mentioned, the p-namespace doesn't have a schema definition, so the
          name of the attribute can be set to whatever name your property
          has.</p><p>This next example includes two more bean definitions that both
          have a reference to another bean:</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;
    
    &lt;bean name="john-classic" class="com.example.Person"&gt;
        &lt;property name="name" value="John Doe"/&gt;
        &lt;property name="spouse" ref="jane"/&gt;
    &lt;/bean&gt;

    &lt;bean name="john-modern" 
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/&gt;

    &lt;bean name="jane" class="com.example.Person"&gt;
        &lt;property name="name" value="Jane Doe"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>As you can see, this example doesn't only include a property
          value using the p-namespace, but also uses a special format to
          declare property references. Whereas the first bean definition uses
          <tt class="literal">&lt;property name="spouse" ref="jane"/&gt;</tt> to
          create a reference from bean <tt class="literal">john</tt> to bean
          <tt class="literal">jane</tt>, the second bean definition uses
          <tt class="literal">p:spouse-ref="jane"</tt> as an attribute to do the
          exact same thing. In this case '<tt class="literal">spouse</tt>' is the
          property name whereas the '<tt class="literal">-ref</tt>' part indicates
          that this is not a straight value but rather a reference to another
          bean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Please note that the p-namespace is not quite as flexible as
            the standard XML format - for example particular, the 'special'
            format used to declare property references will clash with
            properties that end in '<tt class="literal">Ref</tt>', whereas the
            standard XML format would have no problem there. We recommend that
            you choose carefully which approach you are going to use in your
            projects. You should also communicate this to your team members so
            you won't end up with XML documents using all three approaches at
            the same time. This will prevent people from not understanding the
            application because of different ways of configuring it, and will
            add to the overall consistency of your codebase.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-compound-property-names"></a>3.3.2.7.&nbsp;Compound property names</h4></div></div><div></div></div><p>Compound or nested property names are perfectly legal when
        setting bean properties, as long as all components of the path except
        the final property name are not <tt class="literal">null</tt>. Consider the
        following bean definition...</p><pre class="programlisting">&lt;bean id="foo" class="foo.Bar"&gt;
  &lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">foo</tt> bean has a <tt class="literal">fred</tt>
        property which has a <tt class="literal">bob</tt> property, which has a
        <tt class="literal">sammy</tt> property, and that final
        <tt class="literal">sammy</tt> property is being set to the value
        <tt class="literal">123</tt>. In order for this to work, the
        <tt class="literal">fred</tt> property of <tt class="literal">foo</tt>, and the
        <tt class="literal">bob</tt> property of <tt class="literal">fred</tt> must not be
        <tt class="literal">null</tt> be non-null after the bean is constructed, or
        a <tt class="exceptionname">NullPointerException</tt> will be
        thrown.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependson"></a>3.3.3.&nbsp;Using <tt class="literal">depends-on</tt></h3></div></div><div></div></div><p>For most situations, the fact that a bean is a dependency of
      another is expressed by the fact that one bean is set as a property of
      another. This is typically accomplished with the <a href="beans.html#beans-ref-element" title="3.3.2.2.&nbsp;References to other beans (collaborators)"><tt class="literal">&lt;ref/&gt;</tt>
      element</a> in XML-based configuration metadata. For the relatively
      infrequent situations where dependencies between beans are less direct
      (for example, when a static initializer in a class needs to be
      triggered, such as database driver registration), the
      <tt class="literal">'depends-on'</tt> attribute may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized. Find below an example of using the
      <tt class="literal">'depends-on'</tt> attribute to express a dependency on a
      single bean.</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="<span class="bold"><b>manager</b></span>"/&gt;

&lt;bean id="<span class="bold"><b>manager</b></span>" class="ManagerBean" /&gt;</pre><p>If you need to express a dependency on multiple beans, you can
      supply a list of bean names as the value of the
      <tt class="literal">'depends-on'</tt> attribute, with commas, whitespace and
      semicolons all valid delimiters, like so:</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
  &lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The '<tt class="literal">depends-on</tt>' attribute at the bean definition
        level is used not only to specify an initialization time dependency, but
        also to specify the corresponding destroy time dependency (in the case of
        <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a> beans
        only). Dependent beans that define a '<tt class="literal">depends-on</tt>'
        relationship with a given bean will be destroyed first - prior to the given
        bean itself being destroyed. As a consequence, '<tt class="literal">depends-on</tt>'
        may be used to control shutdown order too.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lazy-init"></a>3.3.4.&nbsp;Lazily-instantiated beans</h3></div></div><div></div></div><p>The default behavior for
      <tt class="interfacename">ApplicationContext</tt> implementations is to
      eagerly pre-instantiate all <tt class="literal">singleton</tt> beans at
      startup. Pre-instantiation means that an
      <tt class="interfacename">ApplicationContext</tt> will eagerly create
      and configure all of its <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a> beans as part
      of its initialization process. Generally this is <span class="emphasis"><em>a good
      thing</em></span>, because it means that any errors in the configuration
      or in the surrounding environment will be discovered immediately (as
      opposed to possibly hours or even days down the line).</p><p>However, there are times when this behavior is
      <span class="emphasis"><em>not</em></span> what is wanted. If you do not want a singleton
      bean to be pre-instantiated when using an
      <tt class="interfacename">ApplicationContext</tt>, you can selectively
      control this by marking a bean definition as lazy-initialized. A
      lazily-initialized bean indicates to the IoC container whether or not a
      bean instance should be created at startup or when it is first
      requested.</p><p>When configuring beans via XML, this lazy loading is controlled by
      the <tt class="literal">'lazy-init'</tt> attribute on the
      <tt class="literal">&lt;bean/&gt;</tt> element; for example:</p><pre class="programlisting">&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" <span class="bold"><b>lazy-init="true"</b></span>/&gt;

&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;</pre><p>When the above configuration is consumed by an
      <tt class="interfacename">ApplicationContext</tt>, the bean named
      <tt class="literal">'lazy'</tt> will <span class="emphasis"><em>not</em></span> be eagerly
      pre-instantiated when the
      <tt class="interfacename">ApplicationContext</tt> is starting up,
      whereas the <tt class="literal">'not.lazy'</tt> bean will be eagerly
      pre-instantiated.</p><p>One thing to understand about lazy-initialization is that even
      though a bean definition may be marked up as being lazy-initialized, if
      the lazy-initialized bean is the dependency of a singleton bean that is
      not lazy-initialized, when the
      <tt class="interfacename">ApplicationContext</tt> is eagerly
      pre-instantiating the singleton, it will have to satisfy all of the
      singletons dependencies, one of which will be the lazy-initialized bean!
      So don't be confused if the IoC container creates one of the beans that
      you have explicitly configured as lazy-initialized at startup; all that
      means is that the lazy-initialized bean is being injected into a
      non-lazy-initialized singleton bean elsewhere.</p><p>It is also possible to control lazy-initialization at the
      container level by using the <tt class="literal">'default-lazy-init'</tt>
      attribute on the <tt class="literal">&lt;beans/&gt;</tt> element; for
      example:</p><pre class="programlisting">&lt;beans default-lazy-init="true"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- no beans will be pre-instantiated... --&gt;</span></i>
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-autowire"></a>3.3.5.&nbsp;Autowiring collaborators</h3></div></div><div></div></div><p>The Spring container is able to <span class="emphasis"><em>autowire</em></span>
      relationships between collaborating beans. This means that it is
      possible to automatically let Spring resolve collaborators (other beans)
      for your bean by inspecting the contents of the
      <tt class="interfacename">BeanFactory</tt>. The autowiring functionality
      has five modes. Autowiring is specified <span class="emphasis"><em>per</em></span> bean
      and can thus be enabled for some beans, while other beans will not be
      autowired. Using autowiring, it is possible to reduce or eliminate the
      need to specify properties or constructor arguments, thus saving a
      significant amount of typing. <sup>[<a name="d0e3240" href="#ftn.d0e3240">2</a>]</sup> When using XML-based configuration metadata, the autowire
      mode for a bean definition is specified by using the
      <tt class="literal">autowire</tt> attribute of the
      <tt class="literal">&lt;bean/&gt;</tt> element. The following values are
      allowed:</p><div class="table"><a name="beans-factory-autowiring-modes-tbl"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Autowiring modes</b></p><table summary="Autowiring modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>no</td><td><p>No autowiring at all. Bean references must be
              defined via a <tt class="literal">ref</tt> element. This is the
              default, and changing this is discouraged for larger
              deployments, since explicitly specifying collaborators gives
              greater control and clarity. To some extent, it is a form of
              documentation about the structure of a system.</p></td></tr><tr><td>byName</td><td><p>Autowiring by property name. This option will
              inspect the container and look for a bean named exactly the same
              as the property which needs to be autowired. For example, if you
              have a bean definition which is set to autowire by name, and it
              contains a <span class="emphasis"><em>master</em></span> property (that is, it has
              a <span class="emphasis"><em>setMaster(..)</em></span> method), Spring will look
              for a bean definition named <tt class="literal">master</tt>, and use
              it to set the property.</p></td></tr><tr><td>byType</td><td><p>Allows a property to be autowired if there is
              exactly one bean of the property type in the container. If there
              is more than one, a fatal exception is thrown, and this
              indicates that you may not use <span class="emphasis"><em>byType</em></span>
              autowiring for that bean. If there are no matching beans,
              nothing happens; the property is not set. If this is not
              desirable, setting the
              <tt class="literal">dependency-check="objects"</tt> attribute value
              specifies that an error should be thrown in this
              case.</p></td></tr><tr><td>constructor</td><td><p>This is analogous to <span class="emphasis"><em>byType</em></span>,
              but applies to constructor arguments. If there isn't exactly one
              bean of the constructor argument type in the container, a fatal
              error is raised.</p></td></tr><tr><td>autodetect</td><td><p>Chooses <span class="emphasis"><em>constructor</em></span> or
              <span class="emphasis"><em>byType</em></span> through introspection of the bean
              class. If a default constructor is found, the
              <span class="emphasis"><em>byType</em></span> mode will be applied.</p></td></tr></tbody></table></div><p>Note that explicit dependencies in <tt class="literal">property</tt> and
      <tt class="literal">constructor-arg</tt> settings
      <tt class="interfacename">always</tt> override autowiring. Please also
      note that it is not currently possible to autowire so-called
      <span class="emphasis"><em>simple</em></span> properties such as primitives,
      <tt class="classname">Strings</tt>, and <tt class="classname">Classes</tt> (and
      arrays of such simple properties). (This is by-design and should be
      considered a <span class="emphasis"><em>feature</em></span>.) When using either the
      <span class="emphasis"><em>byType</em></span> or <span class="emphasis"><em>constructor</em></span>
      autowiring mode, it is possible to wire arrays and typed-collections. In
      such cases <span class="emphasis"><em>all</em></span> autowire candidates within the
      container that match the expected type will be provided to satisfy the
      dependency. Strongly-typed Maps can even be autowired if the expected
      key type is <tt class="classname">String</tt>. An autowired Map's values
      will consist of all bean instances that match the expected type, and the
      Map's keys will contain the corresponding bean names.</p><p>Autowire behavior can be combined with dependency checking, which
      will be performed after all autowiring has been completed.</p><p>It is important to understand the various advantages and
      disadvantages of autowiring. Some advantages of autowiring
      include:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring can significantly reduce the volume of
          configuration required. However, mechanisms such as the use of a
          bean template (<a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">discussed elsewhere in this
          chapter</a>) are also valuable in this regard.</p></li><li><p>Autowiring can cause configuration to keep itself up to date
          as your objects evolve. For example, if you need to add an
          additional dependency to a class, that dependency can be satisfied
          automatically without the need to modify configuration. Thus there
          may be a strong case for autowiring during development, without
          ruling out the option of switching to explicit wiring when the code
          base becomes more stable.</p></li></ul></div><p>Some disadvantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring is more magical than explicit wiring. Although, as
          noted in the above table, Spring is careful to avoid guessing in
          case of ambiguity which might have unexpected results, the
          relationships between your Spring-managed objects are no longer
          documented explicitly.</p></li><li><p>Wiring information may not be available to tools that may
          generate documentation from a Spring container.</p></li></ul></div><p>Another issue to consider when autowiring by type is that multiple
      bean definitions within the container may match the type specified by
      the setter method or constructor argument to be autowired. For arrays,
      collections, or Maps, this is not necessarily a problem. However for
      dependencies that expect a single value, this ambiguity will not be
      arbitrarily resolved. Instead, if no unique bean definition is
      available, an Exception will be thrown. You do have several options when
      confronted with this scenario. First, you may abandon autowiring in
      favor of explicit wiring. Second, you may designate that certain bean
      definitions are never to be considered as candidates by setting their
      <tt class="literal">'autowire-candidate'</tt> attributes to
      <tt class="literal">'false'</tt> as described in the next section. Third, you
      may designate a single bean definition as the
      <span class="emphasis"><em>primary</em></span> candidate by setting the
      <tt class="literal">'primary'</tt> attribute of its
      <tt class="literal">&lt;bean/&gt;</tt> element to <tt class="literal">'true'</tt>.
      Finally, if you are using at least Java 5, you may be interested in
      exploring the more fine-grained control available with annotation-based
      configuration as described in the section entitled <a href="beans.html#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>.</p><p>When deciding whether to use autowiring, there is no wrong or
      right answer in all cases. A degree of consistency across a project is
      best though; for example, if autowiring is not used in general, it might
      be confusing to developers to use it just to wire one or two bean
      definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-autowire-candidate"></a>3.3.5.1.&nbsp;Excluding a bean from being available for autowiring</h4></div></div><div></div></div><p>You can also (on a per-bean basis) totally exclude a bean from
        being an autowire candidate. When configuring beans using Spring's XML
        format, the <tt class="literal">'autowire-candidate'</tt> attribute of the
        <tt class="literal">&lt;bean/&gt;</tt> element can be set to
        <tt class="literal">'false'</tt>; this has the effect of making the
        container totally exclude that specific bean definition from being
        available to the autowiring infrastructure.</p><p>Another option is to limit autowire candidates based on
        pattern-matching against bean names. The top-level
        <tt class="literal">&lt;beans/&gt;</tt> element accepts one or more patterns
        within its <tt class="literal">'default-autowire-candidates'</tt> attribute.
        For example, to limit autowire candidate status to any bean whose name
        ends with <span class="emphasis"><em>'Repository'</em></span>, provide a value of
        '*Repository'. To provide multiple patterns, define them in a
        comma-separated list. Note that an explicit value of
        <tt class="literal">'true'</tt> or <tt class="literal">'false'</tt> for a bean
        definition's <tt class="literal">'autowire-candidate'</tt> attribute always
        takes precedence, and for such beans, the pattern matching rules will
        not apply.</p><p>These techniques can be useful when you have one or more beans
        that you absolutely never ever want to have injected into other beans
        via autowiring. It does not mean that an excluded bean cannot itself
        be configured using autowiring... it can, it is rather that it itself
        will not be considered as a candidate for autowiring other
        beans.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependencies"></a>3.3.6.&nbsp;Checking for dependencies</h3></div></div><div></div></div><p>The Spring IoC container also has the ability to check for the
      existence of unresolved dependencies of a bean deployed into the
      container. These are JavaBeans properties of the bean, which do not have
      actual values set for them in the bean definition, or alternately
      provided automatically by the autowiring feature.</p><p>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <span class="emphasis"><em>not</em></span> check dependencies. Dependency
      checking can be handled in several different modes. When using XML-based
      configuration metadata, this is specified via the
      <tt class="literal">'dependency-check'</tt> attribute in a bean definition,
      which may have the following values.</p><div class="table"><a name="beans-factory-dependency-check-modes-tbl"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Dependency checking modes</b></p><table summary="Dependency checking modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>none</td><td><p>No dependency checking. Properties of the bean
              which have no value specified for them are simply not
              set.</p></td></tr><tr><td>simple</td><td><p>Dependency checking is performed for primitive
              types and collections (everything except
              collaborators).</p></td></tr><tr><td>object</td><td><p>Dependency checking is performed for collaborators
              only.</p></td></tr><tr><td>all</td><td><p>Dependency checking is done for collaborators,
              primitive types and collections.</p></td></tr></tbody></table></div><p>If you are using Java 5 and thus have access to source-level
      annotations, you may find the section entitled <a href="metadata.html#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a> to be of interest.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-method-injection"></a>3.3.7.&nbsp;Method Injection</h3></div></div><div></div></div><p>For most application scenarios, the majority of the beans in the
      container will be <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singletons</a>. When a
      singleton bean needs to collaborate with another singleton bean, or a
      non-singleton bean needs to collaborate with another non-singleton bean,
      the typical and common approach of handling this dependency by defining
      one bean to be a property of the other is quite adequate. There is a
      problem when the bean lifecycles are different. Consider a singleton
      bean A which needs to use a non-singleton (prototype) bean B, perhaps on
      each method invocation on A. The container will only create the
      singleton bean A once, and thus only get the opportunity to set the
      properties once. There is no opportunity for the container to provide
      bean A with a new instance of bean B every time one is needed.</p><p>One solution to this issue is to forego some inversion of control.
      Bean A can be <a href="beans.html#beans-factory-aware-beanfactoryaware" title="3.5.2.1.&nbsp;BeanFactoryAware">made
      aware of the container</a> by implementing the
      <tt class="interfacename">BeanFactoryAware</tt> interface, and <a href="beans.html#beans-factory-client" title="3.2.4.&nbsp;Using the container">use programmatic means</a> to ask the
      container via a <tt class="methodname">getBean("B")</tt> call for (a
      typically new) bean B instance every time it needs it. Find below an
      admittedly somewhat contrived example of this approach:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// a class that uses a stateful Command-style class to perform some processing</span></i>
package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// lots of Spring-API imports</span></i>
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;

public class CommandManager implements BeanFactoryAware {

   private BeanFactory beanFactory;

   public Object process(Map commandState) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt></span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">Command</tt> returned here could be an implementation that executes asynchronously, or whatever</span></i>
   protected Command createCommand() {
      return (Command) this.beanFactory.getBean("command"); <i class="lineannotation"><span class="lineannotation">// notice the Spring API dependency</span></i>
   }

   public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
   }
}</pre><p>The above example is generally not a desirable solution since the
      business code is then aware of and coupled to the Spring Framework.
      Method Injection, a somewhat advanced feature of the Spring IoC
      container, allows this use case to be handled in a clean fashion.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lookup-method-injection"></a>3.3.7.1.&nbsp;Lookup method injection</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Isn't this Method Injection...</b></p><p>... somewhat like Tapestry 4.0's pages, where folks wrote
          <tt class="literal">abstract</tt> properties that Tapestry would override
          at runtime with implementations that did stuff? It sure is (well,
          somewhat).</p><p>You can read more about the motivation for Method Injection in
          <a href="http://blog.springframework.com/rod/?p=1" target="_top">this blog
          entry</a>.</p></div><p>Lookup method injection refers to the ability of the container
        to override methods on <span class="emphasis"><em>container managed beans</em></span>,
        to return the result of looking up another named bean in the
        container. The lookup will typically be of a prototype bean as in the
        scenario described above. The Spring Framework implements this method
        injection by dynamically generating a subclass overriding the method,
        using bytecode generation via the CGLIB library.</p><p>So if you look at the code from previous code snippet (the
        <tt class="classname">CommandManager</tt> class), the Spring container is
        going to dynamically override the implementation of the
        <tt class="methodname">createCommand()</tt> method. Your
        <tt class="classname">CommandManager</tt> class is not going to have any
        Spring dependencies, as can be seen in this reworked example
        below:</p><pre class="programlisting">package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// no more Spring imports! </span></i>

public abstract class CommandManager {

   public Object process(Object commandState) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt> interface</span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

    <i class="lineannotation"><span class="lineannotation">// okay... but where is the implementation of this method?</span></i>
   protected abstract Command createCommand();
}</pre><p>In the client class containing the method to be injected (the
        <tt class="classname">CommandManager</tt> in this case), the method that
        is to be 'injected' must have a signature of the following
        form:</p><pre class="programlisting">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(<i class="lineannotation"><span class="lineannotation">no-arguments</span></i>);</pre><p>If the method is <tt class="literal">abstract</tt>, the
        dynamically-generated subclass will implement the method. Otherwise,
        the dynamically-generated subclass will override the concrete method
        defined in the original class. Let's look at an example:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></i>
&lt;bean id="command" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies here as required --&gt;</span></i>
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">commandProcessor</tt> uses <tt class="literal">statefulCommandHelper</tt> --&gt;</span></i>
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
  &lt;lookup-method name="createCommand" bean="command"/&gt;
&lt;/bean&gt;</pre><p>The bean identified as <span class="emphasis"><em>commandManager</em></span> will
        call its own method <tt class="methodname">createCommand()</tt> whenever
        it needs a new instance of the <span class="emphasis"><em>command</em></span> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy the <tt class="literal">command</tt> bean as a prototype
        (if that is actually what is needed). If it is deployed as a <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a>, the same
        instance of the <tt class="literal">command</tt> bean will be returned each
        time!</p><p>Please be aware that in order for this dynamic subclassing to
        work, you will need to have the CGLIB jar(s) on your classpath.
        Additionally, the class that the Spring container is going to subclass
        cannot be <tt class="literal">final</tt>, and the method that is being
        overridden cannot be <tt class="literal">final</tt> either. Also, testing a
        class that has an <tt class="literal">abstract</tt> method can be somewhat
        odd in that you will have to subclass the class yourself and supply a
        stub implementation of the <tt class="literal">abstract</tt> method.
        Finally, objects that have been the target of method injection cannot
        be serialized.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The interested reader may also find the
          <tt class="classname">ServiceLocatorFactoryBean</tt> (in the
          <tt class="literal">org.springframework.beans.factory.config</tt> package)
          to be of use; the approach is similar to that of the
          <tt class="classname">ObjectFactoryCreatingFactoryBean</tt>, but it
          allows you to specify your own lookup interface as opposed to having
          to use a Spring-specific lookup interface such as the
          <tt class="interfacename">ObjectFactory</tt>. Consult the (copious)
          Javadoc for the <tt class="classname">ServiceLocatorFactoryBean</tt> for
          a full treatment of this alternative approach (that
          <span class="emphasis"><em>does</em></span> reduce the coupling to Spring).</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-arbitrary-method-replacement"></a>3.3.7.2.&nbsp;Arbitrary method replacement</h4></div></div><div></div></div><p>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</p><p>When using XML-based configuration metadata, the
        <tt class="literal">replaced-method</tt> element may be used to replace an
        existing method implementation with another, for a deployed bean.
        Consider the following class, with a method computeValue, which we
        want to override:</p><pre class="programlisting">public class MyValueCalculator {

  public String computeValue(String input) {
    <i class="lineannotation"><span class="lineannotation">// some real code...</span></i>
  }

  <i class="lineannotation"><span class="lineannotation">// some other methods...</span></i>

}</pre><p>A class implementing the
        <tt class="interfacename">org.springframework.beans.factory.support.MethodReplacer</tt>
        interface provides the new method definition.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">/** meant to be used to override the existing <tt class="methodname">computeValue(String)</tt>
    implementation in <tt class="classname">MyValueCalculator</tt>
  */</span></i>
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        <i class="lineannotation"><span class="lineannotation">// get the input value, work with it, and return a computed result</span></i>
        String input = (String) args[0];
        ... 
        return ...;
    }
}</pre><p>The bean definition to deploy the original class and specify the
        method override would look like this:</p><pre class="programlisting">&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- arbitrary method replacement --&gt;</span></i>
  &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
    &lt;arg-type&gt;String&lt;/arg-type&gt;
  &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</pre><p>One or more contained <tt class="literal">&lt;arg-type/&gt;</tt>
        elements within the <tt class="literal">&lt;replaced-method/&gt;</tt>
        element may be used to indicate the method signature of the method
        being overridden. Note that the signature for the arguments is
        actually only needed in the case that the method is actually
        overloaded and there are multiple variants within the class. For
        convenience, the type string for an argument may be a substring of the
        fully qualified type name. For example, all the following would match
        <tt class="classname">java.lang.String</tt>.</p><pre class="programlisting">    java.lang.String
    String
    Str</pre><p>Since the number of arguments is often enough to distinguish
        between each possible choice, this shortcut can save a lot of typing,
        by allowing you to type just the shortest string that will match an
        argument type.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-scopes"></a>3.4.&nbsp;Bean scopes</h2></div></div><div></div></div><p>When you create a bean definition what you are actually creating is
    a <span class="emphasis"><em>recipe</em></span> for creating actual instances of the class
    defined by that bean definition. The idea that a bean definition is a
    recipe is important, because it means that, just like a class, you can
    potentially have many object instances created from a single
    recipe.</p><p>You can control not only the various dependencies and configuration
    values that are to be plugged into an object that is created from a
    particular bean definition, but also the <i class="firstterm">scope</i> of
    the objects created from a particular bean definition. This approach is
    very powerful and gives you the flexibility to <span class="emphasis"><em>choose</em></span>
    the scope of the objects you create through configuration instead of
    having to 'bake in' the scope of an object at the Java class level. Beans
    can be defined to be deployed in one of a number of scopes: out of the
    box, the Spring Framework supports exactly five scopes (of which three are
    available only if you are using a web-aware
    <tt class="interfacename">ApplicationContext</tt>).</p><p>The scopes supported out of the box are listed below:</p><div class="table"><a name="beans-factory-scopes-tbl"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Bean scopes</b></p><table summary="Bean scopes" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Scope</th><th align="center">Description</th></tr></thead><tbody><tr><td><p>
                <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a>
              </p></td><td><p>Scopes a single bean definition to a single object
              instance per Spring IoC container.</p></td></tr><tr><td><p>
                <a href="beans.html#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototype</a>
              </p></td><td><p>Scopes a single bean definition to any number of object
              instances.</p></td></tr><tr><td><p>
                <a href="beans.html#beans-factory-scopes-request" title="3.4.4.2.&nbsp;The request scope">request</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a
              single HTTP request; that is each and every HTTP request will
              have its own instance of a bean created off the back of a single
              bean definition. Only valid in the context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p>
                <a href="beans.html#beans-factory-scopes-global-session" title="3.4.4.4.&nbsp;The global session scope">session</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a HTTP
              <tt class="interfacename">Session</tt>. Only valid in the
              context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p>
                <a href="beans.html#beans-factory-scopes-global-session" title="3.4.4.4.&nbsp;The global session scope">global
                session</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a
              global HTTP <tt class="interfacename">Session</tt>. Typically
              only valid when used in a portlet context. Only valid in the
              context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-singleton"></a>3.4.1.&nbsp;The singleton scope</h3></div></div><div></div></div><p>When a bean is a singleton, only one <span class="emphasis"><em>shared</em></span>
      instance of the bean will be managed, and all requests for beans with an
      id or <tt class="literal">id</tt>s matching that bean definition will result
      in that one specific bean instance being returned by the Spring
      container.</p><p>To put it another way, when you define a bean definition and it is
      scoped as a singleton, then the Spring IoC container will create
      <span class="emphasis"><em>exactly one</em></span> instance of the object defined by that
      bean definition. This single instance will be stored in a cache of such
      singleton beans, and <span class="emphasis"><em>all subsequent requests and
      references</em></span> for that named bean will result in the cached
      object being returned.</p><p>
        </p><div class="mediaobject" align="center"><img src="images/singleton.png" align="middle"></div><p>
      </p><p>Please be aware that Spring's concept of a singleton bean is quite
      different from the Singleton pattern as defined in the seminal Gang of
      Four (GoF) patterns book. The GoF Singleton hard codes the scope of an
      object such that one <span class="emphasis"><em>and only one</em></span> instance of a
      particular class will ever be created<span class="emphasis"><em> per
      <tt class="classname">ClassLoader</tt></em></span>. The scope of the Spring
      singleton is best described as <span class="emphasis"><em>per container and per
      bean</em></span>. This means that if you define one bean for a particular
      class in a single Spring container, then the Spring container will
      create one <span class="emphasis"><em>and only one</em></span> instance of the class
      defined by that bean definition. <span class="emphasis"><em>The singleton scope is the
      default scope in Spring</em></span>. To define a bean as a singleton in
      XML, you would write configuration like so:</p><pre class="programlisting">&lt;bean id="accountService" class="com.foo.DefaultAccountService"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent, though redundant (singleton scope is the default); using <tt class="literal">spring-beans-2.0.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="singleton"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent and preserved for backward compatibility in <tt class="literal">spring-beans.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="true"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-prototype"></a>3.4.2.&nbsp;The prototype scope</h3></div></div><div></div></div><p>The non-singleton, prototype scope of bean deployment results in
      the <span class="emphasis"><em>creation of a new bean instance</em></span> every time a
      request for that specific bean is made (that is, it is injected into
      another bean or it is requested via a programmatic
      <tt class="literal">getBean()</tt> method call on the container). As a rule of
      thumb, you should use the prototype scope for all beans that are
      stateful, while the singleton scope should be used for stateless
      beans.</p><p>The following diagram illustrates the Spring prototype scope.
      <span class="emphasis"><em>Please note that a DAO would not typically be configured as a
      prototype, since a typical DAO would not hold any conversational state;
      it was just easier for this author to reuse the core of the singleton
      diagram.</em></span></p><p>
        </p><div class="mediaobject" align="center"><img src="images/prototype.png" align="middle"></div><p>
      </p><p>To define a bean as a prototype in XML, you would write
      configuration like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- using <tt class="literal">spring-beans-2.0.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="prototype"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent and preserved for backward compatibility in <tt class="literal">spring-beans.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="false"/&gt;</pre><p>There is one quite important thing to be aware of when deploying a
      bean in the prototype scope, in that the lifecycle of the bean changes
      slightly. Spring does not manage the complete lifecycle of a prototype
      bean: the container instantiates, configures, decorates and otherwise
      assembles a prototype object, hands it to the client and then has no
      further knowledge of that prototype instance. This means that while
      <span class="emphasis"><em>initialization</em></span> lifecycle callback methods will be
      called on all objects regardless of scope, in the case of prototypes,
      any configured <span class="emphasis"><em>destruction</em></span> lifecycle callbacks will
      <span class="emphasis"><em>not</em></span> be called. It is the responsibility of the
      client code to clean up prototype scoped objects and release any
      expensive resources that the prototype bean(s) are holding onto. (One
      possible way to get the Spring container to release resources used by
      prototype-scoped beans is through the use of a custom <a href="beans.html#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors">bean post-processor</a> which
      would hold a reference to the beans that need to be cleaned up.)</p><p>In some respects, you can think of the Spring containers role when
      talking about a prototype-scoped bean as somewhat of a replacement for
      the Java <tt class="literal">'new'</tt> operator. All lifecycle aspects past
      that point have to be handled by the client. (The lifecycle of a bean in
      the Spring container is further described in the section entitled <a href="beans.html#beans-factory-lifecycle" title="3.5.1.&nbsp;Lifecycle callbacks">Section&nbsp;3.5.1, &#8220;Lifecycle callbacks&#8221;</a>.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-sing-prot-interaction"></a>3.4.3.&nbsp;Singleton beans with prototype-bean dependencies</h3></div></div><div></div></div><p>When using singleton-scoped beans that have dependencies on beans
      that are scoped as prototypes, please be aware that
      <span class="emphasis"><em>dependencies are resolved at instantiation time</em></span>.
      This means that if you dependency inject a prototype-scoped bean into a
      singleton-scoped bean, a brand new prototype bean will be instantiated
      and then dependency injected into the singleton bean... <span class="emphasis"><em>but
      that is all</em></span>. That exact same prototype instance will be the
      sole instance that is ever supplied to the singleton-scoped bean, which
      is fine if that is what you want.</p><p>However, sometimes what you actually want is for the
      singleton-scoped bean to be able to acquire a brand new instance of the
      prototype-scoped bean again and again and again at runtime. In that case
      it is no use just dependency injecting a prototype-scoped bean into your
      singleton bean, because as explained above, that only happens
      <span class="emphasis"><em>once</em></span> when the Spring container is instantiating the
      singleton bean and resolving and injecting its dependencies. If you are
      in the scenario where you need to get a brand new instance of a
      (prototype) bean again and again and again at runtime, you are referred
      to the section entitled <a href="beans.html#beans-factory-method-injection" title="3.3.7.&nbsp;Method Injection">Section&nbsp;3.3.7, &#8220;Method Injection&#8221;</a></p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Backwards compatibility note: specifying the lifecycle scope in&#xA;      XML"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Backwards compatibility note: specifying the lifecycle scope in
      XML</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are referencing the <tt class="filename">'spring-beans.dtd'</tt>
      DTD in a bean definition file(s), and you are being explicit about the
      lifecycle scope of your beans you must use the
      "<tt class="literal">singleton</tt>" attribute to express the lifecycle scope
      (remembering that the <a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton lifecycle
      scope</a> is the default). If you are referencing the
      <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD or the Spring 2.0 XSD
      schema, then you will need to use the "<tt class="literal">scope</tt>"
      attribute (because the "<tt class="literal">singleton</tt>" attribute was
      removed from the definition of the new DTD and XSD files in favor of the
      "<tt class="literal">scope</tt>" attribute).</p><p>To be totally clear about this, this means that if you use the
      "<tt class="literal">singleton</tt>" attribute in an XML bean definition then
      you <span class="emphasis"><em>must</em></span> be referencing the
      <tt class="filename">'spring-beans.dtd'</tt> DTD <span class="emphasis"><em>in that
      file</em></span>. If you are using the "<tt class="literal">scope</tt>"
      attribute then you <span class="emphasis"><em>must</em></span> be referencing either the
      <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD or the
      <tt class="filename">'spring-beans-2.5.xsd'</tt> XSD <span class="emphasis"><em>in that
      file</em></span>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-other"></a>3.4.4.&nbsp;The other scopes</h3></div></div><div></div></div><p>The other scopes, namely <tt class="literal">request</tt>,
      <tt class="literal">session</tt>, and <tt class="literal">global session</tt> are
      for use only in web-based applications (and can be used irrespective of
      which particular web application framework you are using, if indeed
      any). In the interest of keeping related concepts together in one place
      in the reference documentation, these scopes are described here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The scopes that are described in the following paragraphs are
        <span class="emphasis"><em>only</em></span> available if you are using a web-aware
        Spring <tt class="interfacename">ApplicationContext</tt>
        implementation (such as
        <tt class="classname">XmlWebApplicationContext</tt>). If you try using
        these next scopes with regular Spring IoC containers such as the
        <tt class="classname">XmlBeanFactory</tt> or
        <tt class="classname">ClassPathXmlApplicationContext</tt>, you
        <span class="emphasis"><em>will</em></span> get an
        <tt class="classname">IllegalStateException</tt> complaining about an
        unknown bean scope.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-web-configuration"></a>3.4.4.1.&nbsp;Initial web configuration</h4></div></div><div></div></div><p>In order to support the scoping of beans at the
        <tt class="literal">request</tt>, <tt class="literal">session</tt>, and
        <tt class="literal">global session</tt> levels (web-scoped beans), some
        minor initial configuration is required before you can set about
        defining your bean definitions. Please note that this extra setup is
        <span class="emphasis"><em>not</em></span> required if you just want to use the
        'standard' scopes (namely singleton and prototype).</p><p>Now as things stand, there are a couple of ways to effect this
        initial setup depending on your particular Servlet
        environment...</p><p>If you are accessing scoped beans within Spring Web MVC, i.e.
        within a request that is processed by the Spring
        <tt class="classname">DispatcherServlet</tt>, or
        <tt class="classname">DispatcherPortlet</tt>, then no special setup is
        necessary: <tt class="classname">DispatcherServlet</tt> and
        <tt class="classname">DispatcherPortlet</tt> already expose all relevant
        state.</p><p>When using a Servlet 2.4+ web container, with requests processed
        outside of Spring's DispatcherServlet (e.g. when using JSF or Struts),
        you need to add the following
        <tt class="interfacename">javax.servlet.ServletRequestListener</tt> to
        the declarations in your web application's
        <tt class="literal">'web.xml'</tt> file.</p><pre class="programlisting">&lt;web-app&gt;
  ...
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  ...
&lt;/web-app&gt;</pre><p>If you are using an older web container (Servlet 2.3), you will
        need to use the provided
        <tt class="interfacename">javax.servlet.Filter</tt> implementation.
        Find below a snippet of XML configuration that has to be included in
        the <tt class="literal">'web.xml'</tt> file of your web application if you
        want to have access to web-scoped beans in requests outside of
        Spring's DispatcherServlet on a Servlet 2.3 container. (The filter
        mapping depends on the surrounding web application configuration and
        so you will have to change it as appropriate.)</p><pre class="programlisting">&lt;web-app&gt;
  ..
  &lt;filter&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
  &lt;/filter&gt; 
  &lt;filter-mapping&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  ...
&lt;/web-app&gt;</pre><p>That's it. <tt class="classname">DispatcherServlet</tt>,
        <tt class="classname">RequestContextListener</tt> and
        <tt class="classname">RequestContextFilter</tt> all do exactly the same
        thing, namely bind the HTTP request object to the
        <tt class="classname">Thread</tt> that is servicing that request. This
        makes beans that are request- and session-scoped available further
        down the call chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-request"></a>3.4.4.2.&nbsp;The request scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="loginAction" class="com.foo.LoginAction" scope="request"/&gt;</pre><p>With the above bean definition in place, the Spring container
        will create a brand new instance of the
        <tt class="classname">LoginAction</tt> bean using the
        <tt class="literal">'loginAction'</tt> bean definition for each and every
        HTTP request. That is, the <tt class="literal">'loginAction'</tt> bean will
        be effectively scoped at the HTTP request level. You can change or
        dirty the internal state of the instance that is created as much as
        you want, safe in the knowledge that other requests that are also
        using instances created off the back of the same
        <tt class="literal">'loginAction'</tt> bean definition will not be seeing
        these changes in state since they are particular to an individual
        request. When the request is finished processing, the bean that is
        scoped to the request will be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-session"></a>3.4.4.3.&nbsp;The session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;</pre><p>With the above bean definition in place, the Spring container
        will create a brand new instance of the
        <tt class="classname">UserPreferences</tt> bean using the
        <tt class="literal">'userPreferences'</tt> bean definition for the lifetime
        of a single HTTP <tt class="interfacename">Session</tt>. In other
        words, the <tt class="literal">'userPreferences'</tt> bean will be
        effectively scoped at the HTTP <tt class="interfacename">Session</tt>
        level. Just like <tt class="literal">request-scoped</tt> beans, you can
        change the internal state of the instance that is created as much as
        you want, safe in the knowledge that other HTTP
        <tt class="interfacename">Session</tt> instances that are also using
        instances created off the back of the same
        <tt class="literal">'userPreferences'</tt> bean definition will not be
        seeing these changes in state since they are particular to an
        individual HTTP <tt class="interfacename">Session</tt>. When the HTTP
        <tt class="interfacename">Session</tt> is eventually discarded, the
        bean that is scoped to that particular HTTP
        <tt class="interfacename">Session</tt> will also be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-global-session"></a>3.4.4.4.&nbsp;The global session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/&gt;</pre><p>The <tt class="literal">global session</tt> scope is similar to the
        standard HTTP <tt class="interfacename">Session</tt> scope (<a href="beans.html#beans-factory-scopes-session" title="3.4.4.3.&nbsp;The session scope">described immediately
        above</a>), and really only makes sense in the context of
        portlet-based web applications. The portlet specification defines the
        notion of a global <tt class="interfacename">Session</tt> that is
        shared amongst all of the various portlets that make up a single
        portlet web application. Beans defined at the <tt class="literal">global
        session</tt> scope are scoped (or bound) to the lifetime of the
        global portlet <tt class="interfacename">Session</tt>.</p><p>Please note that if you are writing a standard Servlet-based web
        application and you define one or more beans as having <tt class="literal">global
        session</tt> scope, the standard HTTP
        <tt class="interfacename">Session</tt> scope will be used, and no
        error will be raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-injection"></a>3.4.4.5.&nbsp;Scoped beans as dependencies</h4></div></div><div></div></div><p>Being able to define a bean scoped to a HTTP request or
        <tt class="interfacename">Session</tt> (or indeed <a href="beans.html#beans-factory-scopes-custom" title="3.4.5.&nbsp;Custom scopes">a custom scope</a> of your
        own devising) is all very well, but one of the main value-adds of the
        Spring IoC container is that it manages not only the instantiation of
        your objects (beans), but also the wiring up of collaborators (or
        dependencies). If you want to inject a (for example) HTTP request
        scoped bean into another bean, you will need to inject an AOP proxy in
        place of the scoped bean. That is, you need to inject a proxy object
        that exposes the same public interface as the scoped object, but that
        is smart enough to be able to retrieve the real, target object from
        the relevant scope (for example a HTTP request) and delegate method
        calls onto the real object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You <span class="emphasis"><em>do not</em></span> need to use the
          <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> in conjunction with
          beans that are scoped as <tt class="literal">singletons</tt> or
          <tt class="literal">prototypes</tt>. It is an error to try to create a
          scoped proxy for a singleton bean (and the resulting
          <tt class="exceptionname">BeanCreationException</tt> will certainly
          set you straight in this regard).</p></td></tr></table></div><p>Let's look at the configuration that is required to effect this;
        the configuration is not hugely complex (it takes just one line), but
        it is important to understand the &#8220;<span class="quote">why</span>&#8221; as well as the
        &#8220;<span class="quote">how</span>&#8221; behind it.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- a HTTP <tt class="interfacename">Session</tt>-scoped bean exposed as a proxy --&gt;</span></i>
    &lt;bean id="userPreferences" class="com.foo.UserPreferences" <span class="bold"><b>scope="session"</b></span>&gt;
          
          <i class="lineannotation"><span class="lineannotation">&lt;!-- this next element effects the proxying of the surrounding bean --&gt;</span></i>
          <span class="bold"><b>&lt;aop:scoped-proxy/&gt;</b></span>
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- a singleton-scoped bean <span class="bold"><b>injected with a proxy to the above bean</b></span> --&gt;</span></i>
    &lt;bean id="userService" class="com.foo.SimpleUserService"&gt;
    
        <i class="lineannotation"><span class="lineannotation">&lt;!-- a reference to the <span class="bold"><b>proxied</b></span> <tt class="literal">'userPreferences'</tt> bean --&gt;</span></i>
        &lt;property name="userPreferences" ref="userPreferences"/&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</pre><p>To create such a proxy, you need only to insert a child
        <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element into a scoped
        bean definition (you may also need the CGLIB library on your classpath
        so that the container can effect class-based proxying; you will also
        need to be using <a href="xsd-config.html" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>). So, just why do you
        need this <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element in the
        definition of beans scoped at the <tt class="literal">request</tt>,
        <tt class="literal">session</tt>, <tt class="literal">globalSession</tt> and
        '<span class="emphasis"><em>insert your custom scope here</em></span>' level? The reason
        is best explained by picking apart the following bean definition
        (please note that the following <tt class="literal">'userPreferences'</tt>
        bean definition as it stands is
        <span class="emphasis"><em>incomplete</em></span>):</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><p>From the above configuration it is evident that the singleton
        bean <tt class="literal">'userManager'</tt> is being injected with a
        reference to the HTTP <tt class="interfacename">Session</tt>-scoped
        bean <tt class="literal">'userPreferences'</tt>. The salient point here is
        that the <tt class="literal">'userManager'</tt> bean is a singleton... it
        will be instantiated <span class="emphasis"><em>exactly once</em></span> per container,
        and its dependencies (in this case only one, the
        <tt class="literal">'userPreferences'</tt> bean) will also only be injected
        (once!). This means that the <tt class="literal">'userManager'</tt> will
        (conceptually) only ever operate on the exact same
        <tt class="literal">'userPreferences'</tt> object, that is the one that it
        was originally injected with. This is <span class="emphasis"><em>not</em></span> what
        you want when you inject a HTTP
        <tt class="interfacename">Session</tt>-scoped bean as a dependency
        into a collaborating object (typically). Rather, what we
        <span class="emphasis"><em>do</em></span> want is a single
        <tt class="literal">'userManager'</tt> object, and then, for the lifetime of
        a HTTP <tt class="interfacename">Session</tt>, we want to see and use
        a <tt class="literal">'userPreferences'</tt> object that is specific to said
        HTTP <tt class="interfacename">Session</tt>.</p><p>Rather what you need then is to inject some sort of object that
        exposes the exact same public interface as the
        <tt class="classname">UserPreferences</tt> class (ideally an object that
        <span class="emphasis"><em>is a</em></span> <tt class="classname">UserPreferences</tt>
        instance) and that is smart enough to be able to go off and fetch the
        <tt class="interfacename">real</tt>
        <tt class="classname">UserPreferences</tt> object from whatever underlying
        scoping mechanism we have chosen (HTTP request,
        <tt class="interfacename">Session</tt>, etc.). We can then safely
        inject this proxy object into the <tt class="literal">'userManager'</tt>
        bean, which will be blissfully unaware that the
        <tt class="classname">UserPreferences</tt> reference that it is holding
        onto is a proxy. In the case of this example, when a
        <tt class="interfacename">UserManager</tt> instance invokes a method
        on the dependency-injected <tt class="classname">UserPreferences</tt>
        object, it is really invoking a method on the proxy... the proxy will
        then go off and fetch the real <tt class="classname">UserPreferences</tt>
        object from (in this case) the HTTP
        <tt class="interfacename">Session</tt>, and delegate the method
        invocation onto the retrieved real
        <tt class="classname">UserPreferences</tt> object.</p><p>That is why you need the following, correct and complete,
        configuration when injecting <tt class="literal">request-</tt>,
        <tt class="literal">session-</tt>, and
        <tt class="literal">globalSession-scoped</tt> beans into collaborating
        objects:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"&gt;
    <span class="bold"><b><tt class="literal">&lt;aop:scoped-proxy/&gt;</tt></b></span>
&lt;/bean&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-scopes-other-injection-proxies"></a>3.4.4.5.1.&nbsp;Choosing the type of proxy created</h5></div></div><div></div></div><p>By default, when the Spring container is creating a proxy for
          a bean that is marked up with the <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt>
          element, <span class="emphasis"><em>a CGLIB-based class proxy will be created</em></span>.
          This means that you need to have the CGLIB library on the classpath
          of your application.</p><p><span class="emphasis"><em>Note: CGLIB proxies will only intercept public method
          calls!</em></span> Do not call non-public methods on such a proxy;
          they will not be delegated to the scoped target object.</p><p>You can choose to have the Spring container create 'standard'
          JDK interface-based proxies for such scoped beans by specifying
          '<tt class="literal">false</tt>' for the value of the
          '<tt class="literal">proxy-target-class</tt>' attribute of the
          <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element. Using JDK
          interface-based proxies does mean that you don't need any additional
          libraries on your application's classpath to effect such proxying,
          but it does mean that the class of the scoped bean must implement at
          least one interface, and <span class="emphasis"><em>all</em></span> of the
          collaborators into which the scoped bean is injected must be
          referencing the bean via one of its interfaces.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="classname">DefaultUserPreferences</tt> implements the <tt class="interfacename">UserPreferences</tt> interface --&gt;</span></i>
&lt;bean id="userPreferences" class="com.foo.DefaultUserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy <span class="bold"><b>proxy-target-class="false"<tt class="literal"></tt></b></span>/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><p>The section entitled <a href="aop.html#aop-proxying" title="6.6.&nbsp;Proxying mechanisms">Section&nbsp;6.6, &#8220;Proxying mechanisms&#8221;</a> may also
          be of some interest with regard to understanding the nuances of
          choosing whether class-based or interface-based proxying is right
          for you.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-custom"></a>3.4.5.&nbsp;Custom scopes</h3></div></div><div></div></div><p>As of Spring 2.0, the bean scoping mechanism in Spring is
      extensible. This means that you are not limited to just the bean scopes
      that Spring provides out of the box; you can define your own scopes, or
      even redefine the existing scopes (although that last one would probably
      be considered bad practice - please note that you
      <span class="emphasis"><em>cannot</em></span> override the built-in
      <tt class="literal">singleton</tt> and <tt class="literal">prototype</tt>
      scopes).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-custom-creating"></a>3.4.5.1.&nbsp;Creating your own custom scope</h4></div></div><div></div></div><p>Scopes are defined by the
        <tt class="interfacename">org.springframework.beans.factory.config.Scope</tt>
        interface. This is the interface that you will need to implement in
        order to integrate your own custom scope(s) into the Spring container,
        and is described in detail below. You may wish to look at the
        <tt class="interfacename">Scope</tt> implementations that are supplied
        with the Spring Framework itself for an idea of how to go about
        implementing your own. The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/Scope.html" target="_top">Scope
        Javadoc</a> explains the main class to implement when you need
        your own scope in more detail too.</p><p>The <tt class="literal">Scope</tt> interface has four methods dealing
        with getting objects from the scope, removing them from the scope and
        allowing them to be 'destroyed' if needed.</p><p>The first method should return the object from the underlying
        scope. The session scope implementation for example will return the
        session-scoped bean (and if it does not exist, return a new instance
        of the bean, after having bound it to the session for future
        reference).</p><pre class="programlisting">Object get(String name, ObjectFactory objectFactory)</pre><p>The second method should remove the object from the underlying
        scope. The session scope implementation for example, removes the
        session-scoped bean from the underlying session. The object should be
        returned (you are allowed to return null if the object with the
        specified name wasn't found)</p><pre class="programlisting">Object remove(String name)</pre><p>The third method is used to register callbacks the scope should
        execute when it is destroyed or when the specified object in the scope
        is destroyed. Please refer to the Javadoc or a Spring scope
        implementation for more information on destruction callbacks.</p><pre class="programlisting">void registerDestructionCallback(String name, Runnable destructionCallback)</pre><p>The last method deals with obtaining the conversation identifier
        for the underlying scope. This identifier is different for each scope.
        For a session for example, this can be the session identifier.</p><pre class="programlisting">String getConversationId()</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-custom-using"></a>3.4.5.2.&nbsp;Using a custom scope</h4></div></div><div></div></div><p>After you have written and tested one or more custom
        <tt class="interfacename">Scope</tt> implementations, you then need to
        make the Spring container aware of your new scope(s). The central
        method to register a new <tt class="interfacename">Scope</tt> with the
        Spring container is declared on the
        <tt class="interfacename">ConfigurableBeanFactory</tt> interface
        (implemented by most of the concrete
        <tt class="interfacename">BeanFactory</tt> implementations that ship
        with Spring); this central method is displayed below:</p><pre class="programlisting">void registerScope(String scopeName, Scope scope);</pre><p>The first argument to the
        <tt class="methodname">registerScope(..)</tt> method is the unique name
        associated with a scope; examples of such names in the Spring
        container itself are <tt class="literal">'singleton'</tt> and
        <tt class="literal">'prototype'</tt>. The second argument to the
        <tt class="methodname">registerScope(..)</tt> method is an actual
        instance of the custom <tt class="interfacename">Scope</tt>
        implementation that you wish to register and use.</p><p>Let's assume that you have written your own custom
        <tt class="interfacename">Scope</tt> implementation, and you have
        registered it like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// note: the <tt class="classname">ThreadScope</tt> class does <span class="bold"><b>not</b></span> ship with the Spring Framework</span></i>
Scope customScope = new ThreadScope();
beanFactory.registerScope("<span class="bold"><b>thread</b></span>", customScope);</pre><p>You can then create bean definitions that adhere to the scoping
        rules of your custom <tt class="interfacename">Scope</tt> like
        so:</p><pre class="programlisting">&lt;bean id="..." class="..." <span class="bold"><b>scope="thread"</b></span>/&gt;</pre><p>If you have your own custom <tt class="interfacename">Scope</tt>
        implementation(s), you are not just limited to only programmatic
        registration of the custom scope(s). You can also do the
        <tt class="interfacename">Scope</tt> registration declaratively, using
        the <tt class="classname">CustomScopeConfigurer</tt> class.</p><p>The declarative registration of custom
        <tt class="interfacename">Scope</tt> implementations using the
        <tt class="classname">CustomScopeConfigurer</tt> class is shown
        below:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
        &lt;property name="scopes"&gt;
            &lt;map&gt;<span class="bold"><b>
                &lt;entry key="thread"&gt;
                    &lt;bean class="com.foo.ThreadScope"/&gt;
                &lt;/entry&gt;</b></span>
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="bar" class="x.y.Bar" <span class="bold"><b>scope="thread"</b></span>&gt;
        &lt;property name="name" value="Rick"/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="bar" ref="bar"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that, when placing a &lt;aop:scoped-proxy/&gt; in a <tt class="interfacename">FactoryBean</tt>
      implementation, it is the factory bean itself that is scoped, not the object returned from
      <tt class="methodname">getObject()</tt>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-nature"></a>3.5.&nbsp;Customizing the nature of a bean</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle"></a>3.5.1.&nbsp;Lifecycle callbacks</h3></div></div><div></div></div><p>The Spring Framework provides several callback interfaces to change
      the behavior of your bean in the container; they include
      <tt class="interfacename">InitializingBean</tt> and
      <tt class="interfacename">DisposableBean</tt>. Implementing these
      interfaces will result in the container calling
      <tt class="methodname">afterPropertiesSet()</tt> for the former and
      <tt class="methodname">destroy()</tt> for the latter to allow the bean to
      perform certain actions upon initialization and destruction.</p><p>Internally, the Spring Framework uses
      <tt class="interfacename">BeanPostProcessor</tt> implementations to
      process any callback interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <tt class="interfacename">BeanPostProcessor</tt> yourself. More
      information about this can be found in the section entitled <a href="beans.html#beans-factory-extension" title="3.7.&nbsp;Container extension points">Section&nbsp;3.7, &#8220;Container extension points&#8221;</a>.</p><p>All the different lifecycle callback interfaces are described below.
      In one of the appendices, you can find diagrams that show how Spring
      manages beans, how those lifecycle features change the nature of your
      beans, and how they are managed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-initializingbean"></a>3.5.1.1.&nbsp;Initialization callbacks</h4></div></div><div></div></div><p>Implementing the
        <tt class="interfacename">org.springframework.beans.factory.InitializingBean</tt>
        interface allows a bean to perform initialization work after all
        necessary properties on the bean have been set by the container. The
        <tt class="interfacename">InitializingBean</tt> interface specifies
        exactly one method:</p><pre class="programlisting">void afterPropertiesSet() throws Exception;</pre><p>Generally, the use of the
        <tt class="interfacename">InitializingBean</tt> interface can be
        avoided and is actually discouraged since it unnecessarily couples the
        code to Spring. As an alternative, bean definitions provide support
        for a generic initialization method to be specified. In the case of
        XML-based configuration metadata, this is done using the
        <tt class="literal">'init-method'</tt> attribute. For example, the following
        definition:</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</pre><pre class="programlisting">public class ExampleBean {
    
    public void init() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>...is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements InitializingBean {
    
    public void afterPropertiesSet() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-disposablebean"></a>3.5.1.2.&nbsp;Destruction callbacks</h4></div></div><div></div></div><p>Implementing the
        <tt class="interfacename">org.springframework.beans.factory.DisposableBean</tt>
        interface allows a bean to get a callback when the container
        containing it is destroyed. The
        <tt class="interfacename">DisposableBean</tt> interface specifies a
        single method:</p><pre class="programlisting">void destroy() throws Exception;</pre><p>Generally, the use of the
        <tt class="interfacename">DisposableBean</tt> callback interface can be
        avoided and is actually discouraged since it unnecessarily couples the
        code to Spring. As an alternative, bean definitions provide support
        for a generic destroy method to be specified. When using XML-based
        configuration metadata this is done via the
        <tt class="literal">'destroy-method'</tt> attribute on the
        <tt class="literal">&lt;bean/&gt;</tt>. For example, the following
        definition:</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    public void cleanup() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>...is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-default-init-destroy-methods"></a>3.5.1.3.&nbsp;Default initialization &amp; destroy methods</h4></div></div><div></div></div><p>When writing initialization and destroy method callbacks that do
        not use the Spring-specific
        <tt class="interfacename">InitializingBean</tt> and
        <tt class="interfacename">DisposableBean</tt> callback interfaces, one
        typically finds oneself writing methods with names such as
        <tt class="literal">init()</tt>, <tt class="literal">initialize()</tt>,
        <tt class="literal">dispose()</tt>, etc. The names of such lifecycle
        callback methods are (hopefully!) standardized across a project so
        that all developers on a team use the same method names and thus
        ensure some level of consistency.</p><p>The Spring container can be configured to
        <tt class="literal">'look'</tt> for named initialization and destroy
        callback method names on <span class="emphasis"><em>every</em></span> bean. This means
        that you, as an application developer, can simply write your
        application classes, use a convention of having an initialization
        callback called <tt class="literal">init()</tt>, and then (without having to
        configure each and every bean with, in the case of XML-based
        configuration, an <tt class="literal">'init-method="init"'</tt> attribute)
        be safe in the knowledge that the Spring IoC container
        <span class="emphasis"><em>will</em></span> call that method when the bean is being
        created (and in accordance with the standard lifecycle callback
        contract described previously).</p><p>Let's look at an example to make the use of this feature
        completely clear. For the sake of the example, let us say that one of
        the coding conventions on a project is that all initialization
        callback methods are to be named <tt class="literal">init()</tt> and that
        destroy callback methods are to be called
        <tt class="literal">destroy()</tt>. This leads to classes like so...</p><pre class="programlisting">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    <i class="lineannotation"><span class="lineannotation">// this is (unsurprisingly) the initialization callback method</span></i>
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</pre><pre class="programlisting">&lt;beans <span class="bold"><b>default-init-method="init"</b></span>&gt;

    &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Notice the use of the <tt class="literal">'default-init-method'</tt>
        attribute on the top-level <tt class="literal">&lt;beans/&gt;</tt> element.
        The presence of this attribute means that the Spring IoC container
        will recognize a method called <tt class="literal">'init'</tt> on beans as
        being the initialization method callback, and when a bean is being
        created and assembled, if the bean's class has such a method, it will
        be invoked at the appropriate time.</p><p>Destroy method callbacks are configured similarly (in XML that
        is) using the <tt class="literal">'default-destroy-method'</tt> attribute on
        the top-level <tt class="literal">&lt;beans/&gt;</tt> element.</p><p>The use of this feature can save you the (small) housekeeping
        chore of specifying an initialization and destroy method callback on
        each and every bean, and it is great for enforcing a consistent naming
        convention for initialization and destroy method callbacks, as
        consistency is something that should always be aimed for.</p><p>Consider the case where you have some existing beans where the
        underlying classes already have initialization callback methods that
        are named at variance with the convention. You can
        <span class="emphasis"><em>always</em></span> override the default by specifying (in XML
        that is) the method name using the <tt class="literal">'init-method'</tt>
        and <tt class="literal">'destroy-method'</tt> attributes on the
        <tt class="literal">&lt;bean/&gt;</tt> element itself.</p><p>Finally, please be aware that the Spring container guarantees
        that a configured initialization callback is called immediately after
        a bean has been supplied with all of its dependencies. This means that
        the initialization callback will be called on the raw bean reference,
        which means that any AOP interceptors or suchlike that will ultimately
        be applied to the bean will not yet be in place. A target bean is
        fully created <span class="emphasis"><em>first</em></span>, <span class="emphasis"><em>then</em></span> an
        AOP proxy (for example) with its interceptor chain is applied. Note
        that, if the target bean and the proxy are defined separately, your
        code can even interact with the raw target bean, bypassing the proxy.
        Hence, it would be very inconsistent to apply the interceptors to the
        init method, since that would couple the lifecycle of the target bean
        with its proxy/interceptors and leave strange semantics when talking
        to the raw target bean directly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-combined-effects"></a>3.5.1.4.&nbsp;Combining lifecycle mechanisms</h4></div></div><div></div></div><p>As of Spring 2.5, there are three options for controlling bean
        lifecycle behavior: the <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks"><tt class="interfacename">InitializingBean</tt></a>
        and <a href="beans.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks"><tt class="interfacename">DisposableBean</tt></a>
        callback interfaces; custom <tt class="literal">init()</tt> and
        <tt class="literal">destroy()</tt> methods; and the <a href="beans.html#beans-postconstruct-and-predestroy-annotations" title="3.11.6.&nbsp;@PostConstruct and&#xA;      @PreDestroy"><tt class="interfacename">@PostConstruct</tt>
        and <tt class="interfacename">@PreDestroy</tt>
        annotations</a>.</p><p>When combining different lifecycle mechanisms - for example, in
        a class hierarchy in which various lifecycle mechanisms are in use -
        developers should be aware of the order in which these mechanisms are
        applied. The following is the ordering for initialization
        methods:</p><div class="itemizedlist"><ul type="disc"><li><p>Methods annotated with
            <tt class="interfacename">@PostConstruct</tt></p></li><li><p><tt class="literal">afterPropertiesSet()</tt> as defined by the
            <tt class="interfacename">InitializingBean</tt> callback
            interface</p></li><li><p>A custom configured <tt class="literal">init()</tt> method</p></li></ul></div><p>Destroy methods are called in the same order:</p><div class="itemizedlist"><ul type="disc"><li><p>Methods annotated with
            <tt class="interfacename">@PreDestroy</tt></p></li><li><p><tt class="literal">destroy()</tt> as defined by the
            <tt class="interfacename">DisposableBean</tt> callback
            interface</p></li><li><p>A custom configured <tt class="literal">destroy()</tt>
            method</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If multiple lifecycle mechanisms are configured for a given
          bean, and each mechanism is configured with a different method name,
          then each configured method will be executed in the order listed
          above; however, if the same method name is configured - for example,
          <tt class="literal">init()</tt> for an initialization method - for more
          than one of the aforementioned lifecycle mechanisms, that method
          will only be executed once.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-shutdown"></a>3.5.1.5.&nbsp;Shutting down the Spring IoC container gracefully in non-web
        applications</h4></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This next section does not apply to web applications (in case
          the title of this section did not make that abundantly clear).
          Spring's web-based <tt class="interfacename">ApplicationContext</tt>
          implementations already have code in place to handle shutting down
          the Spring IoC container gracefully when the relevant web
          application is being shutdown.</p></td></tr></table></div><p>If you are using Spring's IoC container in a non-web application
        environment, for example in a rich client desktop environment, and you
        want the container to shutdown gracefully and call the relevant
        destroy callbacks on your singleton beans, you will need to register a
        shutdown hook with the JVM. This is quite easy to do (see below), and
        will ensure that your Spring IoC container shuts down gracefully and
        that all resources held by your singletons are released. Of course it
        is still up to you to both configure the destroy callbacks for your
        singletons and implement such destroy callbacks correctly.</p><p>So to register a shutdown hook that enables the graceful
        shutdown of the relevant Spring IoC container, you simply need to call
        the <tt class="methodname">registerShutdownHook()</tt> method that is
        declared on the <tt class="classname">AbstractApplicationContext</tt>
        class. To wit...</p><pre class="programlisting">import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        <i class="lineannotation"><span class="lineannotation">// add a shutdown hook for the above context... </span></i>
        ctx.registerShutdownHook();

        <i class="lineannotation"><span class="lineannotation">// app runs here...</span></i>

        <i class="lineannotation"><span class="lineannotation">// main method exits, hook is called prior to the app shutting down...</span></i>
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-aware"></a>3.5.2.&nbsp;Knowing who you are</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beanfactoryaware"></a>3.5.2.1.&nbsp;<tt class="interfacename">BeanFactoryAware</tt></h4></div></div><div></div></div><p>A class which implements the
        <tt class="interfacename">org.springframework.beans.factory.BeanFactoryAware</tt>
        interface is provided with a reference to the
        <tt class="interfacename">BeanFactory</tt> that created it, when it is
        created by that <tt class="interfacename">BeanFactory</tt>.</p><pre class="programlisting">public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre><p>This allows beans to manipulate the
        <tt class="interfacename">BeanFactory</tt> that created them
        programmatically, through the
        <tt class="interfacename">BeanFactory</tt> interface, or by casting
        the reference to a known subclass of this which exposes additional
        functionality. Primarily this would consist of programmatic retrieval
        of other beans. While there are cases when this capability is useful,
        it should generally be avoided, since it couples the code to Spring
        and does not follow the Inversion of Control style, where
        collaborators are provided to beans as properties.</p><p>An alternative option that is equivalent in effect to the
        <tt class="interfacename">BeanFactoryAware</tt>-based approach is to
        use the
        <tt class="classname">org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</tt>.
        (It should be noted that this approach still does not reduce the
        coupling to Spring, but it does not violate the central principle of
        IoC as much as the
        <tt class="interfacename">BeanFactoryAware</tt>-based
        approach.)</p><p>The <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> is a
        <a href="beans.html#beans-factory-extension-factorybean" title="3.7.3.&nbsp;Customizing instantiation logic using&#xA;      FactoryBeans"><tt class="interfacename">FactoryBean</tt></a>
        implementation that returns a reference to an object (factory) that
        can in turn be used to effect a bean lookup. The
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> class does
        itself implement the <tt class="interfacename">BeanFactoryAware</tt>
        interface; what client beans are actually injected with is an instance
        of the <tt class="interfacename">ObjectFactory</tt> interface. This is
        a Spring-specific interface (and hence there is still no total
        decoupling from Spring), but clients can then use the
        <tt class="interfacename">ObjectFactory</tt>'s
        <tt class="methodname">getObject()</tt> method to effect the bean lookup
        (under the hood the <tt class="interfacename">ObjectFactory</tt>
        implementation instance that is returned simply delegates down to a
        <tt class="interfacename">BeanFactory</tt> to actually lookup a bean
        by name). All that you need to do is supply the
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> with the name
        of the bean that is to be looked up. Let's look at an example:</p><pre class="programlisting">package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}</pre><pre class="programlisting">package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hard code the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}</pre><p>Find below the XML configuration to wire together the above
        classes using the
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt>
        approach.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="newsFeedManager" class="x.y.NewsFeedManager"&gt;
        &lt;property name="factory"&gt;
            &lt;bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"&gt;
                &lt;property name="targetBeanName"&gt;
                    &lt;idref local="newsFeed" /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="newsFeed" class="x.y.NewsFeed" scope="prototype"&gt;
        &lt;property name="news" value="... that's fit to print!" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>And here is a small driver program to test the fact that new
        (prototype) instances of the <tt class="literal">newsFeed</tt> bean are
        actually being returned for each call to the injected
        <tt class="interfacename">ObjectFactory</tt> inside the
        <tt class="classname">NewsFeedManager</tt>'s
        <tt class="methodname">printNews()</tt> method.</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}</pre><p>The output from running the above program will look like so
        (results will of course vary on your machine).</p><pre class="programlisting">x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!'</pre><p>As of Spring 2.5, you can rely upon autowiring of the
        <tt class="interfacename">BeanFactory</tt> as yet another alternative
        to implementing the <tt class="interfacename">BeanFactoryAware</tt>
        interface. The "traditional" <tt class="literal">constructor</tt> and
        <tt class="literal">byType</tt> autowiring modes (as described in the
        section entitled <a href="beans.html#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a>) are now
        capable of providing a dependency of type
        <tt class="interfacename">BeanFactory</tt> for either a constructor
        argument or setter method parameter respectively. For more flexibility
        (including the ability to autowire fields and multiple parameter
        methods), consider using the new annotation-based autowiring features.
        In that case, the <tt class="interfacename">BeanFactory</tt> will be
        autowired into a field, constructor argument, or method parameter that
        is expecting the <tt class="interfacename">BeanFactory</tt> type as
        long as the field, constructor, or method in question carries the
        <tt class="interfacename">@Autowired</tt> annotation. For more
        information, see the section entitled <a href="beans.html#beans-autowired-annotation" title="3.11.2.&nbsp;@Autowired">Section&nbsp;3.11.2, &#8220;@Autowired&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beannameaware"></a>3.5.2.2.&nbsp;<tt class="interfacename">BeanNameAware</tt></h4></div></div><div></div></div><p>If a bean implements the
        <tt class="interfacename">org.springframework.beans.factory.BeanNameAware</tt>
        interface and is deployed in a
        <tt class="interfacename">BeanFactory</tt>, the
        <tt class="interfacename">BeanFactory</tt> will call the bean through
        this interface to inform the bean of the <span class="emphasis"><em>name</em></span> it
        was deployed under. The callback will be invoked after population of
        normal bean properties but before an initialization callback like
        <tt class="interfacename">InitializingBean</tt>'s
        <span class="emphasis"><em>afterPropertiesSet</em></span> or a custom
        init-method.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-child-bean-definitions"></a>3.6.&nbsp;Bean definition inheritance</h2></div></div><div></div></div><p>A bean definition potentially contains a large amount of
    configuration information, including container specific information (for
    example initialization method, static factory method name, and so forth)
    and constructor arguments and property values. A child bean definition is
    a bean definition that inherits configuration data from a parent
    definition. It is then able to override some values, or add others, as
    needed. Using parent and child bean definitions can potentially save a lot
    of typing. Effectively, this is a form of templating.</p><p>When working with a <tt class="interfacename">BeanFactory</tt>
    programmatically, child bean definitions are represented by the
    <tt class="classname">ChildBeanDefinition</tt> class. Most users will never
    work with them on this level, instead configuring bean definitions
    declaratively in something like the <tt class="classname">XmlBeanFactory</tt>.
    When using XML-based configuration metadata a child bean definition is
    indicated simply by using the <tt class="literal">'parent'</tt> attribute,
    specifying the parent bean as the value of this attribute.</p><pre class="programlisting">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
      class="org.springframework.beans.DerivedTestBean"
      <span class="bold"><b>parent="inheritedTestBean"</b></span> init-method="initialize"&gt;
    
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</span></i>

&lt;/bean&gt;</pre><p>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, that is it
    must accept the parent's property values.</p><p>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If any init-method, destroy-method and/or
    <tt class="literal">static</tt> factory method settings are specified, they will
    override the corresponding parent settings.</p><p>The remaining settings will <span class="emphasis"><em>always</em></span> be taken
    from the child definition: <span class="emphasis"><em>depends on</em></span>,
    <span class="emphasis"><em>autowire mode</em></span>, <span class="emphasis"><em>dependency check</em></span>,
    <span class="emphasis"><em>singleton</em></span>, <span class="emphasis"><em>scope</em></span>, <span class="emphasis"><em>lazy
    init</em></span>.</p><p>Note that in the example above, we have explicitly marked the parent
    bean definition as abstract by using the <tt class="literal">abstract</tt>
    attribute. In the case that the parent definition does not specify a
    class, and so explicitly marking the parent bean definition as
    <tt class="literal">abstract</tt> is required:</p><pre class="programlisting">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- age will inherit the value of <tt class="literal">1</tt> from the parent bean definition--&gt;</span></i>
&lt;/bean&gt;</pre><p>The parent bean cannot get instantiated on its own since it is
    incomplete, and it is also explicitly marked as
    <tt class="literal">abstract</tt>. When a definition is defined to be
    <tt class="literal">abstract</tt> like this, it is usable only as a pure
    template bean definition that will serve as a parent definition for child
    definitions. Trying to use such an <tt class="literal">abstract</tt> parent bean
    on its own (by referring to it as a ref property of another bean, or doing
    an explicit <tt class="methodname">getBean()</tt> call with the parent bean
    id), will result in an error. Similarly, the container's internal
    <tt class="methodname">preInstantiateSingletons()</tt> method will completely
    ignore bean definitions which are defined as abstract.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">ApplicationContexts</tt> (but
      <span class="emphasis"><em>not</em></span> <tt class="literal">BeanFactories</tt>) will by
      default pre-instantiate all singletons. Therefore it is important (at
      least for singleton beans) that if you have a (parent) bean definition
      which you intend to use only as a template, and this definition
      specifies a class, you must make sure to set the
      <span class="emphasis"><em>'abstract'</em></span> attribute to
      <span class="emphasis"><em>'true'</em></span>, otherwise the application context will
      actually (attempt to) pre-instantiate the <tt class="literal">abstract</tt>
      bean.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-extension"></a>3.7.&nbsp;Container extension points</h2></div></div><div></div></div><p>The IoC component of the Spring Framework has been designed for
    extension. There is typically no need for an application developer to
    subclass any of the various <tt class="interfacename">BeanFactory</tt> or
    <tt class="interfacename">ApplicationContext</tt> implementation classes.
    The Spring IoC container can be infinitely extended by plugging in
    implementations of special integration interfaces. The next few sections
    are devoted to detailing all of these various integration
    interfaces.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-bpp"></a>3.7.1.&nbsp;Customizing beans using
      <tt class="literal">BeanPostProcessors</tt></h3></div></div><div></div></div><p>The first extension point that we will look at is the
      <tt class="interfacename">BeanPostProcessor</tt> interface. This
      interface defines a number of <i class="firstterm">callback methods</i>
      that you as an application developer can implement in order to provide
      your own (or override the containers default) instantiation logic,
      dependency-resolution logic, and so forth. If you want to do some custom
      logic after the Spring container has finished instantiating, configuring
      and otherwise initializing a bean, you can plug in one or more
      <tt class="interfacename">BeanPostProcessor</tt> implementations.</p><p>You can configure multiple <tt class="literal">BeanPostProcessors</tt>
      if you wish. You can control the order in which these
      <tt class="literal">BeanPostProcessors</tt> execute by setting the
      <tt class="literal">'order'</tt> property (you can only set this property if
      the <tt class="interfacename">BeanPostProcessor</tt> implements the
      <tt class="interfacename">Ordered</tt> interface; if you write your own
      <tt class="interfacename">BeanPostProcessor</tt> you should consider
      implementing the <tt class="interfacename">Ordered</tt> interface too);
      consult the Javadoc for the
      <tt class="interfacename">BeanPostProcessor</tt> and
      <tt class="interfacename">Ordered</tt> interfaces for more
      details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">BeanPostProcessors</tt> operate on bean (or
        object) <span class="emphasis"><em>instances</em></span>; that is to say, the Spring IoC
        container will have instantiated a bean instance for you, and
        <span class="emphasis"><em>then</em></span> <tt class="literal">BeanPostProcessors</tt> get a
        chance to do their stuff.</p><p>If you want to change the actual bean definition (that is the
        recipe that defines the bean), then you rather need to use a
        <tt class="interfacename">BeanFactoryPostProcessor</tt> (described
        below in the section entitled <a href="beans.html#beans-factory-extension-factory-postprocessors" title="3.7.2.&nbsp;Customizing configuration metadata with&#xA;      BeanFactoryPostProcessors">Section&nbsp;3.7.2, &#8220;Customizing configuration metadata with
      BeanFactoryPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanPostProcessors</tt> are scoped
        <span class="emphasis"><em>per-container</em></span>. This is only relevant if you are
        using container hierarchies. If you define a
        <tt class="interfacename">BeanPostProcessor</tt> in one container, it
        will <span class="emphasis"><em>only</em></span> do its stuff on the beans in that
        container. Beans that are defined in another container will not be
        post-processed by <tt class="literal">BeanPostProcessors</tt> in another
        container, even if both containers are part of the same
        hierarchy.</p></td></tr></table></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.config.BeanPostProcessor</tt>
      interface consists of exactly two callback methods. When such a class is
      registered as a post-processor with the container (see below for how
      this registration is effected), for each bean instance that is created
      by the container, the post-processor will get a callback from the
      container both <span class="emphasis"><em>before</em></span> any container initialization
      methods (such as <span class="emphasis"><em>afterPropertiesSet</em></span> and any
      declared init method) are called, and also afterwards. The
      post-processor is free to do what it wishes with the bean instance,
      including ignoring the callback completely. A bean post-processor will
      typically check for callback interfaces, or do something such as wrap a
      bean with a proxy; some of the Spring AOP infrastructure classes are
      implemented as bean post-processors and they do this proxy-wrapping
      logic.</p><p>It is important to know that a
      <tt class="interfacename">BeanFactory</tt> treats bean post-processors
      slightly differently than an
      <tt class="interfacename">ApplicationContext</tt>. An
      <tt class="interfacename">ApplicationContext</tt> will
      <span class="emphasis"><em>automatically detect</em></span> any beans which are defined in
      the configuration metadata which is supplied to it that implement the
      <tt class="interfacename">BeanPostProcessor</tt> interface, and register
      them as post-processors, to be then called appropriately by the
      container on bean creation. Nothing else needs to be done other than
      deploying the post-processors in a similar fashion to any other bean. On
      the other hand, when using a <tt class="interfacename">BeanFactory</tt>
      implementation, bean post-processors explicitly have to be registered,
      with code like this:</p><pre class="programlisting">ConfigurableBeanFactory factory = new XmlBeanFactory(...);
            
<i class="lineannotation"><span class="lineannotation">// now register any needed <tt class="interfacename">BeanPostProcessor</tt> instances</span></i>
MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<i class="lineannotation"><span class="lineannotation">// now start using the factory</span></i></pre><p>This explicit registration step is not convenient, and this is one
      of the reasons why the various
      <tt class="interfacename">ApplicationContext</tt> implementations are
      preferred above plain <tt class="interfacename">BeanFactory</tt>
      implementations in the vast majority of Spring-backed applications,
      especially when using <tt class="literal">BeanPostProcessors</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: BeanPostProcessors and AOP&#xA;        auto-proxying"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">BeanPostProcessors and AOP
        auto-proxying</th></tr><tr><td colspan="2" align="left" valign="top"><p>Classes that implement the
        <tt class="interfacename">BeanPostProcessor</tt> interface are
        <span class="emphasis"><em>special</em></span>, and so they are treated differently by
        the container. All <tt class="interfacename">BeanPostProcessors</tt>
        <span class="emphasis"><em>and their directly referenced beans</em></span> will be
        instantiated on startup, as part of the special startup phase of the
        <tt class="interfacename">ApplicationContext</tt>,
        <span class="emphasis"><em>then</em></span> all those
        <tt class="interfacename">BeanPostProcessors</tt> will be registered
        in a sorted fashion - and applied to all further beans. Since AOP
        auto-proxying is implemented as a
        <tt class="interfacename">BeanPostProcessor</tt> itself, no
        <tt class="interfacename">BeanPostProcessors</tt> or directly
        referenced beans are eligible for auto-proxying (and thus will not
        have aspects 'woven' into them.</p><p>For any such bean, you should see an info log message:
        <span class="emphasis"><em>&#8220;<span class="quote">Bean 'foo' is not eligible for getting processed by
        all BeanPostProcessors (for example: not eligible for
        auto-proxying)</span>&#8221;.</em></span></p></td></tr></table></div><p>Find below some examples of how to write, register, and use
      <tt class="literal">BeanPostProcessors</tt> in the context of an
      <tt class="interfacename">ApplicationContext</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-hw"></a>3.7.1.1.&nbsp;Example: Hello World,
        <tt class="interfacename">BeanPostProcessor</tt>-style</h4></div></div><div></div></div><p>This first example is hardly compelling, but serves to
        illustrate basic usage. All we are going to do is code a custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation that
        simply invokes the <tt class="methodname">toString()</tt> method of each
        bean as it is created by the container and prints the resulting string
        to the system console. Yes, it is not hugely useful, but serves to get
        the basic concepts across before we move into the second example which
        <span class="emphasis"><em>is</em></span> actually useful.</p><p>Find below the custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation class
        definition:</p><pre class="programlisting">package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.BeansException;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    <i class="lineannotation"><span class="lineannotation">// simply return the instantiated bean as-is</span></i>
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean; <i class="lineannotation"><span class="lineannotation">// we could potentially return <span class="emphasis"><em>any</em></span> object reference here...</span></i>
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd"&gt;

    &lt;lang:groovy id="messenger"
          script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy"&gt;
        &lt;lang:property name="message" value="Fiona Apple Is Just So Dreamy."/&gt; 
    &lt;/lang:groovy&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- 
        when the above bean ('messenger') is instantiated, this custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation will output the fact to the system console
     --&gt;</span></i>
    &lt;bean class="scripting.InstantiationTracingBeanPostProcessor"/&gt;

&lt;/beans&gt;</pre><p>Notice how the
        <tt class="classname">InstantiationTracingBeanPostProcessor</tt> is simply
        defined; it doesn't even have a name, and because it is a bean it can
        be dependency injected just like any other bean. (The above
        configuration also just so happens to define a bean that is backed by
        a Groovy script. The Spring 2.0 dynamic language support is detailed
        in the chapter entitled <a href="dynamic-language.html" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a>.)</p><p>Find below a small driver script to exercise the above code and
        configuration;</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger);
    }
}</pre><p>The output of executing the above program will be (something
        like) this:</p><pre class="programlisting">Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-rabpp"></a>3.7.1.2.&nbsp;Example: The
        <tt class="classname">RequiredAnnotationBeanPostProcessor</tt></h4></div></div><div></div></div><p>Using callback interfaces or annotations in conjunction with a
        custom <tt class="interfacename">BeanPostProcessor</tt> implementation
        is a common means of extending the Spring IoC container. This next
        example is a bit of a cop-out, in that you are directed to the section
        entitled <a href="metadata.html#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a> which
        demonstrates the usage of a custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation that
        ships with the Spring distribution which ensures that JavaBean
        properties on beans that are marked with an (arbitrary) annotation are
        actually (configured to be) dependency-injected with a value.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factory-postprocessors"></a>3.7.2.&nbsp;Customizing configuration metadata with
      <tt class="literal">BeanFactoryPostProcessors</tt></h3></div></div><div></div></div><p>The next extension point that we will look at is the
      <tt class="interfacename">org.springframework.beans.factory.config.BeanFactoryPostProcessor</tt>.
      The semantics of this interface are similar to the
      <tt class="interfacename">BeanPostProcessor</tt>, with one major
      difference: <tt class="literal">BeanFactoryPostProcessors</tt> operate on the <span class="emphasis"><em>bean 
      configuration metadata</em></span>; that is, the Spring IoC container will allow
      <tt class="literal">BeanFactoryPostProcessors</tt> to read the configuration
      metadata and potentially change it <span class="emphasis"><em>before</em></span> the
      container has actually instantiated any other beans.</p><p>You can configure multiple
      <tt class="literal">BeanFactoryPostProcessors</tt> if you wish. You can
      control the order in which these
      <tt class="literal">BeanFactoryPostProcessors</tt> execute by setting the
      <tt class="literal">'order'</tt> property (you can only set this property if
      the <tt class="interfacename">BeanFactoryPostProcessor</tt> implements
      the <tt class="interfacename">Ordered</tt> interface; if you write your
      own <tt class="interfacename">BeanFactoryPostProcessor</tt> you should
      consider implementing the <tt class="interfacename">Ordered</tt>
      interface too); consult the Javadoc for the
      <tt class="interfacename">BeanFactoryPostProcessor</tt> and
      <tt class="interfacename">Ordered</tt> interfaces for more
      details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you want to change the actual bean
        <span class="emphasis"><em>instances</em></span> (the objects that are created from the
        configuration metadata), then you rather need to use a
        <tt class="interfacename">BeanPostProcessor</tt> (described above in
        the section entitled <a href="beans.html#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors">Section&nbsp;3.7.1, &#8220;Customizing beans using
      BeanPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanFactoryPostProcessors</tt> are scoped
        <span class="emphasis"><em>per-container</em></span>. This is only relevant if you are
        using container hierarchies. If you define a
        <tt class="interfacename">BeanFactoryPostProcessor</tt> in one
        container, it will <span class="emphasis"><em>only</em></span> do its stuff on the bean
        definitions in that container. Bean definitions in another container
        will not be post-processed by
        <tt class="literal">BeanFactoryPostProcessors</tt> in another container,
        even if both containers are part of the same hierarchy.</p></td></tr></table></div><p>A bean factory post-processor is executed manually (in the case of
      a <tt class="interfacename">BeanFactory</tt>) or automatically (in the
      case of an <tt class="interfacename">ApplicationContext</tt>) to apply
      changes of some sort to the configuration metadata that defines a
      container. Spring includes a number of pre-existing bean factory
      post-processors, such as <tt class="classname">PropertyOverrideConfigurer</tt>
      and <tt class="classname">PropertyPlaceholderConfigurer</tt>, both described
      below. A custom <tt class="interfacename">BeanFactoryPostProcessor</tt>
      can also be used to register custom property editors, for example.</p><p>In a <tt class="interfacename">BeanFactory</tt>, the process of
      applying a <tt class="interfacename">BeanFactoryPostProcessor</tt> is
      manual, and will be similar to this:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));

<i class="lineannotation"><span class="lineannotation">// bring in some property values from a <tt class="classname">Properties</tt> file</span></i>
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

<i class="lineannotation"><span class="lineannotation">// now actually do the replacement</span></i>
cfg.postProcessBeanFactory(factory);</pre><p>This explicit registration step is not convenient, and this is one
      of the reasons why the various
      <tt class="interfacename">ApplicationContext</tt> implementations are
      preferred above plain <tt class="interfacename">BeanFactory</tt>
      implementations in the vast majority of Spring-backed applications,
      especially when using
      <tt class="literal">BeanFactoryPostProcessors</tt>.</p><a name="beans-factory-autodetect-beanfactorypostprocessors"></a><p>An <tt class="interfacename">ApplicationContext</tt> will detect
      any beans which are deployed into it which implement the
      <tt class="interfacename">BeanFactoryPostProcessor</tt> interface, and
      automatically use them as bean factory post-processors, at the
      appropriate time. Nothing else needs to be done other than deploying
      these post-processor in a similar fashion to any other bean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Just as in the case of <tt class="literal">BeanPostProcessors</tt>,
        you typically don't want to have
        <tt class="literal">BeanFactoryPostProcessors</tt> marked as being
        lazily-initialized. If they are marked as such, then the Spring
        container will never instantiate them, and thus they won't get a
        chance to apply their custom logic. If you are using the
        <tt class="literal">'default-lazy-init'</tt> attribute on the declaration of
        your <tt class="literal">&lt;beans/&gt;</tt> element, be sure to mark your
        various <tt class="interfacename">BeanFactoryPostProcessor</tt> bean
        definitions with <tt class="literal">'lazy-init="false"'</tt>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-placeholderconfigurer"></a>3.7.2.1.&nbsp;Example: the
        <tt class="interfacename">PropertyPlaceholderConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="interfacename">PropertyPlaceholderConfigurer</tt>
        is used to externalize property values from a
        <tt class="interfacename">BeanFactory</tt> definition, into another
        separate file in the standard Java <tt class="classname">Properties</tt>
        format. This is useful to allow the person deploying an application to
        customize environment-specific properties (for example database URLs,
        usernames and passwords), without the complexity or risk of modifying
        the main XML definition file or files for the container.</p><p>Consider the following XML-based configuration metadata
        fragment, where a <tt class="interfacename">DataSource</tt> with
        placeholder values is defined. We will configure some properties from
        an external <tt class="classname">Properties</tt> file, and at runtime, we
        will apply a <tt class="classname">PropertyPlaceholderConfigurer</tt> to
        the metadata which will replace some properties of the
        DataSource:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/foo/jdbc.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="dataSource" destroy-method="close"
      class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="<span class="bold"><b>${jdbc.driverClassName}</b></span>"/&gt;
    &lt;property name="url" value="<span class="bold"><b>${jdbc.url}</b></span>"/&gt;
    &lt;property name="username" value="<span class="bold"><b>${jdbc.username}</b></span>"/&gt;
    &lt;property name="password" value="<span class="bold"><b>${jdbc.password}</b></span>"/&gt;
&lt;/bean&gt;</pre><p>The actual values come from another file in the standard Java
        <tt class="classname">Properties</tt> format:</p><pre class="programlisting">jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre><p>With the <tt class="literal">context</tt> namespace introduced in
        Spring 2.5, it is possible to configure property placeholders with a
        dedicated configuration element. Multiple locations may be provided as a
        comma-separated list for the <tt class="literal">location</tt> attribute.</p><pre class="programlisting">&lt;context:property-placeholder location="classpath:com/foo/jdbc.properties"/&gt;</pre><p>The <tt class="classname">PropertyPlaceholderConfigurer</tt> doesn't
        only look for properties in the <tt class="classname">Properties</tt> file
        you specify, but also checks against the Java
        <tt class="classname">System</tt> properties if it cannot find a property
        you are trying to use. This behavior can be customized by setting the
        <tt class="literal">systemPropertiesMode</tt> property of the configurer. It
        has three values, one to tell the configurer to always override, one
        to let it <span class="emphasis"><em>never</em></span> override and one to let it
        override only if the property cannot be found in the properties file
        specified. Please consult the Javadoc for the
        <tt class="classname">PropertyPlaceholderConfigurer</tt> for more
        information.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Class name substitution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Class name substitution</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="classname">PropertyPlaceholderConfigurer</tt> can
          be used to substitute class names, which is sometimes useful when
          you have to pick a particular implementation class at runtime. For
          example:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="serviceStrategy" class="${custom.strategy.class}"/&gt;</pre><p>If the class is unable to be resolved at runtime to a valid
          class, resolution of the bean will fail once it is about to be
          created (which is during the
          <tt class="methodname">preInstantiateSingletons()</tt> phase of an
          <tt class="interfacename">ApplicationContext</tt> for a
          non-lazy-init bean.)</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-overrideconfigurer"></a>3.7.2.2.&nbsp;Example: the
        <tt class="classname">PropertyOverrideConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="classname">PropertyOverrideConfigurer</tt>, another
        bean factory post-processor, is similar to the
        <tt class="interfacename">PropertyPlaceholderConfigurer</tt>, but in
        contrast to the latter, the original definitions can have default
        values or no values at all for bean properties. If an overriding
        <tt class="classname">Properties</tt> file does not have an entry for a
        certain bean property, the default context definition is used.</p><p>Note that the bean factory definition is
        <span class="emphasis"><em>not</em></span> aware of being overridden, so it is not
        immediately obvious when looking at the XML definition file that the
        override configurer is being used. In case that there are multiple
        <tt class="classname">PropertyOverrideConfigurer</tt> instances that
        define different values for the same bean property, the last one will
        win (due to the overriding mechanism).</p><p>Properties file configuration lines are expected to be in the
        format:</p><pre class="programlisting">beanName.property=value</pre><p>An example properties file might look like this:</p><pre class="programlisting">dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre><p>This example file would be usable against a container definition
        which contains a bean called <span class="emphasis"><em>dataSource</em></span>, which
        has <span class="emphasis"><em>driver</em></span> and <span class="emphasis"><em>url</em></span>
        properties.</p><p>Note that compound property names are also supported, as long as
        every component of the path except the final property being overridden
        is already non-null (presumably initialized by the constructors). In
        this example...</p><pre class="programlisting">foo.fred.bob.sammy=123</pre><p>... the <tt class="literal">sammy</tt> property of the
        <tt class="literal">bob</tt> property of the <tt class="literal">fred</tt>
        property of the <tt class="literal">foo</tt> bean is being set to the scalar
        value <tt class="literal">123</tt>.</p><p><span class="emphasis"><em>Note:</em></span> Specified override values are always
        <span class="emphasis"><em>literal</em></span> values; they are not translated into bean
        references. This also applies when the original value in the XML bean
        definition specifies a bean reference</p><p>With the <tt class="literal">context</tt> namespace introduced in
        Spring 2.5, it is possible to configure property overriding with a
        dedicated configuration element:</p><pre class="programlisting">&lt;context:property-override location="classpath:override.properties"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factorybean"></a>3.7.3.&nbsp;Customizing instantiation logic using
      <tt class="literal">FactoryBeans</tt></h3></div></div><div></div></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.FactoryBean</tt>
      interface is to be implemented by objects that <span class="emphasis"><em>are themselves
      factories</em></span>.</p><p>The <tt class="interfacename">FactoryBean</tt> interface is a
      point of pluggability into the Spring IoC containers instantiation
      logic. If you have some complex initialization code that is better
      expressed in Java as opposed to a (potentially) verbose amount of XML,
      you can create your own <tt class="interfacename">FactoryBean</tt>,
      write the complex initialization inside that class, and then plug your
      custom <tt class="interfacename">FactoryBean</tt> into the
      container.</p><p>The <tt class="interfacename">FactoryBean</tt> interface provides
      three methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">Object getObject()</tt>: has to return an
          instance of the object this factory creates. The instance can
          possibly be shared (depending on whether this factory returns
          singletons or prototypes).</p></li><li><p><tt class="methodname">boolean isSingleton()</tt>: has to return
          <tt class="literal">true</tt> if this
          <tt class="interfacename">FactoryBean</tt> returns singletons,
          <tt class="literal">false</tt> otherwise</p></li><li><p><tt class="methodname">Class getObjectType()</tt>: has to return
          either the object type returned by the
          <tt class="methodname">getObject()</tt> method or
          <tt class="literal">null</tt> if the type isn't known in advance</p></li></ul></div><p>The <tt class="interfacename">FactoryBean</tt> concept and
      interface is used in a number of places within the Spring Framework; at
      the time of writing there are over 50 implementations of the
      <tt class="interfacename">FactoryBean</tt> interface that ship with
      Spring itself.</p><p>Finally, there is sometimes a need to ask a container for an
      actual <tt class="interfacename">FactoryBean</tt> instance itself, not
      the bean it produces. This may be achieved by prepending the bean id
      with <tt class="literal">'&amp;'</tt> (sans quotes) when calling the
      <tt class="methodname">getBean</tt> method of the
      <tt class="interfacename">BeanFactory</tt> (including
      <tt class="interfacename">ApplicationContext</tt>). So for a given
      <tt class="interfacename">FactoryBean</tt> with an id of
      <tt class="literal">myBean</tt>, invoking <tt class="literal">getBean("myBean")</tt>
      on the container will return the product of the
      <tt class="interfacename">FactoryBean</tt>, but invoking
      <tt class="literal">getBean("&amp;myBean")</tt> will return the
      <tt class="interfacename">FactoryBean</tt> instance itself.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-introduction"></a>3.8.&nbsp;The <tt class="interfacename">ApplicationContext</tt></h2></div></div><div></div></div><p>While the <tt class="literal">beans</tt> package provides basic
    functionality for managing and manipulating beans, including in a
    programmatic way, the <tt class="literal">context</tt> package adds the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" target="_top"><tt class="interfacename">ApplicationContext</tt></a>
    interface, which enhances <tt class="interfacename">BeanFactory</tt>
    functionality in a more <span class="emphasis"><em>framework-oriented style</em></span>.
    Many users will use <tt class="interfacename">ApplicationContext</tt> in a
    completely declarative fashion, not even having to create it manually, but
    instead relying on support classes such as
    <tt class="classname">ContextLoader</tt> to automatically instantiate an
    <tt class="interfacename">ApplicationContext</tt> as part of the normal
    startup process of a J2EE web-app. (Of course, it is still possible to
    create an <tt class="interfacename">ApplicationContext</tt>
    programmatically.)</p><p>The basis for the context package is the
    <tt class="interfacename">ApplicationContext</tt> interface, located in
    the <tt class="literal">org.springframework.context</tt> package. Deriving from
    the <tt class="interfacename">BeanFactory</tt> interface, it provides all
    the functionality of <tt class="interfacename">BeanFactory</tt>. To allow
    working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following
    functionality:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">MessageSource</tt>, providing access
        to messages in i18n-style.</p></li><li><p><span class="emphasis"><em>Access to resources</em></span>, such as URLs and
        files.</p></li><li><p><span class="emphasis"><em>Event propagation</em></span> to beans implementing the
        <tt class="interfacename">ApplicationListener</tt> interface.</p></li><li><p><span class="emphasis"><em>Loading of multiple (hierarchical)
        contexts</em></span>, allowing each to be focused on one particular
        layer, for example the web layer of an application.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-introduction-ctx-vs-beanfactory"></a>3.8.1.&nbsp;<tt class="interfacename">BeanFactory</tt> or
      <tt class="interfacename">ApplicationContext</tt>?</h3></div></div><div></div></div><p>Short version: <span class="emphasis"><em>use an
      <tt class="interfacename">ApplicationContext</tt> unless you have a
      really good reason for not doing so. For those of you that are looking
      for slightly more depth as to the 'but why' of the above recommendation,
      keep reading.</em></span></p><p>As the <tt class="interfacename">ApplicationContext</tt> includes
      all functionality of the <tt class="interfacename">BeanFactory</tt>, it
      is generally recommended that it be used in preference to the
      <tt class="interfacename">BeanFactory</tt>, except for a few limited
      situations such as in an <tt class="classname">Applet</tt>, where memory
      consumption might be critical and a few extra kilobytes might make a
      difference. However, for most 'typical' enterprise applications and
      systems, the <tt class="interfacename">ApplicationContext</tt> is what
      you will want to use. Versions of Spring 2.0 and above make
      <span class="emphasis"><em>heavy</em></span> use of the <a href="beans.html#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors"><tt class="interfacename">BeanPostProcessor</tt>
      extension point</a> (to effect proxying and suchlike), and if you are
      using just a plain <tt class="interfacename">BeanFactory</tt> then a
      fair amount of support such as transactions and AOP will not take effect
      (at least not without some extra steps on your part), which could be
      confusing because nothing will actually be wrong with the
      configuration.</p><p>Find below a feature matrix that lists what features are provided
      by the <tt class="interfacename">BeanFactory</tt> and
      <tt class="interfacename">ApplicationContext</tt> interfaces (and
      attendant implementations). (The following sections describe
      functionality that <tt class="interfacename">ApplicationContext</tt>
      adds to the basic <tt class="interfacename">BeanFactory</tt>
      capabilities in a lot more depth than the said feature matrix.)</p><div class="table"><a name="context-introduction-ctx-vs-beanfactory-feature-matrix"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Feature Matrix</b></p><table summary="Feature Matrix" width="100%" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Feature</th><th align="center"><tt class="interfacename">BeanFactory</tt></th><th align="center"><tt class="interfacename">ApplicationContext</tt></th></tr></thead><tbody><tr><td align="left"><p>Bean instantiation/wiring</p></td><td align="center"><p>Yes</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Automatic
              <tt class="interfacename">BeanPostProcessor</tt>
              registration</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Automatic
              <tt class="interfacename">BeanFactoryPostProcessor</tt>
              registration</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Convenient
              <tt class="interfacename">MessageSource</tt> access (for
              i18n)</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p><tt class="interfacename">ApplicationEvent</tt>
              publication</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-messagesource"></a>3.8.2.&nbsp;Internationalization using
      <tt class="literal">MessageSources</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">ApplicationContext</tt> interface
      extends an interface called
      <tt class="interfacename">MessageSource</tt>, and therefore provides
      messaging (i18n or internationalization) functionality. Together with
      the <tt class="classname">HierarchicalMessageSource</tt>, capable of
      resolving hierarchical messages, these are the basic interfaces Spring
      provides to do message resolution. Let's quickly review the methods
      defined there:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">String getMessage(String code, Object[] args,
          String default, Locale loc)</tt>: the basic method used to
          retrieve a message from the
          <tt class="interfacename">MessageSource</tt>. When no message is
          found for the specified locale, the default message is used. Any
          arguments passed in are used as replacement values, using the
          <tt class="interfacename">MessageFormat</tt> functionality provided
          by the standard library.</p></li><li><p><tt class="methodname">String getMessage(String code, Object[] args,
          Locale loc)</tt>: essentially the same as the previous
          method, but with one difference: no default message can be
          specified; if the message cannot be found, a
          <tt class="classname">NoSuchMessageException</tt> is thrown.</p></li><li><p><tt class="methodname">String getMessage(MessageSourceResolvable
          resolvable, Locale locale)</tt>: all properties used in the
          methods above are also wrapped in a class named
          <tt class="interfacename">MessageSourceResolvable</tt>, which you
          can use via this method.</p></li></ul></div><p>When an <tt class="interfacename">ApplicationContext</tt> gets
      loaded, it automatically searches for a
      <tt class="interfacename">MessageSource</tt> bean defined in the
      context. The bean has to have the name
      <tt class="literal">'messageSource'</tt>. If such a bean is found, all calls
      to the methods described above will be delegated to the message source
      that was found. If no message source was found, the
      <tt class="interfacename">ApplicationContext</tt> attempts to see if it
      has a parent containing a bean with the same name. If so, it uses that
      bean as the <tt class="interfacename">MessageSource</tt>. If it can't
      find any source for messages, an empty
      <tt class="classname">DelegatingMessageSource</tt> will be instantiated
      in order to be able to accept calls to the methods defined above.</p><p>Spring currently provides two
      <tt class="interfacename">MessageSource</tt> implementations. These are
      the <tt class="classname">ResourceBundleMessageSource</tt> and the
      <tt class="classname">StaticMessageSource</tt>. Both implement
      <tt class="interfacename">HierarchicalMessageSource</tt> in order to do
      nested messaging. The <tt class="classname">StaticMessageSource</tt> is
      hardly ever used but provides programmatic ways to add messages to the
      source. The <tt class="classname">ResourceBundleMessageSource</tt> is more
      interesting and is the one we will provide an example for:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property name="basenames"&gt;
      &lt;list&gt;
        &lt;value&gt;format&lt;/value&gt;
        &lt;value&gt;exceptions&lt;/value&gt;
        &lt;value&gt;windows&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>This assumes you have three resource bundles defined on your
      classpath called <tt class="literal">format</tt>,
      <tt class="literal">exceptions</tt> and <tt class="literal">windows</tt>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. For the purposes of the
      example, lets assume the contents of two of the above resource bundle
      files are...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'format.properties'</span></i>
message=Alligators rock!</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions.properties'</span></i>
argument.required=The '{0}' argument is required.</pre><p>Some (admittedly trivial) driver code to exercise the
      <tt class="classname">MessageSource</tt> functionality can be found below.
      Remember that all <tt class="classname">ApplicationContext</tt>
      implementations are also <tt class="classname">MessageSource</tt>
      implementations and so can be cast to the
      <tt class="classname">MessageSource</tt> interface.</p><pre class="programlisting">public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", null);
    System.out.println(message);
}</pre><p>The resulting output from the above program will be...</p><pre class="programlisting">Alligators rock!</pre><p>So to summarize, the <tt class="classname">MessageSource</tt> is
      defined in a file called <tt class="literal">'beans.xml'</tt> (this file
      exists at the root of your classpath). The
      <tt class="literal">'messageSource'</tt> bean definition refers to a number of
      resource bundles via its <tt class="literal">basenames</tt> property; the
      three files that are passed in the list to the
      <tt class="literal">basenames</tt> property exist as files at the root of your
      classpath (and are called <tt class="literal">format.properties</tt>,
      <tt class="literal">exceptions.properties</tt>, and
      <tt class="literal">windows.properties</tt> respectively).</p><p>Lets look at another example, and this time we will look at
      passing arguments to the message lookup; these arguments will be
      converted into Strings and inserted into placeholders in the lookup
      message. This is perhaps best explained with an example:</p><pre class="programlisting">&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this <tt class="interfacename">MessageSource</tt> is being used in a web application --&gt;</span></i>
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basename" value="test-messages"/&gt;
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- let's inject the above <tt class="interfacename">MessageSource</tt> into this POJO --&gt;</span></i>
    &lt;bean id="example" class="com.foo.Example"&gt;
        &lt;property name="messages" ref="messageSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", null);
        System.out.println(message);
    }

}</pre><p>The resulting output from the invocation of the
      <tt class="methodname">execute()</tt> method will be...</p><pre class="programlisting">The 'userDao' argument is required.</pre><p>With regard to internationalization (i18n), Spring's various
      <tt class="classname">MessageResource</tt> implementations follow the same
      locale resolution and fallback rules as the standard JDK
      <tt class="classname">ResourceBundle</tt>. In short, and continuing with the
      example <tt class="literal">'messageSource'</tt> defined previously, if you
      want to resolve messages against the British (en-GB) locale, you would
      create files called <tt class="literal">format_en_GB.properties</tt>,
      <tt class="literal">exceptions_en_GB.properties</tt>, and
      <tt class="literal">windows_en_GB.properties</tt> respectively.</p><p>Locale resolution is typically going to be managed by the
      surrounding environment of the application. For the purpose of this
      example though, we'll just manually specify the locale that we want to
      resolve our (British) messages against.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions_en_GB.properties'</span></i>
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.</pre><pre class="programlisting">public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}</pre><p>The resulting output from the running of the above program will
      be...</p><pre class="programlisting">Ebagum lad, the 'userDao' argument is required, I say, required.</pre><p>The <tt class="classname">MessageSourceAware</tt> interface can also
      be used to acquire a reference to any
      <tt class="classname">MessageSource</tt> that has been defined. Any bean
      that is defined in an <tt class="classname">ApplicationContext</tt> that
      implements the <tt class="classname">MessageSourceAware</tt> interface will
      be injected with the application context's
      <tt class="classname">MessageSource</tt> when it (the bean) is being created
      and configured.</p><p><span class="emphasis"><em>Note: As an alternative to <tt class="classname">ResourceBundleMessageSource</tt>,
      Spring also provides a <tt class="classname">ReloadableResourceBundleMessageSource</tt> class.
      This variant supports the same bundle file format but is more flexible than the standard
      JDK based <tt class="classname">ResourceBundleMessageSource</tt> implementation.</em></span>
      In particular, it allows for reading files from any Spring resource location
      (not just from the classpath) and supports hot reloading of bundle property files
      (while efficiently caching them in between). Check out the
      <tt class="classname">ReloadableResourceBundleMessageSource</tt> javadoc for details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-events"></a>3.8.3.&nbsp;Events</h3></div></div><div></div></div><p>Event handling in the
      <tt class="interfacename">ApplicationContext</tt> is provided through
      the <tt class="classname">ApplicationEvent</tt> class and
      <tt class="interfacename">ApplicationListener</tt> interface. If a bean
      which implements the <tt class="interfacename">ApplicationListener</tt>
      interface is deployed into the context, every time an
      <tt class="classname">ApplicationEvent</tt> gets published to the
      <tt class="interfacename">ApplicationContext</tt>, that bean will be
      notified. Essentially, this is the standard
      <span class="emphasis"><em>Observer</em></span> design pattern. Spring provides the
      following standard events:</p><div class="table"><a name="beans-ctx-events-tbl"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Built-in Events</b></p><table summary="Built-in Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Event</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="classname">ContextRefreshedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is initialized
              or refreshed, e.g. using the <tt class="methodname">refresh()</tt>
              method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Initialized" here means that all beans are loaded,
              post-processor beans are detected and activated, singletons are
              pre-instantiated, and the
              <tt class="interfacename">ApplicationContext</tt> object is
              ready for use. A refresh may be triggered multiple times,
              as long as the context hasn't been closed - provided that
              the chosen <tt class="interfacename">ApplicationContext</tt>
              actually supports such "hot" refreshes (which e.g.
              <tt class="classname">XmlWebApplicationContext</tt> does but
              <tt class="classname">GenericApplicationContext</tt> doesn't).</td></tr><tr><td><tt class="classname">ContextStartedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is started,
              using the <tt class="methodname">start()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Started" here means that all
              <tt class="interfacename">Lifecycle</tt> beans will receive
              an explicit start signal. This will typically be used for
              restarting after an explicit stop, but may also be used
              for starting components that haven't been configured for
              autostart (e.g. haven't started on initialization already).</td></tr><tr><td><tt class="classname">ContextStoppedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is stopped,
              using the <tt class="methodname">stop()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Stopped" here means that all
              <tt class="interfacename">Lifecycle</tt> beans will receive
              an explicit stop signal. A stopped context may be restarted
              through a <tt class="methodname">start()</tt> call.</td></tr><tr><td><tt class="classname">ContextClosedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is closed,
              using the <tt class="methodname">close()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Closed" here means that all singleton beans
              are destroyed. A closed context has reached its end of life;
              it cannot be refreshed or restarted.</td></tr><tr><td><tt class="classname">RequestHandledEvent</tt></td><td>A web-specific event telling all beans that an
              HTTP request has been serviced (this will be published
              <span class="emphasis"><em>after</em></span> the request has been finished).
              Note that this event is only applicable for web applications
              using Spring's
              <tt class="classname">DispatcherServlet</tt>.</td></tr></tbody></table></div><p>Implementing custom events can be done as well. Simply call the
      <tt class="methodname">publishEvent()</tt> method on the
      <tt class="interfacename">ApplicationContext</tt>, specifying a
      parameter which is an instance of your custom event class implementing
      <tt class="classname">ApplicationEvent</tt>. Event listeners receive events
      synchronously. This means the <tt class="methodname">publishEvent()</tt>
      method blocks until all listeners have finished processing the event (it
      is possible to supply an alternate event publishing strategy via a
      <tt class="interfacename">ApplicationEventMulticaster</tt>
      implementation). Furthermore, when a listener receives an event it
      operates inside the transaction context of the publisher, if a
      transaction context is available.</p><p>Let's look at an example. First, the
      <tt class="interfacename">ApplicationContext</tt>:</p><pre class="programlisting">&lt;bean id="emailer" class="example.EmailBean"&gt;
  &lt;property name="blackList"&gt;
    &lt;list&gt;
      &lt;value&gt;black@list.org&lt;/value&gt;
      &lt;value&gt;white@list.org&lt;/value&gt;
      &lt;value&gt;john@doe.org&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
  &lt;property name="notificationAddress" value="spam@list.org"/&gt;
&lt;/bean&gt;</pre><p>Now, let's look at the actual classes:</p><pre class="programlisting">public class EmailBean implements ApplicationContextAware {

    private List blackList;
    private ApplicationContext ctx;

    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }

    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }

    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent event = new BlackListEvent(address, text);
            ctx.publishEvent(event);
            return;
        }
        <i class="lineannotation"><span class="lineannotation">// send email...</span></i>
    }
}</pre><pre class="programlisting">public class BlackListNotifier implements ApplicationListener {

    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof BlackListEvent) {
            <i class="lineannotation"><span class="lineannotation">// notify appropriate person...</span></i>
        }
    }
}</pre><p>Of course, this particular example could probably be implemented
      in better ways (perhaps by using AOP features), but it should be
      sufficient to illustrate the basic event mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-resources"></a>3.8.4.&nbsp;Convenient access to low-level resources</h3></div></div><div></div></div><p>For optimal usage and understanding of application contexts, users
      should generally familiarize themselves with Spring's
      <tt class="interfacename">Resource</tt> abstraction, as described in the
      chapter entitled <a href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.</p><p>An application context is a
      <tt class="interfacename">ResourceLoader</tt>, able to be used to load
      <tt class="interfacename">Resource</tt>s. A
      <tt class="interfacename">Resource</tt> is essentially a
      <tt class="literal">java.net.URL</tt> on steroids (in fact, it just wraps and
      uses a URL where appropriate), which can be used to obtain low-level
      resources from almost any location in a transparent fashion, including
      from the classpath, a filesystem location, anywhere describable with a
      standard URL, and some other variations. If the resource location string
      is a simple path without any special prefixes, where those resources
      come from is specific and appropriate to the actual application context
      type.</p><p>A bean deployed into the application context may implement the
      special callback interface,
      <tt class="interfacename">ResourceLoaderAware</tt>, to be automatically
      called back at initialization time with the application context itself
      passed in as the <tt class="interfacename">ResourceLoader</tt>. A bean
      may also expose properties of type
      <tt class="interfacename">Resource</tt>, to be used to access static
      resources, and expect that they will be injected into it like any other
      properties. The person deploying the bean may specify those
      <tt class="interfacename">Resource</tt> properties as simple String
      paths, and rely on a special JavaBean
      <tt class="interfacename">PropertyEditor</tt> that is automatically
      registered by the context, to convert those text strings to actual
      <tt class="interfacename">Resource</tt> objects.</p><p>The location path or paths supplied to an
      <tt class="interfacename">ApplicationContext</tt> constructor are
      actually resource strings, and in simple form are treated appropriately
      to the specific context implementation (
      <tt class="classname">ClassPathXmlApplicationContext</tt> treats a simple
      location path as a classpath location), but may also be used with
      special prefixes to force loading of definitions from the classpath or a
      URL, regardless of the actual context type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-create"></a>3.8.5.&nbsp;Convenient <tt class="interfacename">ApplicationContext</tt>
      instantiation for web applications</h3></div></div><div></div></div><p>As opposed to the <tt class="interfacename">BeanFactory</tt>,
      which will often be created programmatically,
      <tt class="interfacename">ApplicationContext</tt> instances can be
      created declaratively using for example a
      <tt class="classname">ContextLoader</tt>. Of course you can also create
      <tt class="interfacename">ApplicationContext</tt> instances
      programmatically using one of the
      <tt class="interfacename">ApplicationContext</tt> implementations.
      First, let's examine the <tt class="classname">ContextLoader</tt> mechanism
      and its implementations.</p><p>The <tt class="classname">ContextLoader</tt> mechanism comes in two
      flavors: the <tt class="classname">ContextLoaderListener</tt> and the
      <tt class="classname">ContextLoaderServlet</tt>. They both have the same
      functionality but differ in that the listener version cannot be reliably
      used in Servlet 2.3 containers. Since the Servlet 2.4 specification,
      servlet context listeners are required to execute immediately after the
      servlet context for the web application has been created and is
      available to service the first request (and also when the servlet
      context is about to be shut down): as such a servlet context listener is
      an ideal place to initialize the Spring
      <tt class="interfacename">ApplicationContext</tt>. It is up to you as to
      which one you use, but all things being equal you should probably prefer
      <tt class="classname">ContextLoaderListener</tt>; for more information on
      compatibility, have a look at the Javadoc for the
      <tt class="classname">ContextLoaderServlet</tt>.</p><p>You can register an
      <tt class="interfacename">ApplicationContext</tt> using the
      <tt class="classname">ContextLoaderListener</tt> as follows:</p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- or use the <tt class="classname">ContextLoaderServlet</tt> instead of the above listener</span></i><span class="emphasis"><em>
&lt;servlet&gt;
  &lt;servlet-name&gt;context&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--</em></span>&gt;</pre><p>The listener inspects the
      <tt class="literal">'contextConfigLocation'</tt> parameter. If the parameter
      does not exist, the listener will use
      <tt class="literal">/WEB-INF/applicationContext.xml</tt> as a default. When it
      <span class="emphasis"><em>does</em></span> exist, it will separate the String using
      predefined delimiters (comma, semicolon and whitespace) and use the
      values as locations where application contexts will be searched for.
      Ant-style path patterns are supported as well: e.g.
      <tt class="literal">/WEB-INF/*Context.xml</tt> (for all files whose name ends
      with "Context.xml", residing in the "WEB-INF" directory) or
      <tt class="literal">/WEB-INF/**/*Context.xml</tt> (for all such files in any
      subdirectory of "WEB-INF").</p><p>The <tt class="classname">ContextLoaderServlet</tt> can be used
      instead of the <tt class="classname">ContextLoaderListener</tt>. The servlet
      will use the <tt class="literal">'contextConfigLocation'</tt> parameter just
      as the listener does.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-glue-code-and-singletons"></a>3.9.&nbsp;Glue code and the evil singleton</h2></div></div><div></div></div><p>The majority of the code inside an application is best written in a
    DI style, where that code is served out of a Spring IoC container, has its
    own dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    Spring IoC container. For example, third party code may try to construct
    new objects directly (<tt class="literal">Class.forName()</tt> style), without
    the ability to force it to get these objects out of a Spring IoC
    container. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a Spring
    IoC container to get a real object to delegate to, then inversion of
    control has still been achieved for the majority of the code (the object
    coming out of the container); thus most code is still unaware of the
    container or how it is accessed, and remains decoupled from other code,
    with all ensuing benefits. EJBs may also use this stub/proxy approach to
    delegate to a plain Java implementation object, coming out of a Spring IoC
    container. While the Spring IoC container itself ideally does not have to
    be a singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the Spring IoC container such as
    a Hibernate <tt class="interfacename">SessionFactory</tt>) for each bean
    to use its own, non-singleton Spring IoC container.</p><p>As another example, in complex J2EE applications with multiple
    layers (various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own Spring IoC container definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    Spring IoC container from the multiple XML definition files from each
    layer. All of the various Spring IoC container implementations may be
    constructed from multiple definition files in this fashion. However, if
    there are multiple sibling web-applications at the root of the hierarchy,
    it is problematic to create a Spring IoC container for each
    web-application which consists of mostly identical bean definitions from
    lower layers, as there may be issues due to increased memory usage, issues
    with creating multiple copies of beans which take a long time to
    initialize (for example a Hibernate
    <tt class="interfacename">SessionFactory</tt>), and possible issues due to
    side-effects. As an alternative, classes such as <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a></tt>
    or <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></tt>
    may be used to demand-load multiple hierarchical (that is one container is
    the parent of another) Spring IoC container instances in a singleton
    fashion, which may then be used as the parents of the web-application
    Spring IoC container instances. The result is that bean definitions for
    lower layers are loaded only as needed, and loaded only once.</p><p>You can see a detailed example of the usage of these classes by
    viewing the Javadoc for the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a>
    and <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a>
    classes. As mentioned in the <a href="ejb.html" title="Chapter&nbsp;18.&nbsp;Enterprise Java Beans (EJB) integration">chapter on EJBs</a>,
    the Spring convenience base classes for EJBs normally use a non-singleton
    <tt class="interfacename">BeanFactoryLocator</tt> implementation, which is
    easily replaced by the use of
    <tt class="classname">SingletonBeanFactoryLocator</tt> and
    <tt class="classname">ContextSingletonBeanFactoryLocator</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-rar-deployment"></a>3.10.&nbsp;Deploying a Spring ApplicationContext as a J2EE RAR file</h2></div></div><div></div></div><p>Since Spring 2.5, it is possible to deploy a Spring ApplicationContext
    as a RAR file, encapsulating the context and all of its required bean classes
    and library JARs in a J2EE RAR deployment unit. This is the equivalent of
    bootstrapping a standalone ApplicationContext, just hosted in J2EE environment,
    being able to access the J2EE server's facilities. RAR deployment is intended
    as a more 'natural' alternative to the not uncommon scenario of deploying a
    headless WAR file - i.e. a WAR file without any HTTP entry points, just used
    for bootstrapping a Spring ApplicationContext in a J2EE environment.</p><p>RAR deployment is ideal for application contexts that do not need any
    HTTP entry points but rather just consist of message endpoints and scheduled
    jobs etc. Beans in such a context may use application server resources such
    as the JTA transaction manager and JNDI-bound JDBC DataSources and JMS
    ConnectionFactory instances, and may also register with the platform's
    JMX server - all through Spring's standard transaction management and
    JNDI and JMX support facilities. Application components may also interact
    with the application's server JCA WorkManager through Spring's
    <tt class="interfacename">TaskExecutor</tt> abstraction.</p><p>Check out the JavaDoc of the
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jca/context/SpringContextResourceAdapter.html" target="_top">SpringContextResourceAdapter</a>
    class for the configuration details involved in RAR deployment.</p><p><span class="emphasis"><em>For simple deployment needs, all you need to do is the following:</em></span>
    Package all application classes into a RAR file (which is just a standard
    JAR file with a different file extension), add all required library jars
    into the root of the RAR archive, add a "META-INF/ra.xml" deployment descriptor
    (as shown in <tt class="classname">SpringContextResourceAdapter</tt>'s JavaDoc)
    as well as the corresponding Spring XML bean definition file(s)
    (typically "META-INF/applicationContext.xml"), and drop the resulting RAR
    file into your application server's deployment directory!</p><p><span class="emphasis"><em>NOTE:</em></span> Such RAR deployment units are usually self-contained;
    they do not expose components to the 'outside' world, not even to other
    modules of the same application. Interaction with a RAR-based ApplicationContext
    usually happens through JMS destinations that it shares with other modules.
    A RAR-based ApplicationContext may also - for example - schedule some jobs,
    reacting to new files in the file system (or the like). If it actually needs
    to allow for synchronous access from the outside, it could for example export
    RMI endpoints, which of course may be used by other application modules
    on the same machine as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-annotation-config"></a>3.11.&nbsp;Annotation-based configuration</h2></div></div><div></div></div><p>As mentioned in the section entitled <a href="beans.html#beans-factory-extension-bpp-examples-rabpp" title="3.7.1.2.&nbsp;Example: The&#xA;        RequiredAnnotationBeanPostProcessor">Section&nbsp;3.7.1.2, &#8220;Example: The
        RequiredAnnotationBeanPostProcessor&#8221;</a>, using a
    <tt class="interfacename">BeanPostProcessor</tt> in conjunction with
    annotations is a common means of extending the Spring IoC container. For
    example, Spring 2.0 introduced the possibility of enforcing required
    properties with the <a href="metadata.html#metadata-annotations-required" title="25.3.1.&nbsp;@Required">@Required</a> annotation. As of
    Spring 2.5, it is now possible to follow that same general approach to
    drive Spring's dependency injection. Essentially, the
    <tt class="interfacename">@Autowired</tt> annotation provides the same
    capabilities as described in <a href="beans.html#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a> but
    with more fine-grained control and wider applicability. Spring 2.5 also
    adds support for JSR-250 annotations such as
    <tt class="interfacename">@Resource</tt>,
    <tt class="interfacename">@PostConstruct</tt>, and
    <tt class="interfacename">@PreDestroy</tt>. Of course, these options are
    only available if you are using at least Java 5 (Tiger) and thus have
    access to source level annotations. Use of these annotations also requires
    that certain <tt class="interfacename">BeanPostProcessors</tt> be
    registered within the Spring container. As always, these can be registered
    as individual bean definitions, but they can also be implicitly registered
    by including the following tag in an XML-based Spring configuration
    (notice the inclusion of the '<tt class="literal">context</tt>'
    namespace):</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <i class="lineannotation"><span class="lineannotation">xmlns:context="http://www.springframework.org/schema/context"</span></i>
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;
               
     <i class="lineannotation"><span class="lineannotation">&lt;context:annotation-config/&gt;</span></i>
     
&lt;/beans&gt;</pre><p>(The implicitly registered post-processors include <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">AutowiredAnnotationBeanPostProcessor</tt></a>,
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">CommonAnnotationBeanPostProcessor</tt></a>,
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">PersistenceAnnotationBeanPostProcessor</tt></a>,
    as well as the aforementioned <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">RequiredAnnotationBeanPostProcessor</tt></a>.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that <tt class="literal">&lt;context:annotation-config/&gt;</tt> only looks for
        annotations  on beans in the same application context it is defined in.
        This means that, if you put <tt class="literal">&lt;context:annotation-config/&gt;</tt> in a
        <tt class="interfacename">WebApplicationContext</tt> for a <tt class="classname">DispatcherServlet</tt>, it only
        checks for <tt class="interfacename">@Autowired</tt> beans in your controllers, and not your services.
        See <a href="mvc.html#mvc-servlet" title="13.2.&nbsp;The DispatcherServlet">Section&nbsp;13.2, &#8220;The DispatcherServlet&#8221;</a> for more information.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-required-annotation"></a>3.11.1.&nbsp;<tt class="interfacename">@Required</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@Required</tt> annotation applies
      to bean property setter methods, as in the following example:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>This annotation simply indicates that the affected bean property must
      be populated at configuration time: either through an explicit property value
      in a bean definition or through autowiring. The container will throw an exception
      if the affected bean property has not been populated; this allows for eager and
      explicit failure, avoiding <tt class="classname">NullPointerException</tt>s or the
      like later on. Note that it is still recommended to put assertions into the
      bean class itself (for example into an init method) in order to enforce those
      required references and values even when using the class outside of a container.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-autowired-annotation"></a>3.11.2.&nbsp;<tt class="interfacename">@Autowired</tt></h3></div></div><div></div></div><p>As expected, the <tt class="interfacename">@Autowired</tt>
      annotation may be applied to "traditional" setter methods:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The annotation may also be applied to methods with arbitrary names
      and/or multiple arguments:</p><pre class="programlisting">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The <tt class="interfacename">@Autowired</tt> annotation may even
      be applied on constructors and fields:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>It is also possible to provide <span class="emphasis"><em>all</em></span> beans of a
      particular type from the
      <tt class="interfacename">ApplicationContext</tt> by adding the
      annotation to a field or method that expects an array of that
      type:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The same applies for typed collections:</p><pre class="programlisting">public class MovieRecommender {

    private Set&lt;MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Even typed Maps may be autowired as long as the expected key type
      is <tt class="classname">String</tt>. The Map values will contain all beans
      of the expected type, and the keys will contain the corresponding bean
      names:</p><pre class="programlisting">public class MovieRecommender {

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>By default, the autowiring will fail whenever
      <span class="emphasis"><em>zero</em></span> candidate beans are available; the default
      behavior is to treat annotated methods, constructors, and fields as
      indicating <span class="emphasis"><em>required</em></span> dependencies. This behavior can
      be changed as demonstrated below.</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required=false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Only <span class="emphasis"><em>one annotated constructor per-class</em></span>
        may be marked as <span class="emphasis"><em>required</em></span>, but multiple non-required
        constructors can be annotated. In that case, each will be considered
        among the candidates and Spring will use the <span class="emphasis"><em>greediest</em></span>
        constructor whose dependencies can be satisfied.</p><p>Prefer the use of <tt class="interfacename">@Autowired</tt>'s
        <span class="emphasis"><em>required</em></span> attribute over the <tt class="interfacename">@Required</tt>
        annotation. The <span class="emphasis"><em>required</em></span> attribute indicates that
        the property is not required for autowiring purposes, simply skipping
        it if it cannot be autowired. <tt class="interfacename">@Required</tt>,
        on the other hand, is stronger in that it enforces the property to
        have been set in any of the container's supported ways; if no value
        has been injected, a corresponding exception will be raised.</p></td></tr></table></div><p><tt class="interfacename">@Autowired</tt> may also be used for
      well-known "resolvable dependencies": the <tt class="interfacename">BeanFactory</tt>
      interface, the <tt class="interfacename">ApplicationContext</tt> interface,
      the <tt class="interfacename">ResourceLoader</tt> interface,
      the <tt class="interfacename">ApplicationEventPublisher</tt> interface
      and the <tt class="interfacename">MessageSource</tt> interface.
      These interfaces (and their extended interfaces such as
      <tt class="interfacename">ConfigurableApplicationContext</tt> or
      <tt class="interfacename">ResourcePatternResolver</tt>) will be
      automatically resolved, with no special setup necessary.</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-autowired-annotation-qualifiers"></a>3.11.3.&nbsp;Fine-tuning annotation-based autowiring with qualifiers</h3></div></div><div></div></div><p>Since autowiring by type may lead to multiple candidates, it is
      often necessary to have more control over the selection process. One way
      to accomplish this is with Spring's
      <tt class="interfacename">@Qualifier</tt> annotation. This allows for
      associating qualifier values with specific arguments, narrowing the
      set of type matches so that a specific bean is chosen for each argument.
      In the simplest case, this can be a plain descriptive value:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Qualifier("main")</b></span>
    private MovieCatalog movieCatalog;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The <tt class="interfacename">@Qualifier</tt> annotation can also
      be specified on individual constructor arguments or method
      parameters:</p><pre class="programlisting">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(<span class="bold"><b>@Qualifier("main")</b></span> MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The corresponding bean definitions would look like as follows.
      The bean with qualifier value "main" would be wired with the
      constructor argument that has been qualified with the same value.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier value="main"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier value="action"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;
</pre><p>For a fallback match, the bean name is considered as a default qualifier
      value. This means that the bean may be defined with an id "main" instead of
      the nested qualifier element, leading to the same matching result. However,
      note that while this can be used to refer to specific beans by name,
      <tt class="interfacename">@Autowired</tt> is fundamentally about type-driven
      injection with optional semantic qualifiers. This means that qualifier values,
      even when using the bean name fallback, always have narrowing semantics within
      the set of type matches; they do not semantically express a reference to a
      unique bean id. Good qualifier values would be "main" or "EMEA" or "persistent",
      expressing characteristics of a specific component - independent from the bean
      id (which may be auto-generated in case of an anonymous bean definition like
      the one above).</p><p>Qualifiers also apply to typed collections (as discussed above):
      e.g. to <tt class="literal">Set&lt;MovieCatalog&gt;</tt>. In such a case,
      all matching beans according to the declared qualifiers are going to
      be injected as a collection. This implies that qualifiers do not have
      to be unique; they rather simply constitute filtering criteria.
      For example, there could be multiple <tt class="classname">MovieCatalog</tt>
      beans defined with the same qualifier value "action"; all of which
      would be injected into a <tt class="literal">Set&lt;MovieCatalog&gt;</tt>
      annotated with <tt class="literal">@Qualifier("action")</tt>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you intend to express annotation-driven injection by name,
        do not primarily use <tt class="interfacename">@Autowired</tt> -
        even if is technically capable of referring to a bean name through
        <tt class="interfacename">@Qualifier</tt> values. Instead,
        prefer the JSR-250 <tt class="interfacename">@Resource</tt>
        annotation which is semantically defined to identify a specific
        target component by its unique name, with the declared type
        being irrelevant for the matching process.</p><p>As a specific consequence of this semantic difference,
        beans which are themselves defined as a collection or map type
        cannot be injected via <tt class="interfacename">@Autowired</tt>
        since type matching is not properly applicable to them.
        Use <tt class="interfacename">@Resource</tt> for such beans,
        referring to the specific collection/map bean by unique name.</p><p><span class="emphasis"><em>Note:</em></span> In contrast to
        <tt class="interfacename">@Autowired</tt> which is applicable to
        fields, constructors and multi-argument methods (allowing for
        narrowing through qualifier annotations at the parameter level),
        <tt class="interfacename">@Resource</tt> is only supported for
        fields and bean property setter methods with a single argument.
        As a consequence, stick with qualifiers if your injection target
        is a constructor or a multi-argument method.</p></td></tr></table></div><p>You may create your own custom qualifier annotations as well.
      Simply define an annotation and provide the
      <tt class="interfacename">@Qualifier</tt> annotation within your
      definition:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
<span class="bold"><b>@Qualifier</b></span>
public @interface Genre {

    String value();
}</pre><p>Then you can provide the custom qualifier on autowired fields and
      parameters:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Genre("Action")</b></span>
    private MovieCatalog actionCatalog;
    
    private MovieCatalog comedyCatalog;
    
    @Autowired
    public void setComedyCatalog(<span class="bold"><b>@Genre("Comedy")</b></span> MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The next step is to provide the information on the candidate bean
      definitions. You can add <tt class="literal">&lt;qualifier/&gt;</tt> tags as
      sub-elements of the <tt class="literal">&lt;bean/&gt;</tt> tag and then
      specify the <tt class="literal">'type'</tt> and <tt class="literal">'value'</tt> to
      match your custom qualifier annotations. The type will be matched
      against the fully-qualified class name of the annotation, or as a
      convenience when there is no risk of conflicting names, you may use the
      'short' class name. Both are demonstrated in the following
      example.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier type="Genre" value="Action"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier type="example.Genre" value="Comedy"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;
    
    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;
</pre><p>In the next section, entitled <a href="beans.html#beans-classpath-scanning" title="3.12.&nbsp;Classpath scanning for managed components">Section&nbsp;3.12, &#8220;Classpath scanning for managed components&#8221;</a>,
      you will see an annotation-based alternative to providing the qualifier
      metadata in XML. Specifically, see: <a href="beans.html#beans-scanning-qualifiers" title="3.12.6.&nbsp;Providing qualifier metadata with annotations">Section&nbsp;3.12.6, &#8220;Providing qualifier metadata with annotations&#8221;</a>.
      </p><p>In some cases, it may be sufficient to use an annotation without a
      value. This may be useful when the annotation serves a more generic
      purpose and could be applied across several different types of
      dependencies. For example, you may provide an
      <span class="emphasis"><em>offline</em></span> catalog that would be searched when no
      Internet connection is available. First define the simple
      annotation:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</pre><p>Then add the annotation to the field or property to be
      autowired:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Offline</b></span>
    private MovieCatalog offlineCatalog;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Now the bean definition only needs a qualifier
      <tt class="literal">'type'</tt>:</p><pre class="programlisting">&lt;bean class="example.SimpleMovieCatalog"&gt;
    <span class="bold"><b>&lt;qualifier type="Offline"/&gt;</b></span>
    <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
&lt;/bean&gt;</pre><p>It is also possible to define custom qualifier annotations that
      accept named attributes in addition to or instead of the simple
      <tt class="literal">'value'</tt> attribute. If multiple attribute values are
      then specified on a field or parameter to be autowired, a bean
      definition must match <span class="emphasis"><em>all</em></span> such attribute values to
      be considered an autowire candidate. As an example, consider the
      following annotation definition:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();
    
    Format format();
}</pre><p>In this case <tt class="literal">Format</tt> is an enum:</p><pre class="programlisting">public enum Format {
    
    VHS, DVD, BLURAY
}</pre><p>The fields to be autowired are annotated with the custom qualifier
      and include values for both attributes: <tt class="literal">'genre'</tt> and
      <tt class="literal">'format'</tt>.</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;
   
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Finally, the bean definitions should contain matching qualifier
      values. This example also demonstrates that bean
      <span class="emphasis"><em>meta</em></span> attributes may be used instead of the
      <tt class="literal">&lt;qualifier/&gt;</tt> sub-elements. If available, the
      <tt class="literal">&lt;qualifier/&gt;</tt> and its attributes would take
      precedence, but the autowiring mechanism will fallback on the values
      provided within the <tt class="literal">&lt;meta/&gt;</tt> tags if no such
      qualifier is present (see the last 2 bean definitions below).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Action"/&gt;
        &lt;/qualifier&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Comedy"/&gt;
        &lt;/qualifier&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="DVD"/&gt;
        &lt;meta key="genre" value="Action"/&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;
    
    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="BLURAY"/&gt;
        &lt;meta key="genre" value="Comedy"/&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-custom-autowire-configurer"></a>3.11.4.&nbsp;<tt class="classname">CustomAutowireConfigurer</tt></h3></div></div><div></div></div><p>The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html" target="_top"><tt class="classname">CustomAutowireConfigurer</tt></a>
      is a <tt class="interfacename">BeanFactoryPostProcessor</tt> that
      enables further customization of the autowiring process. Specifically,
      it allows you to register your own custom qualifier annotation types
      even if they are not themselves annotated with Spring's
      <tt class="interfacename">@Qualifier</tt> annotation.</p><pre class="programlisting">&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
    &lt;property name="customQualifierTypes"&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the particular implementation of
      <tt class="interfacename">AutowireCandidateResolver</tt> that will be
      activated for the application context depends upon the Java version. If
      running on less than Java 5, the qualifier annotations are not
      supported, and therefore autowire candidates are solely determined by
      the <tt class="literal">'autowire-candidate'</tt> value of each bean
      definition as well as any
      <tt class="literal">'default-autowire-candidates'</tt> pattern(s) available on
      the <tt class="literal">&lt;beans/&gt;</tt> element. If running on Java 5 or
      greater, the presence of <tt class="interfacename">@Qualifier</tt>
      annotations or any custom annotations registered with the
      <tt class="classname">CustomAutowireConfigurer</tt> will also play a
      role.</p><p>Regardless of the Java version, the determination of a "primary"
      candidate (when multiple beans qualify as autowire candidates) is the
      same: if exactly one bean definition among the candidates has a
      <tt class="literal">'primary'</tt> attribute set to <tt class="literal">'true'</tt>,
      it will be selected.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-resource-annotation"></a>3.11.5.&nbsp;<tt class="interfacename">@Resource</tt></h3></div></div><div></div></div><p>Spring also supports injection using the JSR-250
      <tt class="interfacename">@Resource</tt> annotation on fields or
      bean property setter methods. This is a common pattern found in
      Java EE 5 and Java 6 (e.g. in JSF 1.2 managed beans or JAX-WS 2.0
      endpoints), which Spring supports for Spring-managed objects as well.</p><p><tt class="interfacename">@Resource</tt> takes a 'name' attribute,
      and by default Spring will interpret that value as the bean name to be
      injected. In other words, it follows <span class="emphasis"><em>by-name</em></span>
      semantics as demonstrated in this example:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><b>@Resource(name="myMovieFinder")</b></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><p>If no name is specified explicitly, then the default name
      will be derived from the name of the field or setter method:
      In case of a field, it will simply be equivalent to the field name;
      in case of a setter method, it will be equivalent to the bean
      property name. So the following example is going to have the bean
      with name "movieFinder" injected into its setter method:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><b>@Resource</b></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The name provided with the annotation will be resolved as a bean
        name by the <tt class="interfacename">BeanFactory</tt> of which the
        <tt class="classname">CommonAnnotationBeanPostProcessor</tt> is aware.
        Note that the names may be resolved via JNDI if Spring's <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jndi/support/SimpleJndiBeanFactory.html" target="_top"><tt class="classname">SimpleJndiBeanFactory</tt></a>
        is configured explicitly. However, it is recommended to rely on the
        default behavior and simply use Spring's JNDI lookup capabilities to
        preserve the level of indirection.</p></td></tr></table></div><p>Similar to <tt class="interfacename">@Autowired</tt>,
      <tt class="interfacename">@Resource</tt> may fall back to standard bean type
      matches (i.e. find a primary type match instead of a specific named bean)
      as well as resolve well-known "resolvable dependencies":
      the <tt class="interfacename">BeanFactory</tt> interface,
      the <tt class="interfacename">ApplicationContext</tt> interface,
      the <tt class="interfacename">ResourceLoader</tt> interface,
      the <tt class="interfacename">ApplicationEventPublisher</tt> interface
      and the <tt class="interfacename">MessageSource</tt> interface.
      Note that this only applies to <tt class="interfacename">@Resource</tt>
      usage with no explicit name specified!</p><p>So the following example will have its <tt class="literal">customerPreferenceDao</tt>
      field looking for a bean with name "customerPreferenceDao" first, then falling
      back to a primary type match for the type <tt class="classname">CustomerPreferenceDao</tt>.
      The "context" field will simply be injected based on the known resolvable dependency
      type <tt class="interfacename">ApplicationContext</tt>.</p><pre class="programlisting">public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-postconstruct-and-predestroy-annotations"></a>3.11.6.&nbsp;<tt class="interfacename">@PostConstruct</tt> and
      <tt class="interfacename">@PreDestroy</tt></h3></div></div><div></div></div><p>The <tt class="classname">CommonAnnotationBeanPostProcessor</tt> not
      only recognizes the <tt class="interfacename">@Resource</tt> annotation
      but also the JSR-250 <span class="emphasis"><em>lifecycle</em></span> annotations.
      Introduced in Spring 2.5, the support for these annotations offers yet
      another alternative to those described in the sections on <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">initialization
      callbacks</a> and <a href="beans.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks">destruction
      callbacks</a>. Provided that the
      <tt class="classname">CommonAnnotationBeanPostProcessor</tt> is registered
      within the Spring <tt class="interfacename">ApplicationContext</tt>, a
      method carrying one of these annotations will be invoked at the same
      point in the lifecycle as the corresponding Spring lifecycle interface's
      method or explicitly declared callback method. In the example below, the
      cache will be pre-populated upon initialization and cleared upon
      destruction.</p><pre class="programlisting">public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        <i class="lineannotation"><span class="lineannotation">// populates the movie cache upon initialization...</span></i>
    }
    
    @PreDestroy
    public void clearMovieCache() {
        <i class="lineannotation"><span class="lineannotation">// clears the movie cache upon destruction...</span></i>
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>For details regarding the effects of combining various lifecycle
        mechanisms, see <a href="beans.html#beans-factory-lifecycle-combined-effects" title="3.5.1.4.&nbsp;Combining lifecycle mechanisms">Section&nbsp;3.5.1.4, &#8220;Combining lifecycle mechanisms&#8221;</a>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-classpath-scanning"></a>3.12.&nbsp;Classpath scanning for managed components</h2></div></div><div></div></div><p>Thus far most of the examples within this chapter have used XML for
    specifying the configuration metadata that produces each
    <tt class="interfacename">BeanDefinition</tt> within the Spring container.
    The previous section (<a href="beans.html#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>)
    demonstrated the possibility of providing a considerable amount of the
    configuration metadata using source-level annotations. Even in those
    examples however, the "base" bean definitions were explicitly defined in
    the XML file while the annotations were driving the dependency injection
    only. The current section introduces an option for implicitly detecting the 
    <span class="emphasis"><em>candidate components</em></span> by scanning the classpath and 
    matching against <span class="emphasis"><em>filters</em></span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-stereotype-annotations"></a>3.12.1.&nbsp;<tt class="interfacename">@Component</tt> and further stereotype
      annotations</h3></div></div><div></div></div><p>Beginning with Spring 2.0, the
      <tt class="interfacename">@Repository</tt> annotation was introduced as
      a marker for any class that fulfills the role or
      <span class="emphasis"><em>stereotype</em></span> of a repository (a.k.a. Data Access
      Object or DAO). Among the possibilities for leveraging such a marker is
      the automatic translation of exceptions as described in <a href="orm.html#orm-jpa-exceptions" title="12.6.4.&nbsp;Exception Translation">Section&nbsp;12.6.4, &#8220;Exception Translation&#8221;</a>.</p><p>Spring 2.5 introduces further stereotype annotations:
      <tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Service</tt> and
      <tt class="interfacename">@Controller</tt>.
      <tt class="interfacename">@Component</tt> serves as a generic stereotype
      for any Spring-managed component; whereas,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt> serve as specializations of
      <tt class="interfacename">@Component</tt> for more specific use cases
      (e.g., in the persistence, service, and presentation layers,
      respectively). What this means is that you can annotate your component
      classes with <tt class="interfacename">@Component</tt>, but by
      annotating them with <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, or
      <tt class="interfacename">@Controller</tt> instead, your classes are
      more properly suited for processing by tools or associating with aspects.
      For example, these stereotype annotations make ideal targets for 
      pointcuts. Of course, it is also possible that
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt> may carry additional
      semantics in future releases of the Spring Framework. Thus, if you are 
      making a decision between using <tt class="interfacename">@Component</tt> 
      or <tt class="interfacename">@Service</tt> for your service layer,
      <tt class="interfacename">@Service</tt> is clearly the better choice.
      Similarly, as stated above, <tt class="interfacename">@Repository</tt>
      is already supported as a marker for automatic exception translation in
      your persistence layer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-autodetection"></a>3.12.2.&nbsp;Auto-detecting components</h3></div></div><div></div></div><p>Spring provides the capability of automatically detecting
      'stereotyped' classes and registering corresponding
      <tt class="interfacename">BeanDefinition</tt>s with the
      <tt class="interfacename">ApplicationContext</tt>. For example, the
      following two classes are eligible for such autodetection:</p><pre class="programlisting">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><pre class="programlisting">@Repository
public class JpaMovieFinder implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity</span></i>
}</pre><p>To autodetect these classes and register the corresponding beans
      requires the inclusion of the following element in XML where
      'basePackage' would be a common parent package for the two classes (or
      alternatively a comma-separated list could be specified that included
      the parent package of each class).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;
               
     &lt;context:component-scan base-package="org.example"/&gt;
     
&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that the scanning of classpath packages requires
        the presence of corresponding directory entries in the classpath.
        When building jars with Ant, make sure to <span class="emphasis"><em>not</em></span>
        activate the files-only switch of the jar task!</p></td></tr></table></div><p>Furthermore, the
      <tt class="interfacename">AutowiredAnnotationBeanPostProcessor</tt> and
      <tt class="interfacename">CommonAnnotationBeanPostProcessor</tt> are
      both included implicitly when using the component-scan element. That
      means that the two components are autodetected <span class="emphasis"><em>and</em></span>
      wired together - all without any bean configuration metadata provided in
      XML.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The registration of those post-processors can be disabled by
        including the <span class="emphasis"><em>annotation-config</em></span> attribute with a
        value of 'false'.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-filters"></a>3.12.3.&nbsp;Using filters to customize scanning</h3></div></div><div></div></div><p>By default, classes annotated with
      <tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, or
      <tt class="interfacename">@Controller</tt> (or classes annotated with a
      custom annotation that itself is annotated with 
      <tt class="interfacename">@Component</tt>) are the only detected
      candidate components. However it is simple to modify and extend this
      behavior by applying custom filters. These can be added as either
      <span class="emphasis"><em>include-filter</em></span> or
      <span class="emphasis"><em>exclude-filter</em></span> sub-elements of the 
      '<tt class="literal">component-scan</tt>' element. Each filter element requires 
      the '<tt class="literal">type</tt>' and '<tt class="literal">expression</tt>'
      attributes. Five filtering options exist as described below.</p><div class="table"><a name="beans-scanning-filters-tbl"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;Filter Types</b></p><table summary="Filter Types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Filter Type</th><th>Example Expression</th><th>Description</th></tr></thead><tbody><tr><td>annotation</td><td><tt class="literal">org.example.SomeAnnotation</tt></td><td>An annotation to be present at the type level in target components.</td></tr><tr><td>assignable</td><td><tt class="literal">org.example.SomeClass</tt></td><td>A class (or interface) that the target components are assignable to (extend/implement).</td></tr><tr><td>aspectj</td><td><tt class="literal">org.example..*Service+</tt></td><td>An AspectJ type expression to be matched by the target components.</td></tr><tr><td>regex</td><td><tt class="literal">org\.example\.Default.*</tt></td><td>A regex expression to be matched by the target components' class names.</td></tr><tr><td>custom</td><td><tt class="literal">org.example.MyCustomTypeFilter</tt></td><td>A custom implementation of the <tt class="interfacename">org.springframework.core.type.TypeFilter</tt> interface.</td></tr></tbody></table></div><p>Find below an example of the XML configuration for ignoring all
      <tt class="interfacename">@Repository</tt> annotations and using "stub"
      repositories instead.</p><pre class="programlisting">&lt;beans ...&gt;

     &lt;context:component-scan base-package="org.example"&gt;
        &lt;context:include-filter type="regex" expression=".*Stub.*Repository"/&gt;
        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt;
     &lt;/context:component-scan&gt;

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It is also possible to disable the default filters by providing
        <span class="emphasis"><em>use-default-filters="false"</em></span> as an attribute of
        the &lt;component-scan/&gt; element. This will in effect disable
        automatic detection of classes annotated with
        <tt class="interfacename">@Component</tt>,
        <tt class="interfacename">@Repository</tt>,
        <tt class="interfacename">@Service</tt>, or
        <tt class="interfacename">@Controller</tt>.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-name-generator"></a>3.12.4.&nbsp;Naming autodetected components</h3></div></div><div></div></div><p>When a component is autodetected as part of the scanning process,
      its bean name will be generated by the
      <tt class="interfacename">BeanNameGenerator</tt> strategy known to that
      scanner. By default, any Spring 'stereotype' annotation
      (<tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt>) that contains a
      <tt class="literal">name</tt> value will thereby provide that name to the
      corresponding bean definition. If such an annotation contains no
      <tt class="literal">name</tt> value or for any other detected component (such as
      those discovered due to custom filters), the default bean name generator
      will return the uncapitalized non-qualified class name. For example, if
      the following two components were detected, the names would be
      'myMovieLister' and 'movieFinderImpl':</p><pre class="programlisting">@Service("myMovieLister")
public class SimpleMovieLister {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Repository
public class MovieFinderImpl implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you don't want to rely on the default bean-naming strategy,
        you may provide a custom bean-naming strategy. First, implement the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/support/BeanNameGenerator.html" target="_top"><tt class="interfacename">BeanNameGenerator</tt></a>
        interface, and be sure to include a default no-arg constructor. Then,
        provide the fully-qualified class name when configuring the
        scanner:</p></td></tr></table></div><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             name-generator="org.example.MyNameGenerator" /&gt;

&lt;/beans&gt;</pre><p>As a general rule, consider specifying the name with the
      annotation whenever other components may be making explicit references
      to it. On the other hand, the auto-generated names are adequate whenever
      the container is responsible for wiring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-scope-resolver"></a>3.12.5.&nbsp;Providing a scope for autodetected components</h3></div></div><div></div></div><p>As with Spring-managed components in general, the default and by
      far most common scope is 'singleton'. However, there are times when
      other scopes are needed. Therefore Spring 2.5 introduces a new
      <tt class="interfacename">@Scope</tt> annotation as well. Simply provide
      the name of the scope within the annotation, such as:</p><pre class="programlisting">@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you would like to provide a custom strategy for scope
        resolution rather than relying on the annotation-based approach,
        implement the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/annotation/ScopeMetadataResolver.html" target="_top"><tt class="interfacename">ScopeMetadataResolver</tt></a>
        interface, and be sure to include a default no-arg constructor. Then,
        provide the fully-qualified class name when configuring the
        scanner:</p></td></tr></table></div><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             scope-resolver="org.example.MyScopeResolver" /&gt;
     
&lt;/beans&gt;</pre><p>When using certain non-singleton scopes, it may be necessary to
      generate proxies for the scoped objects. The reasoning is described in
      detail within the section entitled <a href="beans.html#beans-factory-scopes-other-injection" title="3.4.4.5.&nbsp;Scoped beans as dependencies">Section&nbsp;3.4.4.5, &#8220;Scoped beans as dependencies&#8221;</a>. For this purpose, a
      <span class="emphasis"><em>scoped-proxy</em></span> attribute is available on the
      'component-scan' element. The three possible values are: 'no',
      'interfaces', and 'targetClass'. For example, the following
      configuration will result in standard JDK dynamic proxies:</p><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             scoped-proxy="interfaces" /&gt;
     
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-qualifiers"></a>3.12.6.&nbsp;Providing qualifier metadata with annotations</h3></div></div><div></div></div><p>The <tt class="interfacename">@Qualifier</tt> annotation was
      introduced in the section above entitled
      <a href="beans.html#beans-autowired-annotation-qualifiers" title="3.11.3.&nbsp;Fine-tuning annotation-based autowiring with qualifiers">Section&nbsp;3.11.3, &#8220;Fine-tuning annotation-based autowiring with qualifiers&#8221;</a>. The
      examples in that section demonstrated use of the
      <tt class="interfacename">@Qualifier</tt> annotation as well
      as custom qualifier annotations to provide fine-grained control
      when resolving autowire candidates. Since those examples were
      based on XML bean definitions, the qualifier metadata was provided
      on the candidate bean definitions using the '<tt class="literal">qualifier</tt>'
      or '<tt class="literal">meta</tt>' sub-elements of the '<tt class="literal">bean</tt>'
      element in the XML. When relying upon classpath scanning for 
      autodetection of components, then the qualifier metadata may
      be provided with type-level annotations on the candidate class.
      The following three examples demonstrate this technique.</p><pre class="programlisting">@Component
<span class="bold"><b>@Qualifier("Action")</b></span>
public class ActionMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Component
<span class="bold"><b>@Genre("Action")</b></span>
public class ActionMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Component
<span class="bold"><b>@Offline</b></span>
public class CachingMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top">As with most of the annotation-based alternatives, keep
      in mind that the annotation metadata is bound to the class
      definition itself, while the use of XML allows for multiple
      beans <span class="emphasis"><em>of the same type</em></span> to provide variations
      in their qualifier metadata since that metadata is provided
      per-instance rather than per-class.</td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-load-time-weaver"></a>3.13.&nbsp;Registering a <tt class="interfacename">LoadTimeWeaver</tt></h2></div></div><div></div></div><p>The <tt class="literal">context</tt> namespace introduced in Spring 2.5
    provides a <tt class="literal">load-time-weaver</tt> element.</p><pre class="programlisting">&lt;beans ...&gt;
     
     &lt;context:load-time-weaver/&gt;
     
&lt;/beans&gt;</pre><p>Adding this element to an XML-based Spring configuration file
    activates a Spring <tt class="interfacename">LoadTimeWeaver</tt> for the
    <tt class="interfacename">ApplicationContext</tt>. Any bean within that
    <tt class="interfacename">ApplicationContext</tt> may implement
    <tt class="interfacename">LoadTimeWeaverAware</tt> thereby receiving a
    reference to the load-time weaver instance. This is particularly useful in
    combination with <a href="orm.html#orm-jpa" title="12.6.&nbsp;JPA">Spring's JPA support</a> where
    load-time weaving may be necessary for JPA class transformation. Consult
    the <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> Javadoc
    for more detail. For more on AspectJ load-time weaving, see <a href="aop.html#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e1168" href="#d0e1168">1</a>] </sup>See the section entitled <a href="introduction.html#background-ioc" title="Background">Background</a></p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3240" href="#d0e3240">2</a>] </sup>See the section entitled <a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a></p></div></div></div><!--Begin LoopFuse code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" src="http://loopfuse.net/webrecorder/js/listen.js" type="text/javascript"></script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            _lf_cid = "LF_48be82fa";
            _lf_remora();
        </script><!--End LoopFuse code--><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spring-core.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="resources.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;I.&nbsp;Core Technologies&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Resources</td></tr></table></div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>


<!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script>
<script type="text/javascript">var pageTracker = _gat._getTracker("UA-2728886-3");
pageTracker._setDomainName("none");pageTracker._setAllowLinker(true);
pageTracker._trackPageview();var OrgTracker = _gat._getTracker("UA-2728886-2");
OrgTracker._trackPageview();</script>
 <!-- End 2nd Google code -->



</body>
</html>